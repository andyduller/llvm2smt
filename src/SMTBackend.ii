# 1 "SMTBackend.cc"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "SMTBackend.cc"
# 1 "/usr/include/c++/4.3/iostream" 1 3
# 42 "/usr/include/c++/4.3/iostream" 3
       
# 43 "/usr/include/c++/4.3/iostream" 3

# 1 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++config.h" 1 3
# 40 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/4.3/i486-linux-gnu/bits/os_defines.h" 1 3
# 44 "/usr/include/c++/4.3/i486-linux-gnu/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 330 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 348 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 349 "/usr/include/sys/cdefs.h" 2 3 4
# 331 "/usr/include/features.h" 2 3 4
# 354 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4


# 1 "/usr/include/gnu/stubs-32.h" 1 3 4
# 8 "/usr/include/gnu/stubs.h" 2 3 4
# 355 "/usr/include/features.h" 2 3 4
# 45 "/usr/include/c++/4.3/i486-linux-gnu/bits/os_defines.h" 2 3
# 41 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++config.h" 2 3


# 1 "/usr/include/c++/4.3/i486-linux-gnu/bits/cpu_defines.h" 1 3
# 44 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++config.h" 2 3
# 233 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++config.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 245 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++config.h" 3
}
# 45 "/usr/include/c++/4.3/iostream" 2 3
# 1 "/usr/include/c++/4.3/ostream" 1 3
# 43 "/usr/include/c++/4.3/ostream" 3
       
# 44 "/usr/include/c++/4.3/ostream" 3

# 1 "/usr/include/c++/4.3/ios" 1 3
# 42 "/usr/include/c++/4.3/ios" 3
       
# 43 "/usr/include/c++/4.3/ios" 3

# 1 "/usr/include/c++/4.3/iosfwd" 1 3
# 43 "/usr/include/c++/4.3/iosfwd" 3
       
# 44 "/usr/include/c++/4.3/iosfwd" 3


# 1 "/usr/include/c++/4.3/bits/stringfwd.h" 1 3
# 42 "/usr/include/c++/4.3/bits/stringfwd.h" 3
       
# 43 "/usr/include/c++/4.3/bits/stringfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;


}
# 47 "/usr/include/c++/4.3/iosfwd" 2 3
# 1 "/usr/include/c++/4.3/bits/postypes.h" 1 3
# 45 "/usr/include/c++/4.3/bits/postypes.h" 3
       
# 46 "/usr/include/c++/4.3/bits/postypes.h" 3

# 1 "/usr/include/c++/4.3/cwchar" 1 3
# 46 "/usr/include/c++/4.3/cwchar" 3
       
# 47 "/usr/include/c++/4.3/cwchar" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 152 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 214 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 3 4
typedef unsigned int size_t;
# 49 "/usr/include/c++/4.3/cstddef" 2 3




namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::ptrdiff_t;
  using ::size_t;

}
# 50 "/usr/include/c++/4.3/cwchar" 2 3


# 1 "/usr/include/wchar.h" 1 3 4
# 37 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/stdio.h" 1 3 4
# 45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 38 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stdarg.h" 1 3 4
# 43 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 41 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 43 "/usr/include/wchar.h" 2 3 4
# 52 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 355 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 53 "/usr/include/wchar.h" 2 3 4
# 78 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 99 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;



# 124 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) throw ();


extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) throw ();



# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;
# 173 "/usr/include/wchar.h" 2 3 4

extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (__const wchar_t *__s) throw () __attribute__ ((__malloc__));




extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));

extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));

extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));

extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
     throw () __attribute__ ((__pure__));


extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (__const wchar_t *__s) throw () __attribute__ ((__pure__));




extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
     throw () __attribute__ ((__pure__));




extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));





extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
     throw () __attribute__ ((__pure__));


extern int wmemcmp (__const wchar_t *__restrict __s1,
      __const wchar_t *__restrict __s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (__const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();








extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
btowc (int __c) throw ()
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
wctob (wint_t __wc) throw ()
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
mbrlen (__const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ()

{ return (__ps != __null
   ? mbrtowc (__null, __s, __n, __ps) : __mbrlen (__s, __n, __null)); }





extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (__const wchar_t *__s, size_t __n) throw ();






extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 477 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__dest, __const wchar_t *__src) throw ();



extern wchar_t *wcpncpy (wchar_t *__dest, __const wchar_t *__src, size_t __n)
     throw ();
# 527 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
     throw () ;
# 627 "/usr/include/wchar.h" 3 4









extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 683 "/usr/include/wchar.h" 3 4









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 748 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 774 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 784 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 838 "/usr/include/wchar.h" 3 4
}
# 53 "/usr/include/c++/4.3/cwchar" 2 3
# 70 "/usr/include/c++/4.3/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::mbstate_t;

}
# 144 "/usr/include/c++/4.3/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;

  using ::vswprintf;

  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;

  using ::wcschr;

  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcspbrk;

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wcsrchr;

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcsstr;

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wmemchr;

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }

}







namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  using ::wcstold;
# 262 "/usr/include/c++/4.3/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;


}

namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;

}
# 48 "/usr/include/c++/4.3/bits/postypes.h" 2 3


# 1 "/usr/include/stdint.h" 1 3 4
# 28 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 37 "/usr/include/stdint.h" 3 4
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;



__extension__
typedef long long int int64_t;




typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
# 126 "/usr/include/stdint.h" 3 4
typedef int intptr_t;


typedef unsigned int uintptr_t;
# 138 "/usr/include/stdint.h" 3 4
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;
# 51 "/usr/include/c++/4.3/bits/postypes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 71 "/usr/include/c++/4.3/bits/postypes.h" 3
  typedef int64_t streamoff;





  typedef ptrdiff_t streamsize;
# 90 "/usr/include/c++/4.3/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 112 "/usr/include/c++/4.3/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;

}
# 48 "/usr/include/c++/4.3/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 132 "/usr/include/c++/4.3/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;


  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;



}
# 45 "/usr/include/c++/4.3/ios" 2 3
# 1 "/usr/include/c++/4.3/exception" 1 3
# 40 "/usr/include/c++/4.3/exception" 3
#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 56 "/usr/include/c++/4.3/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 112 "/usr/include/c++/4.3/exception" 3
  bool uncaught_exception() throw();
}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 127 "/usr/include/c++/4.3/exception" 3
  void __verbose_terminate_handler ();

}

}

#pragma GCC visibility pop
# 46 "/usr/include/c++/4.3/ios" 2 3
# 1 "/usr/include/c++/4.3/bits/char_traits.h" 1 3
# 44 "/usr/include/c++/4.3/bits/char_traits.h" 3
       
# 45 "/usr/include/c++/4.3/bits/char_traits.h" 3

# 1 "/usr/include/c++/4.3/bits/stl_algobase.h" 1 3
# 66 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 67 "/usr/include/c++/4.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.3/bits/functexcept.h" 1 3
# 42 "/usr/include/c++/4.3/bits/functexcept.h" 3
# 1 "/usr/include/c++/4.3/exception_defines.h" 1 3
# 43 "/usr/include/c++/4.3/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

}
# 68 "/usr/include/c++/4.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.3/bits/cpp_type_traits.h" 1 3
# 41 "/usr/include/c++/4.3/bits/cpp_type_traits.h" 3
       
# 42 "/usr/include/c++/4.3/bits/cpp_type_traits.h" 3
# 74 "/usr/include/c++/4.3/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  template<typename _Iterator, typename _Container>
    class __normal_iterator;

}

namespace std __attribute__ ((__visibility__ ("default"))) {

  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
# 406 "/usr/include/c++/4.3/bits/cpp_type_traits.h" 3
}
# 69 "/usr/include/c++/4.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.3/ext/type_traits.h" 1 3
# 38 "/usr/include/c++/4.3/ext/type_traits.h" 3
       
# 39 "/usr/include/c++/4.3/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };

  template<typename _Tp>
    struct __promote<_Tp, false>
    { typedef _Tp __type; };

  template<typename _Tp, typename _Up>
    struct __promote_2
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;

    public:
      typedef __typeof__(__type1() + __type2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp>
    struct __promote_3
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;

    public:
      typedef __typeof__(__type1() + __type2() + __type3()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    struct __promote_4
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;
      typedef typename __promote<_Wp>::__type __type4;

    public:
      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;
    };

}
# 70 "/usr/include/c++/4.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.3/ext/numeric_traits.h" 1 3
# 38 "/usr/include/c++/4.3/ext/numeric_traits.h" 3
       
# 39 "/usr/include/c++/4.3/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 58 "/usr/include/c++/4.3/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 103 "/usr/include/c++/4.3/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 3010 / 10000);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };

}
# 71 "/usr/include/c++/4.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.3/bits/stl_pair.h" 1 3
# 65 "/usr/include/c++/4.3/bits/stl_pair.h" 3
# 1 "/usr/include/c++/4.3/bits/stl_move.h" 1 3
# 39 "/usr/include/c++/4.3/bits/stl_move.h" 3
# 1 "/usr/include/c++/4.3/bits/concept_check.h" 1 3
# 38 "/usr/include/c++/4.3/bits/concept_check.h" 3
       
# 39 "/usr/include/c++/4.3/bits/concept_check.h" 3
# 40 "/usr/include/c++/4.3/bits/stl_move.h" 2 3
# 70 "/usr/include/c++/4.3/bits/stl_move.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {







  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }

}
# 66 "/usr/include/c++/4.3/bits/stl_pair.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {


  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 103 "/usr/include/c++/4.3/bits/stl_pair.h" 3
      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first),
   second(__p.second) { }
# 146 "/usr/include/c++/4.3/bits/stl_pair.h" 3
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 216 "/usr/include/c++/4.3/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }
# 262 "/usr/include/c++/4.3/bits/stl_pair.h" 3
}
# 72 "/usr/include/c++/4.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.3/bits/stl_iterator_base_types.h" 1 3
# 68 "/usr/include/c++/4.3/bits/stl_iterator_base_types.h" 3
       
# 69 "/usr/include/c++/4.3/bits/stl_iterator_base_types.h" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 72 "/usr/include/c++/4.3/bits/stl_iterator_base_types.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 84 "/usr/include/c++/4.3/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag {};

  struct output_iterator_tag {};

  struct forward_iterator_tag : public input_iterator_tag {};


  struct bidirectional_iterator_tag : public forward_iterator_tag {};


  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
# 108 "/usr/include/c++/4.3/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

}
# 73 "/usr/include/c++/4.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.3/bits/stl_iterator_base_funcs.h" 1 3
# 68 "/usr/include/c++/4.3/bits/stl_iterator_base_funcs.h" 3
       
# 69 "/usr/include/c++/4.3/bits/stl_iterator_base_funcs.h" 3


namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 113 "/usr/include/c++/4.3/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 171 "/usr/include/c++/4.3/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }

}
# 74 "/usr/include/c++/4.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.3/bits/stl_iterator.h" 1 3
# 73 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 94 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 281 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() - __x.base(); }
# 385 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 411 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
# 428 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 454 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 469 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 494 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
# 511 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 537 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 556 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 598 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
# 617 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 643 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }

}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 662 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 760 "/usr/include/c++/4.3/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }

}
# 75 "/usr/include/c++/4.3/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/4.3/debug/debug.h" 1 3
# 52 "/usr/include/c++/4.3/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 77 "/usr/include/c++/4.3/bits/stl_algobase.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {




  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 119 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;


     

     

     

     


      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 159 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 186 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 208 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 230 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 250 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }




  template<typename _Iterator,
    bool _IsNormal = __is_normal_iterator<_Iterator>::__value>
    struct __niter_base
    {
      static _Iterator
      __b(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct __niter_base<_Iterator, true>
    {
      static typename _Iterator::iterator_type
      __b(_Iterator __it)
      { return __it.base(); }
    };


  template<typename _Iterator,
    bool _IsMove = __is_move_iterator<_Iterator>::__value>
    struct __miter_base
    {
      static _Iterator
      __b(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct __miter_base<_Iterator, true>
    {
      static typename _Iterator::iterator_type
      __b(_Iterator __it)
      { return __it.base(); }
    };







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
# 332 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
# 370 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   __builtin_memmove(__result, __first,
       sizeof(_Tp) * (__last - __first));
   return __result + (__last - __first);
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>
   (std::__niter_base<_II>::__b(__first),
    std::__niter_base<_II>::__b(__last),
    std::__niter_base<_OI>::__b(__result)));
    }
# 454 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base<_II>::__b(__first),
        std::__miter_base<_II>::__b(__last), __result));
    }
# 506 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
# 534 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
# 564 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base<_BI1>::__b(__first),
     std::__niter_base<_BI1>::__b(__last),
     std::__niter_base<_BI2>::__b(__result)));
    }
# 622 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base<_BI1>::__b(__first),
        std::__miter_base<_BI1>::__b(__last), __result));
    }
# 679 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 722 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base<_ForwardIterator>::__b(__first),
      std::__niter_base<_ForwardIterator>::__b(__last), __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 776 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base<_OI>::__b(__first),
     __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 942 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base<_II1>::__b(__first1),
         std::__niter_base<_II1>::__b(__last1),
         std::__niter_base<_II2>::__b(__first2));
    }
# 973 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1003 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux
 (std::__niter_base<_II1>::__b(__first1),
  std::__niter_base<_II1>::__b(__last1),
  std::__niter_base<_II2>::__b(__first2),
  std::__niter_base<_II2>::__b(__last2));
    }
# 1037 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;


     
     
      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1076 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1112 "/usr/include/c++/4.3/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }

}
# 47 "/usr/include/c++/4.3/bits/char_traits.h" 2 3

# 1 "/usr/include/c++/4.3/cstdio" 1 3
# 46 "/usr/include/c++/4.3/cstdio" 3
       
# 47 "/usr/include/c++/4.3/cstdio" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 50 "/usr/include/c++/4.3/cstdio" 2 3
# 1 "/usr/include/stdio.h" 1 3 4
# 30 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 131 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 132 "/usr/include/bits/types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 37 "/usr/include/stdio.h" 2 3 4
# 75 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 21 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 53 "/usr/include/_G_config.h" 3 4
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stdarg.h" 1 3 4
# 54 "/usr/include/libio.h" 2 3 4
# 170 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 180 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 203 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 271 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 319 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 328 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 364 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 458 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 488 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 550 "/usr/include/libio.h" 3 4
}
# 76 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 89 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 141 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 142 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename) throw ();

extern int rename (__const char *__old, __const char *__new) throw ();




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) throw ();








extern FILE *tmpfile (void) ;
# 182 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 229 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes) ;




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 272 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) ;
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, __const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;


extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;







extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) throw ();
# 441 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 500 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 528 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 539 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 572 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

# 618 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 634 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) ;

# 695 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
# 706 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream) ;








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 742 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 761 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 784 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (__const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 823 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 842 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 903 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio.h" 1 3 4
# 36 "/usr/include/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (__const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 904 "/usr/include/stdio.h" 2 3 4
# 912 "/usr/include/stdio.h" 3 4
}
# 51 "/usr/include/c++/4.3/cstdio" 2 3
# 98 "/usr/include/c++/4.3/cstdio" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;

}
# 155 "/usr/include/c++/4.3/cstdio" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 170 "/usr/include/c++/4.3/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;


}

namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;

}
# 49 "/usr/include/c++/4.3/bits/char_traits.h" 2 3
# 1 "/usr/include/c++/4.3/cwchar" 1 3
# 46 "/usr/include/c++/4.3/cwchar" 3
       
# 47 "/usr/include/c++/4.3/cwchar" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 50 "/usr/include/c++/4.3/cwchar" 2 3
# 50 "/usr/include/c++/4.3/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 63 "/usr/include/c++/4.3/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 88 "/usr/include/c++/4.3/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 229 "/usr/include/c++/4.3/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c) { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c) { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };


}
# 47 "/usr/include/c++/4.3/ios" 2 3
# 1 "/usr/include/c++/4.3/bits/localefwd.h" 1 3
# 44 "/usr/include/c++/4.3/bits/localefwd.h" 3
       
# 45 "/usr/include/c++/4.3/bits/localefwd.h" 3


# 1 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++locale.h" 1 3
# 45 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++locale.h" 3
       
# 46 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++locale.h" 3

# 1 "/usr/include/c++/4.3/clocale" 1 3
# 45 "/usr/include/c++/4.3/clocale" 3
       
# 46 "/usr/include/c++/4.3/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 29 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 27 "/usr/include/bits/locale.h" 3 4
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
# 31 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, __const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


# 148 "/usr/include/locale.h" 3 4
typedef __locale_t locale_t;





extern __locale_t newlocale (int __category_mask, __const char *__locale,
        __locale_t __base) throw ();
# 189 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 49 "/usr/include/c++/4.3/clocale" 2 3
# 57 "/usr/include/c++/4.3/clocale" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::lconv;
  using ::setlocale;
  using ::localeconv;

}
# 48 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++locale.h" 2 3
# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 49 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  extern "C" __typeof(uselocale) __uselocale;

}


namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 90 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }

}
# 48 "/usr/include/c++/4.3/bits/localefwd.h" 2 3

# 1 "/usr/include/c++/4.3/cctype" 1 3
# 46 "/usr/include/c++/4.3/cctype" 3
       
# 47 "/usr/include/c++/4.3/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 30 "/usr/include/ctype.h" 3 4
extern "C" {
# 41 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 42 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__const));
# 96 "/usr/include/ctype.h" 3 4






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 247 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 323 "/usr/include/ctype.h" 3 4
}
# 50 "/usr/include/c++/4.3/cctype" 2 3
# 69 "/usr/include/c++/4.3/cctype" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;

}
# 50 "/usr/include/c++/4.3/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

}
# 48 "/usr/include/c++/4.3/ios" 2 3
# 1 "/usr/include/c++/4.3/bits/ios_base.h" 1 3
# 44 "/usr/include/c++/4.3/bits/ios_base.h" 3
       
# 45 "/usr/include/c++/4.3/bits/ios_base.h" 3

# 1 "/usr/include/c++/4.3/ext/atomicity.h" 1 3
# 39 "/usr/include/c++/4.3/ext/atomicity.h" 3
# 1 "/usr/include/c++/4.3/i486-linux-gnu/bits/gthr.h" 1 3
# 33 "/usr/include/c++/4.3/i486-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 132 "/usr/include/c++/4.3/i486-linux-gnu/bits/gthr.h" 3
# 1 "/usr/include/c++/4.3/i486-linux-gnu/bits/gthr-default.h" 1 3
# 43 "/usr/include/c++/4.3/i486-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 25 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4


# 1 "/usr/include/time.h" 1 3 4
# 121 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 33 "/usr/include/sched.h" 2 3 4


# 1 "/usr/include/bits/sched.h" 1 3 4
# 66 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


}







struct __sched_param
  {
    int __sched_priority;
  };
# 108 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 186 "/usr/include/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 36 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          __const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 110 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         __const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 26 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 31 "/usr/include/time.h" 3 4
extern "C" {







# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 40 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 44 "/usr/include/time.h" 2 3 4
# 59 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 75 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 93 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 105 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 132 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;








extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) throw ();





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();

extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (__const time_t *__timer) throw ();



extern struct tm *localtime (__const time_t *__timer) throw ();





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (__const struct tm *__tp) throw ();


extern char *ctime (__const time_t *__timer) throw ();







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) throw ();
# 312 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 327 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();
# 389 "/usr/include/time.h" 3 4
extern int getdate_err;
# 398 "/usr/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
# 412 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 27 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/signal.h" 1 3 4
# 31 "/usr/include/signal.h" 3 4
extern "C" {

# 1 "/usr/include/bits/sigset.h" 1 3 4
# 24 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/signal.h" 2 3 4
# 50 "/usr/include/signal.h" 3 4
typedef __sigset_t sigset_t;
# 402 "/usr/include/signal.h" 3 4
}
# 30 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 50 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;
# 67 "/usr/include/bits/pthreadtypes.h" 3 4
typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;





typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;





    int __kind;





    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };

  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
# 170 "/usr/include/bits/pthreadtypes.h" 3 4
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;


    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;
    int __writer;
  } __data;

  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 31 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/setjmp.h" 2 3 4






typedef int __jmp_buf[6];
# 32 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 33 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED_NP,
  PTHREAD_MUTEX_ROBUST_NP
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 115 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 147 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 182 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 220 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      __const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     __const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ();







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
           __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           __const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      __const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 466 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 478 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 512 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 652 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__regparm__ (1)));
# 663 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
  __attribute__ ((__regparm__ (1)));
# 686 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__regparm__ (1)));
# 698 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
  __attribute__ ((__regparm__ (1)));



extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__regparm__ (1))) __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;



struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          __const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
                                    __const struct timespec *__restrict
                                    __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 846 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    __const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         __const pthread_condattr_t *__restrict
         __cond_attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 958 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __const struct timespec *__restrict
       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (__const pthread_condattr_t *
                                        __restrict __attr,
                                        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
                                        int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (__const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1002 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     __const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
                                           int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1069 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    __const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1103 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();




extern __inline __attribute__ ((__gnu_inline__)) int
pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ()
{
  return __thread1 == __thread2;
}


}
# 44 "/usr/include/c++/4.3/i486-linux-gnu/bits/gthr-default.h" 2 3
# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4
extern "C" {
# 173 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 174 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 23 "/usr/include/bits/environments.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/environments.h" 2 3 4
# 178 "/usr/include/unistd.h" 2 3 4
# 191 "/usr/include/unistd.h" 3 4
typedef __ssize_t ssize_t;





# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 198 "/usr/include/unistd.h" 2 3 4





typedef __gid_t gid_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __useconds_t useconds_t;
# 245 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 258 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 301 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 312 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
# 343 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
         __off_t __offset) ;
# 371 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;
# 393 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 405 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 429 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 471 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();






extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();


extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) throw () __attribute__ ((__nonnull__ (1)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     throw ();




extern int execv (__const char *__path, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));



extern int execle (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));



extern int execl (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));



extern int execvp (__const char *__file, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));




extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/bits/confname.h" 1 3 4
# 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS

  };
# 555 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();




extern __pid_t getpgrp (void) throw ();
# 591 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 617 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();
# 634 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw ();




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw ();




extern int seteuid (__uid_t __uid) throw ();






extern int setgid (__gid_t __gid) throw ();




extern int setregid (__gid_t __rgid, __gid_t __egid) throw ();




extern int setegid (__gid_t __gid) throw ();





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw ();



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw ();






extern __pid_t fork (void) throw ();






extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, __const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 837 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 50 "/usr/include/getopt.h" 3 4
extern "C" {
# 59 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 73 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 152 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 171 "/usr/include/getopt.h" 3 4
}
# 838 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (__const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
# 923 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) throw ();




extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();




extern int truncate (__const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 960 "/usr/include/unistd.h" 3 4
extern int truncate64 (__const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 970 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
# 980 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 990 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1011 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1034 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1044 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1065 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (__const char *__key, __const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));






extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));







extern char *ctermid (char *__s) throw ();
# 1103 "/usr/include/unistd.h" 3 4
}
# 45 "/usr/include/c++/4.3/i486-linux-gnu/bits/gthr-default.h" 2 3

typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
# 100 "/usr/include/c++/4.3/i486-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));
static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));
static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));
static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));


static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 211 "/usr/include/c++/4.3/i486-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw_pthread_cancel;
  return __gthread_active_ptr != 0;
}
# 649 "/usr/include/c++/4.3/i486-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_once (__gthread_once_t *once, void (*func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (once, func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))
{
  return __gthrw_pthread_key_create (key, dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t key)
{
  return __gthrw_pthread_key_delete (key);
}

static inline void *
__gthread_getspecific (__gthread_key_t key)
{
  return __gthrw_pthread_getspecific (key);
}

static inline int
__gthread_setspecific (__gthread_key_t key, const void *ptr)
{
  return __gthrw_pthread_setspecific (key, ptr);
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (mutex);
  else
    return 0;
}
# 731 "/usr/include/c++/4.3/i486-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_lock (mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_trylock (mutex);
}

static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_unlock (mutex);
}

static inline int
__gthread_cond_broadcast (__gthread_cond_t *cond)
{
  return __gthrw_pthread_cond_broadcast (cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *cond, __gthread_mutex_t *mutex)
{
  return __gthrw_pthread_cond_wait (cond, mutex);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *cond,
          __gthread_recursive_mutex_t *mutex)
{
  return __gthread_cond_wait (cond, mutex);
}
# 133 "/usr/include/c++/4.3/i486-linux-gnu/bits/gthr.h" 2 3







#pragma GCC visibility pop
# 40 "/usr/include/c++/4.3/ext/atomicity.h" 2 3
# 1 "/usr/include/c++/4.3/i486-linux-gnu/bits/atomic_word.h" 1 3
# 37 "/usr/include/c++/4.3/i486-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 41 "/usr/include/c++/4.3/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
# 66 "/usr/include/c++/4.3/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }

}
# 47 "/usr/include/c++/4.3/bits/ios_base.h" 2 3

# 1 "/usr/include/c++/4.3/bits/locale_classes.h" 1 3
# 44 "/usr/include/c++/4.3/bits/locale_classes.h" 3
       
# 45 "/usr/include/c++/4.3/bits/locale_classes.h" 3


# 1 "/usr/include/c++/4.3/string" 1 3
# 43 "/usr/include/c++/4.3/string" 3
       
# 44 "/usr/include/c++/4.3/string" 3




# 1 "/usr/include/c++/4.3/bits/allocator.h" 1 3
# 53 "/usr/include/c++/4.3/bits/allocator.h" 3
# 1 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++allocator.h" 1 3
# 39 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++allocator.h" 3
# 1 "/usr/include/c++/4.3/ext/new_allocator.h" 1 3
# 37 "/usr/include/c++/4.3/ext/new_allocator.h" 3
# 1 "/usr/include/c++/4.3/new" 1 3
# 44 "/usr/include/c++/4.3/new" 3
# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 45 "/usr/include/c++/4.3/new" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace std
{





  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 95 "/usr/include/c++/4.3/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 38 "/usr/include/c++/4.3/ext/new_allocator.h" 2 3



namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  using std::size_t;
  using std::ptrdiff_t;
# 53 "/usr/include/c++/4.3/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__builtin_expect(__n > this->max_size(), false))
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
# 117 "/usr/include/c++/4.3/ext/new_allocator.h" 3
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }

}
# 40 "/usr/include/c++/4.3/i486-linux-gnu/bits/c++allocator.h" 2 3
# 54 "/usr/include/c++/4.3/bits/allocator.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };







  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };

}
# 49 "/usr/include/c++/4.3/string" 2 3


# 1 "/usr/include/c++/4.3/bits/ostream_insert.h" 1 3
# 38 "/usr/include/c++/4.3/bits/ostream_insert.h" 3
       
# 39 "/usr/include/c++/4.3/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/4.3/cxxabi-forced.h" 1 3
# 34 "/usr/include/c++/4.3/cxxabi-forced.h" 3
#pragma GCC visibility push(default)


namespace __cxxabiv1
{


  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();
    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 42 "/usr/include/c++/4.3/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   if (true)
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   if (false)
     {
       __out._M_setstate(__ios_base::badbit);
       ;
     }
   if (false)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }





  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);



}
# 52 "/usr/include/c++/4.3/string" 2 3



# 1 "/usr/include/c++/4.3/bits/stl_function.h" 1 3
# 65 "/usr/include/c++/4.3/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 102 "/usr/include/c++/4.3/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {
      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
# 136 "/usr/include/c++/4.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 198 "/usr/include/c++/4.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 260 "/usr/include/c++/4.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 341 "/usr/include/c++/4.3/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 410 "/usr/include/c++/4.3/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };

  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 515 "/usr/include/c++/4.3/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }



}


# 1 "/usr/include/c++/4.3/backward/binders.h" 1 3
# 65 "/usr/include/c++/4.3/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 99 "/usr/include/c++/4.3/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }


}
# 705 "/usr/include/c++/4.3/bits/stl_function.h" 2 3
# 56 "/usr/include/c++/4.3/string" 2 3


# 1 "/usr/include/c++/4.3/bits/basic_string.h" 1 3
# 44 "/usr/include/c++/4.3/bits/basic_string.h" 3
       
# 45 "/usr/include/c++/4.3/bits/basic_string.h" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 108 "/usr/include/c++/4.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 145 "/usr/include/c++/4.3/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 170 "/usr/include/c++/4.3/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {
   this->_M_set_sharable();
   this->_M_length = __n;
   traits_type::assign(this->_M_refdata()[__n], _S_terminal);


 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
             -1) <= 0)
       _M_destroy(__a);
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      inline
      basic_string();




      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 464 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());







      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 519 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }






      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }

    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 630 "/usr/include/c++/4.3/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 643 "/usr/include/c++/4.3/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }





      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 672 "/usr/include/c++/4.3/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }




      bool
      empty() const
      { return this->size() == 0; }
# 700 "/usr/include/c++/4.3/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
# 717 "/usr/include/c++/4.3/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 738 "/usr/include/c++/4.3/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 757 "/usr/include/c++/4.3/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }






      basic_string&
      append(const basic_string& __str);
# 817 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 849 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
# 860 "/usr/include/c++/4.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 899 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 915 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 927 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 943 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 955 "/usr/include/c++/4.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 972 "/usr/include/c++/4.3/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 987 "/usr/include/c++/4.3/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1003 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1025 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1048 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1066 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1089 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1106 "/usr/include/c++/4.3/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1130 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1146 "/usr/include/c++/4.3/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {
 ;

 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1166 "/usr/include/c++/4.3/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 ;

        const size_type __pos = __first - _M_ibegin();
 _M_mutate(__pos, __last - __first, size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1193 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1215 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1239 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1258 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1281 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1299 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1317 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {
 ;

 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1338 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1359 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {
 ;

 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1381 "/usr/include/c++/4.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
   ;

   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct(static_cast<size_type>(__beg), __end, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1513 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1523 "/usr/include/c++/4.3/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1533 "/usr/include/c++/4.3/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1565 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1578 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1592 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1609 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1622 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1637 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1650 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1667 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1680 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1695 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1708 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1727 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1741 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1756 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1769 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 1788 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 1802 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 1817 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 1831 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 1848 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 1861 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 1877 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 1890 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 1907 "/usr/include/c++/4.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 1922 "/usr/include/c++/4.3/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 1940 "/usr/include/c++/4.3/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 1970 "/usr/include/c++/4.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 1994 "/usr/include/c++/4.3/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2012 "/usr/include/c++/4.3/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2035 "/usr/include/c++/4.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2060 "/usr/include/c++/4.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()

    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
# 2081 "/usr/include/c++/4.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2152 "/usr/include/c++/4.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2198 "/usr/include/c++/4.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2235 "/usr/include/c++/4.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2272 "/usr/include/c++/4.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2309 "/usr/include/c++/4.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2346 "/usr/include/c++/4.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2383 "/usr/include/c++/4.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2400 "/usr/include/c++/4.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2418 "/usr/include/c++/4.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2441 "/usr/include/c++/4.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2458 "/usr/include/c++/4.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);


}
# 59 "/usr/include/c++/4.3/string" 2 3


# 1 "/usr/include/c++/4.3/bits/basic_string.tcc" 1 3
# 47 "/usr/include/c++/4.3/bits/basic_string.tcc" 3
       
# 48 "/usr/include/c++/4.3/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 if (true)
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 if (false)
   {
     __r->_M_destroy(__a);
     ;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__builtin_expect(__gnu_cxx::__is_null_pointer(__beg)
        && __beg != __end, 0))
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 if (true)
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 if (false)
   {
     __r->_M_destroy(__a);
     ;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 552 "/usr/include/c++/4.3/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   if (true)
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   if (false)
     {
       __in._M_setstate(__ios_base::badbit);
       ;
     }
   if (false)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   if (true)
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   if (false)
     {
       __in._M_setstate(__ios_base::badbit);
       ;
     }
   if (false)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);



}
# 62 "/usr/include/c++/4.3/string" 2 3
# 48 "/usr/include/c++/4.3/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 66 "/usr/include/c++/4.3/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 102 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 121 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    locale() throw();
# 130 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 140 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 155 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 168 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 180 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 194 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 209 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 228 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw ();







    bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }
# 256 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 272 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 307 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 340 "/usr/include/c++/4.3/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 371 "/usr/include/c++/4.3/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);

    static void
    _S_destroy_c_locale(__c_locale& __cloc);



    static __c_locale
    _S_get_c_locale();

    static const char*
    _S_get_c_name();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   if (true)
     { delete this; }
   if (false)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 431 "/usr/include/c++/4.3/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const;
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   if (true)
     { delete this; }
   if (false)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
# 574 "/usr/include/c++/4.3/bits/locale_classes.h" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
# 591 "/usr/include/c++/4.3/bits/locale_classes.h" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
# 608 "/usr/include/c++/4.3/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 635 "/usr/include/c++/4.3/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 649 "/usr/include/c++/4.3/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 666 "/usr/include/c++/4.3/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 685 "/usr/include/c++/4.3/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 699 "/usr/include/c++/4.3/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 728 "/usr/include/c++/4.3/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 744 "/usr/include/c++/4.3/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 757 "/usr/include/c++/4.3/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const;

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const;



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };

}


# 1 "/usr/include/c++/4.3/bits/locale_classes.tcc" 1 3
# 42 "/usr/include/c++/4.3/bits/locale_classes.tcc" 3
       
# 43 "/usr/include/c++/4.3/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      if (true)
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      if (false)
 {
   _M_impl->_M_remove_reference();
   ;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      if (true)
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      if (false)
 {
   __tmp->_M_remove_reference();
   ;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }


  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size



              && static_cast<const _Facet*>(__facets[__i]));

    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();



      return static_cast<const _Facet&>(*__facets[__i]);

    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      if (true)
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      if (false)
 {
   delete [] __c;
   ;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }





  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);



}
# 815 "/usr/include/c++/4.3/bits/locale_classes.h" 2 3
# 49 "/usr/include/c++/4.3/bits/ios_base.h" 2 3
# 1 "/usr/include/c++/4.3/cstdio" 1 3
# 46 "/usr/include/c++/4.3/cstdio" 3
       
# 47 "/usr/include/c++/4.3/cstdio" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 50 "/usr/include/c++/4.3/cstdio" 2 3
# 50 "/usr/include/c++/4.3/bits/ios_base.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {





  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 203 "/usr/include/c++/4.3/bits/ios_base.h" 3
  class ios_base
  {
  public:



    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 255 "/usr/include/c++/4.3/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 330 "/usr/include/c++/4.3/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 361 "/usr/include/c++/4.3/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;





    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 394 "/usr/include/c++/4.3/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 420 "/usr/include/c++/4.3/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 437 "/usr/include/c++/4.3/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
# 449 "/usr/include/c++/4.3/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:




    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;




    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void);


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 558 "/usr/include/c++/4.3/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 574 "/usr/include/c++/4.3/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 591 "/usr/include/c++/4.3/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 617 "/usr/include/c++/4.3/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 668 "/usr/include/c++/4.3/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 680 "/usr/include/c++/4.3/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc);
# 691 "/usr/include/c++/4.3/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 702 "/usr/include/c++/4.3/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 721 "/usr/include/c++/4.3/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 737 "/usr/include/c++/4.3/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 758 "/usr/include/c++/4.3/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 775 "/usr/include/c++/4.3/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

}
# 49 "/usr/include/c++/4.3/ios" 2 3
# 1 "/usr/include/c++/4.3/streambuf" 1 3
# 42 "/usr/include/c++/4.3/streambuf" 3
       
# 43 "/usr/include/c++/4.3/streambuf" 3
# 51 "/usr/include/c++/4.3/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 118 "/usr/include/c++/4.3/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
# 184 "/usr/include/c++/4.3/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 208 "/usr/include/c++/4.3/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 225 "/usr/include/c++/4.3/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 238 "/usr/include/c++/4.3/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 265 "/usr/include/c++/4.3/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 279 "/usr/include/c++/4.3/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 297 "/usr/include/c++/4.3/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 319 "/usr/include/c++/4.3/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 338 "/usr/include/c++/4.3/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 352 "/usr/include/c++/4.3/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 377 "/usr/include/c++/4.3/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 404 "/usr/include/c++/4.3/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 430 "/usr/include/c++/4.3/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 444 "/usr/include/c++/4.3/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 462 "/usr/include/c++/4.3/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 478 "/usr/include/c++/4.3/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 489 "/usr/include/c++/4.3/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 509 "/usr/include/c++/4.3/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 525 "/usr/include/c++/4.3/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 535 "/usr/include/c++/4.3/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 556 "/usr/include/c++/4.3/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
# 571 "/usr/include/c++/4.3/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 582 "/usr/include/c++/4.3/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 594 "/usr/include/c++/4.3/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 607 "/usr/include/c++/4.3/streambuf" 3
      virtual int
      sync() { return 0; }
# 629 "/usr/include/c++/4.3/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 645 "/usr/include/c++/4.3/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 667 "/usr/include/c++/4.3/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 680 "/usr/include/c++/4.3/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 704 "/usr/include/c++/4.3/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 722 "/usr/include/c++/4.3/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 747 "/usr/include/c++/4.3/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 762 "/usr/include/c++/4.3/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }


    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);


}


# 1 "/usr/include/c++/4.3/bits/streambuf.tcc" 1 3
# 43 "/usr/include/c++/4.3/bits/streambuf.tcc" 3
       
# 44 "/usr/include/c++/4.3/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);



}
# 802 "/usr/include/c++/4.3/streambuf" 2 3
# 50 "/usr/include/c++/4.3/ios" 2 3
# 1 "/usr/include/c++/4.3/bits/basic_ios.h" 1 3
# 40 "/usr/include/c++/4.3/bits/basic_ios.h" 3
       
# 41 "/usr/include/c++/4.3/bits/basic_ios.h" 3



# 1 "/usr/include/c++/4.3/bits/locale_facets.h" 1 3
# 44 "/usr/include/c++/4.3/bits/locale_facets.h" 3
       
# 45 "/usr/include/c++/4.3/bits/locale_facets.h" 3

# 1 "/usr/include/c++/4.3/cwctype" 1 3
# 46 "/usr/include/c++/4.3/cwctype" 3
       
# 47 "/usr/include/c++/4.3/cwctype" 3




# 1 "/usr/include/wctype.h" 1 3 4
# 50 "/usr/include/wctype.h" 3 4



typedef unsigned long int wctype_t;

# 72 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {








extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 172 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (__const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();










typedef __const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 214 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (__const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();








extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (__const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (__const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 52 "/usr/include/c++/4.3/cwctype" 2 3
# 81 "/usr/include/c++/4.3/cwctype" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;

}
# 47 "/usr/include/c++/4.3/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.3/cctype" 1 3
# 46 "/usr/include/c++/4.3/cctype" 3
       
# 47 "/usr/include/c++/4.3/cctype" 3
# 48 "/usr/include/c++/4.3/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.3/i486-linux-gnu/bits/ctype_base.h" 1 3
# 42 "/usr/include/c++/4.3/i486-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };

}
# 49 "/usr/include/c++/4.3/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/4.3/bits/streambuf_iterator.h" 1 3
# 40 "/usr/include/c++/4.3/bits/streambuf_iterator.h" 3
       
# 41 "/usr/include/c++/4.3/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {
 ;


 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {
 ;



 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }

}
# 56 "/usr/include/c++/4.3/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 69 "/usr/include/c++/4.3/bits/locale_facets.h" 3
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
     const __c_locale& __cloc);


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&);



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, const streamsize __newlen,
      const streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "/usr/include/c++/4.3/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 167 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 184 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 200 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 216 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 230 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 245 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 259 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 274 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 291 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 310 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 329 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 351 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 376 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 395 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 414 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 433 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 451 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
# 468 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 484 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
# 501 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 520 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
# 541 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
# 563 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
# 587 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
# 610 "/usr/include/c++/4.3/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 679 "/usr/include/c++/4.3/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 716 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 729 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 742 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 757 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 771 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 785 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 800 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 817 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 833 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 850 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 870 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 897 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 928 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 961 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1010 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1027 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1043 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1060 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1080 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1103 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
# 1129 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
# 1155 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:

      void _M_widen_init() const
      {
 char __tmp[sizeof(_M_widen)];
 for (size_t __i = 0; __i < sizeof(_M_widen); ++__i)
   __tmp[__i] = __i;
 do_widen(__tmp, __tmp + sizeof(__tmp), _M_widen);

 _M_widen_ok = 1;

 if (__builtin_memcmp(__tmp, _M_widen, sizeof(_M_widen)))
   _M_widen_ok = 2;
      }




      void _M_narrow_init() const
      {
 char __tmp[sizeof(_M_narrow)];
 for (size_t __i = 0; __i < sizeof(_M_narrow); ++__i)
   __tmp[__i] = __i;
 do_narrow(__tmp, __tmp + sizeof(__tmp), 0, _M_narrow);

 _M_narrow_ok = 1;
 if (__builtin_memcmp(__tmp, _M_narrow, sizeof(_M_narrow)))
   _M_narrow_ok = 2;
 else
   {


     char __c;
     do_narrow(__tmp, __tmp + 1, 1, &__c);
     if (__c == 1)
       _M_narrow_ok = 2;
   }
      }
    };

  template<>
    const ctype<char>&
    use_facet<ctype<char> >(const locale& __loc);
# 1219 "/usr/include/c++/4.3/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1252 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1263 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const;


      virtual
      ~ctype();
# 1287 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1306 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1324 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1342 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1359 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1376 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1392 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1409 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1429 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const;
# 1451 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
# 1474 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const;
# 1500 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;


      void
      _M_initialize_ctype();
    };

  template<>
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale& __loc);



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


}


# 1 "/usr/include/c++/4.3/i486-linux-gnu/bits/ctype_inline.h" 1 3
# 42 "/usr/include/c++/4.3/i486-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }

}
# 1560 "/usr/include/c++/4.3/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod);
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1684 "/usr/include/c++/4.3/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
# 1721 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1735 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
# 1749 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1762 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1793 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1806 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1819 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1836 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1848 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1861 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1874 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1887 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };


# 1956 "/usr/include/c++/4.3/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1977 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 2003 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2039 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2098 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2140 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string& __xtrc) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT& __v) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2211 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
       unsigned short&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned int&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
# 2270 "/usr/include/c++/4.3/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2287 "/usr/include/c++/4.3/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2308 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2326 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2368 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2431 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2456 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2504 "/usr/include/c++/4.3/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }

}


# 1 "/usr/include/c++/4.3/bits/locale_facets.tcc" 1 3
# 40 "/usr/include/c++/4.3/bits/locale_facets.tcc" 3
       
# 41 "/usr/include/c++/4.3/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     if (true)
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     if (false)
       {
  delete __tmp;
  ;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      _M_grouping_size = __np.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __np.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(__np.grouping()[0]) > 0);

      _M_truename_size = __np.truename().size();
      _CharT* __truename = new _CharT[_M_truename_size];
      __np.truename().copy(__truename, _M_truename_size);
      _M_truename = __truename;

      _M_falsename_size = __np.falsename().size();
      _CharT* __falsename = new _CharT[_M_falsename_size];
      __np.falsename().copy(__falsename, _M_falsename_size);
      _M_falsename = __falsename;

      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
   __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
      __ct.widen(__num_base::_S_atoms_in,
   __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);
    }
# 124 "/usr/include/c++/4.3/bits/locale_facets.tcc" 3
  bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp);



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err |= ios_base::failbit;
        }


      if (__testeof)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     if (__gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 const __unsigned_type __max = __negative
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testfail = true;
       else
  {
    __result *= __base;
    __testfail |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testfail = true;
    else
      {
        __result *= __base;
        __testfail |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err |= ios_base::failbit;
   }

 if (!__testfail && (__sep_pos || __found_zero
       || __found_grouping.size()))
   __v = __negative ? -__result : __result;
 else
   __err |= ios_base::failbit;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
            __err |= ios_base::failbit;
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   size_t __n;
   bool __testeof = __beg == __end;
          for (__n = 0; !__testeof; ++__n)
            {
       const char_type __c = *__beg;

       if (__testf)
         {
    if (__n < __lc->_M_falsename_size)
      __testf = __c == __lc->_M_falsename[__n];
    else
      break;
  }

       if (__testt)
         {
    if (__n < __lc->_M_truename_size)
      __testt = __c == __lc->_M_truename[__n];
    else
      break;
  }

       if (!__testf && !__testt)
  break;

       if (++__beg == __end)
  __testeof = true;
            }
   if (__testf && __n == __lc->_M_falsename_size)
     __v = false;
   else if (__testt && __n == __lc->_M_truename_size)
     __v = true;
   else
     __err |= ios_base::failbit;

          if (__testeof)
            __err |= ios_base::eofbit;
        }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned short& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned int& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }
# 717 "/usr/include/c++/4.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      if (!(__err & ios_base::failbit))
 __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 952 "/usr/include/c++/4.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1013 "/usr/include/c++/4.3/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       _CharT* __cs
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __w));
       _M_pad(__fill, __w, __io, __cs, __name, __len);
       __name = __cs;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1152 "/usr/include/c++/4.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase
      | ios_base::internal);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1190 "/usr/include/c++/4.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       const streamsize __newlen,
       const streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }





  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);



}
# 2636 "/usr/include/c++/4.3/bits/locale_facets.h" 2 3
# 45 "/usr/include/c++/4.3/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 65 "/usr/include/c++/4.3/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 130 "/usr/include/c++/4.3/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 141 "/usr/include/c++/4.3/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   ;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 194 "/usr/include/c++/4.3/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 215 "/usr/include/c++/4.3/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 250 "/usr/include/c++/4.3/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 288 "/usr/include/c++/4.3/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 300 "/usr/include/c++/4.3/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 340 "/usr/include/c++/4.3/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 354 "/usr/include/c++/4.3/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 383 "/usr/include/c++/4.3/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 403 "/usr/include/c++/4.3/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 423 "/usr/include/c++/4.3/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 442 "/usr/include/c++/4.3/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };

}


# 1 "/usr/include/c++/4.3/bits/basic_ios.tcc" 1 3
# 39 "/usr/include/c++/4.3/bits/basic_ios.tcc" 3
       
# 40 "/usr/include/c++/4.3/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 150 "/usr/include/c++/4.3/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }





  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;



}
# 476 "/usr/include/c++/4.3/bits/basic_ios.h" 2 3
# 51 "/usr/include/c++/4.3/ios" 2 3
# 46 "/usr/include/c++/4.3/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 58 "/usr/include/c++/4.3/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 85 "/usr/include/c++/4.3/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 111 "/usr/include/c++/4.3/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 168 "/usr/include/c++/4.3/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 253 "/usr/include/c++/4.3/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 286 "/usr/include/c++/4.3/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 314 "/usr/include/c++/4.3/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 327 "/usr/include/c++/4.3/ostream" 3
      __ostream_type&
      flush();
# 338 "/usr/include/c++/4.3/ostream" 3
      pos_type
      tellp();
# 349 "/usr/include/c++/4.3/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 361 "/usr/include/c++/4.3/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
# 383 "/usr/include/c++/4.3/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 402 "/usr/include/c++/4.3/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 412 "/usr/include/c++/4.3/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 430 "/usr/include/c++/4.3/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 451 "/usr/include/c++/4.3/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 493 "/usr/include/c++/4.3/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 543 "/usr/include/c++/4.3/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}


# 1 "/usr/include/c++/4.3/bits/ostream.tcc" 1 3
# 44 "/usr/include/c++/4.3/bits/ostream.tcc" 3
       
# 45 "/usr/include/c++/4.3/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     if (true)
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     if (false)
       {
  this->_M_setstate(ios_base::badbit);
  ;
       }
     if (false)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   if (true)
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   if (true)
     { _M_write(__s, __n); }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (true)
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
   ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      if (true)
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
   ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (true)
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
   ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (true)
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
   ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   if (true)
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   if (false)
     {
       __out._M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);



}
# 573 "/usr/include/c++/4.3/ostream" 2 3
# 46 "/usr/include/c++/4.3/iostream" 2 3
# 1 "/usr/include/c++/4.3/istream" 1 3
# 43 "/usr/include/c++/4.3/istream" 3
       
# 44 "/usr/include/c++/4.3/istream" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 58 "/usr/include/c++/4.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:
# 94 "/usr/include/c++/4.3/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 122 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 169 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 241 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 251 "/usr/include/c++/4.3/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 283 "/usr/include/c++/4.3/istream" 3
      int_type
      get();
# 297 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      get(char_type& __c);
# 324 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 335 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 358 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 368 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 397 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 408 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 432 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
# 449 "/usr/include/c++/4.3/istream" 3
      int_type
      peek();
# 467 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 486 "/usr/include/c++/4.3/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 502 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      putback(char_type __c);
# 517 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      unget();
# 535 "/usr/include/c++/4.3/istream" 3
      int
      sync();
# 549 "/usr/include/c++/4.3/istream" 3
      pos_type
      tellg();
# 564 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      seekg(pos_type);
# 580 "/usr/include/c++/4.3/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 638 "/usr/include/c++/4.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 670 "/usr/include/c++/4.3/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 680 "/usr/include/c++/4.3/istream" 3
      operator bool() const
      { return _M_ok; }

    private:
      bool _M_ok;
    };
# 700 "/usr/include/c++/4.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 741 "/usr/include/c++/4.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 768 "/usr/include/c++/4.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
# 829 "/usr/include/c++/4.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);

}


# 1 "/usr/include/c++/4.3/bits/istream.tcc" 1 3
# 44 "/usr/include/c++/4.3/bits/istream.tcc" 3
       
# 45 "/usr/include/c++/4.3/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     if (true)
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     if (false)
       {
  this->_M_setstate(ios_base::badbit);
  ;
       }
     if (false)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (__gnu_cxx::__numeric_traits<short>::__min <= __l
       && __l <= __gnu_cxx::__numeric_traits<short>::__max)
     __n = short(__l);
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (__gnu_cxx::__numeric_traits<int>::__min <= __l
       && __l <= __gnu_cxx::__numeric_traits<int>::__max)
     __n = int(__l);
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   if (true)
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::failbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 468 "/usr/include/c++/4.3/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      if (true)
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
           ios_base::in);
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
   ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (true)
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
   ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (true)
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
   ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   if (true)
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   if (false)
     {
       __in._M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   if (true)
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   if (false)
     {
       __in._M_setstate(ios_base::badbit);
       ;
     }
   if (false)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;



}
# 837 "/usr/include/c++/4.3/istream" 2 3
# 47 "/usr/include/c++/4.3/iostream" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 63 "/usr/include/c++/4.3/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;

}
# 2 "SMTBackend.cc" 2
# 1 "/usr/include/c++/4.3/sstream" 1 3
# 42 "/usr/include/c++/4.3/sstream" 3
       
# 43 "/usr/include/c++/4.3/sstream" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 61 "/usr/include/c++/4.3/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 95 "/usr/include/c++/4.3/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 108 "/usr/include/c++/4.3/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
# 123 "/usr/include/c++/4.3/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 147 "/usr/include/c++/4.3/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 199 "/usr/include/c++/4.3/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   if (__testin)
     this->setg(this->eback(), this->gptr(), this->pptr());
   else
     this->setg(this->pptr(), this->pptr(), this->pptr());
      }
    };
# 256 "/usr/include/c++/4.3/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 292 "/usr/include/c++/4.3/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 310 "/usr/include/c++/4.3/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
# 332 "/usr/include/c++/4.3/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 365 "/usr/include/c++/4.3/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 401 "/usr/include/c++/4.3/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 419 "/usr/include/c++/4.3/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
# 441 "/usr/include/c++/4.3/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 474 "/usr/include/c++/4.3/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 508 "/usr/include/c++/4.3/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 524 "/usr/include/c++/4.3/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
# 546 "/usr/include/c++/4.3/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };

}


# 1 "/usr/include/c++/4.3/bits/sstream.tcc" 1 3
# 44 "/usr/include/c++/4.3/bits/sstream.tcc" 3
       
# 45 "/usr/include/c++/4.3/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 115 "/usr/include/c++/4.3/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->gbump((__beg + __newoffi) - this->gptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       this->pbump((__beg + __newoffo) - this->pptr());
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->gbump((__beg + __pos) - this->gptr());
       if (__testout)
                this->pbump((__beg + __pos) - this->pptr());
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   this->setp(__base, __endp);
   this->pbump(__o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }





  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;



}
# 573 "/usr/include/c++/4.3/sstream" 2 3
# 3 "SMTBackend.cc" 2

# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/CallingConv.h" 1
# 17 "/local/monniaux/packages/llvm-2.7/include/llvm/CallingConv.h"
namespace llvm {




namespace CallingConv {



  enum ID {




    C = 0,







    Fast = 8,





    Cold = 9,


    GHC = 10,



    FirstTargetCC = 64,





    X86_StdCall = 64,




    X86_FastCall = 65,



    ARM_APCS = 66,



    ARM_AAPCS = 67,


    ARM_AAPCS_VFP = 68,


    MSP430_INTR = 69
  };
}

}
# 5 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h" 1
# 24 "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Constant.h" 1
# 17 "/local/monniaux/packages/llvm-2.7/include/llvm/Constant.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/User.h" 1
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/User.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Value.h" 1
# 17 "/local/monniaux/packages/llvm-2.7/include/llvm/Value.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/AbstractTypeUser.h" 1
# 30 "/local/monniaux/packages/llvm-2.7/include/llvm/AbstractTypeUser.h"
# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 68 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 31 "/local/monniaux/packages/llvm-2.7/include/llvm/AbstractTypeUser.h" 2

namespace llvm {

class Value;
class Type;
class DerivedType;
template<typename T> struct simplify_type;
# 56 "/local/monniaux/packages/llvm-2.7/include/llvm/AbstractTypeUser.h"
class AbstractTypeUser {
protected:
  virtual ~AbstractTypeUser();




  void setType(Value *V, const Type *NewTy);

public:





  virtual void refineAbstractType(const DerivedType *OldTy,
                                  const Type *NewTy) = 0;






  virtual void typeBecameConcrete(const DerivedType *AbsTy) = 0;


  virtual void dump() const = 0;
};





class PATypeHandle {
  const Type *Ty;
  AbstractTypeUser * const User;



  void addUser();
  void removeUser();
public:

  inline PATypeHandle(const Type *ty, AbstractTypeUser *user)
    : Ty(ty), User(user) {
    addUser();
  }


  inline PATypeHandle(const PATypeHandle &T) : Ty(T.Ty), User(T.User) {
    addUser();
  }


  inline ~PATypeHandle() { removeUser(); }


  inline operator Type *() const { return const_cast<Type*>(Ty); }
  inline Type *get() const { return const_cast<Type*>(Ty); }


  inline Type *operator=(const Type *ty) {
    if (Ty != ty) {
      removeUser();
      Ty = ty;
      addUser();
    }
    return get();
  }


  inline const Type *operator=(const PATypeHandle &T) {
    return operator=(T.Ty);
  }

  inline bool operator==(const Type *ty) {
    return Ty == ty;
  }


  inline const Type *operator->() const { return Ty; }
};







class PATypeHolder {
  mutable const Type *Ty;
  void destroy();
public:
  PATypeHolder(const Type *ty) : Ty(ty) {
    addRef();
  }
  PATypeHolder(const PATypeHolder &T) : Ty(T.Ty) {
    addRef();
  }

  ~PATypeHolder() { if (Ty) dropRef(); }

  operator Type *() const { return get(); }
  Type *get() const;


  Type *operator->() const { return get(); }


  Type *operator=(const Type *ty) {
    if (Ty != ty) {
      dropRef();
      Ty = ty;
      addRef();
    }
    return get();
  }
  Type *operator=(const PATypeHolder &H) {
    return operator=(H.Ty);
  }



  const Type *getRawType() const { return Ty; }

private:
  void addRef();
  void dropRef();
  friend class TypeMapBase;
};



template<> struct simplify_type<PATypeHolder> {
  typedef const Type* SimpleType;
  static SimpleType getSimplifiedValue(const PATypeHolder &Val) {
    return static_cast<SimpleType>(Val.get());
  }
};
template<> struct simplify_type<const PATypeHolder> {
  typedef const Type* SimpleType;
  static SimpleType getSimplifiedValue(const PATypeHolder &Val) {
    return static_cast<SimpleType>(Val.get());
  }
};

}
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/Value.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Use.h" 1
# 28 "/local/monniaux/packages/llvm-2.7/include/llvm/Use.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Casting.h" 1
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Casting.h"
# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Casting.h" 2

namespace llvm {





template<typename FromCl> struct isa_impl_cl;





template<typename From> struct simplify_type {
  typedef From SimpleType;


  static SimpleType &getSimplifiedValue(From &Val) { return Val; }
};

template<typename From> struct simplify_type<const From> {
  typedef const From SimpleType;
  static SimpleType &getSimplifiedValue(const From &Val) {
    return simplify_type<From>::getSimplifiedValue(static_cast<From&>(Val));
  }
};







template <typename To, typename From>
inline bool isa_impl(const From &Val) {
  return To::classof(&Val);
}

template<typename To, typename From, typename SimpleType>
struct isa_impl_wrap {


  static bool doit(const From &Val) {
    return isa_impl_cl<const SimpleType>::template
                    isa<To>(simplify_type<const From>::getSimplifiedValue(Val));
  }
};

template<typename To, typename FromTy>
struct isa_impl_wrap<To, const FromTy, const FromTy> {

  static bool doit(const FromTy &Val) {
    return isa_impl<To,FromTy>(Val);
  }
};




template<typename FromCl>
struct isa_impl_cl {
  template<class ToCl>
  static bool isa(const FromCl &Val) {
    return isa_impl_wrap<ToCl,const FromCl,
                   typename simplify_type<const FromCl>::SimpleType>::doit(Val);
  }
};


template<typename FromCl>
struct isa_impl_cl<const FromCl> {
  template<class ToCl>
  static bool isa(const FromCl &Val) {
    return isa_impl_cl<FromCl>::template isa<ToCl>(Val);
  }
};


template<class FromCl>
struct isa_impl_cl<FromCl*> {
  template<class ToCl>
  static bool isa(FromCl *Val) {
    return isa_impl_cl<FromCl>::template isa<ToCl>(*Val);
  }
};


template<class FromCl>
struct isa_impl_cl<FromCl&> {
  template<class ToCl>
  static bool isa(FromCl &Val) {
    return isa_impl_cl<FromCl>::template isa<ToCl>(&Val);
  }
};

template <class X, class Y>
inline bool isa(const Y &Val) {
  return isa_impl_cl<Y>::template isa<X>(Val);
}





template<class To, class From> struct cast_retty;




template<class To, class From> struct cast_retty_impl {
  typedef To& ret_type;
};
template<class To, class From> struct cast_retty_impl<To, const From> {
  typedef const To &ret_type;
};

template<class To, class From> struct cast_retty_impl<To, From*> {
  typedef To* ret_type;
};

template<class To, class From> struct cast_retty_impl<To, const From*> {
  typedef const To* ret_type;
};

template<class To, class From> struct cast_retty_impl<To, const From*const> {
  typedef const To* ret_type;
};


template<class To, class From, class SimpleFrom>
struct cast_retty_wrap {



  typedef typename cast_retty<To, SimpleFrom>::ret_type ret_type;
};

template<class To, class FromTy>
struct cast_retty_wrap<To, FromTy, FromTy> {

  typedef typename cast_retty_impl<To,FromTy>::ret_type ret_type;
};

template<class To, class From>
struct cast_retty {
  typedef typename cast_retty_wrap<To, From,
                   typename simplify_type<From>::SimpleType>::ret_type ret_type;
};




template<class To, class From, class SimpleFrom> struct cast_convert_val {

  static typename cast_retty<To, From>::ret_type doit(const From &Val) {
    return cast_convert_val<To, SimpleFrom,
      typename simplify_type<SimpleFrom>::SimpleType>::doit(
                          simplify_type<From>::getSimplifiedValue(Val));
  }
};

template<class To, class FromTy> struct cast_convert_val<To,FromTy,FromTy> {

  static typename cast_retty<To, FromTy>::ret_type doit(const FromTy &Val) {
    typename cast_retty<To, FromTy>::ret_type Res2
     = (typename cast_retty<To, FromTy>::ret_type)const_cast<FromTy&>(Val);
    return Res2;
  }
};
# 198 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Casting.h"
template <class X, class Y>
inline typename cast_retty<X, Y>::ret_type cast(const Y &Val) {
  ((isa<X>(Val) && "cast<Ty>() argument of incompatible type!") ? static_cast<void> (0) : __assert_fail ("isa<X>(Val) && \"cast<Ty>() argument of incompatible type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Casting.h", 200, __PRETTY_FUNCTION__));
  return cast_convert_val<X, Y,
                          typename simplify_type<Y>::SimpleType>::doit(Val);
}




template <class X, class Y>
inline typename cast_retty<X, Y*>::ret_type cast_or_null(Y *Val) {
  if (Val == 0) return 0;
  ((isa<X>(Val) && "cast_or_null<Ty>() argument of incompatible type!") ? static_cast<void> (0) : __assert_fail ("isa<X>(Val) && \"cast_or_null<Ty>() argument of incompatible type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Casting.h", 211, __PRETTY_FUNCTION__));
  return cast<X>(Val);
}
# 224 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Casting.h"
template <class X, class Y>
inline typename cast_retty<X, Y>::ret_type dyn_cast(const Y &Val) {
  return isa<X>(Val) ? cast<X, Y>(Val) : 0;
}




template <class X, class Y>
inline typename cast_retty<X, Y>::ret_type dyn_cast_or_null(const Y &Val) {
  return (Val && isa<X>(Val)) ? cast<X, Y>(Val) : 0;
}
# 302 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Casting.h"
}
# 29 "/local/monniaux/packages/llvm-2.7/include/llvm/Use.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/PointerIntPair.h" 1
# 17 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/PointerIntPair.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/PointerLikeTypeTraits.h" 1
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/PointerLikeTypeTraits.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/System/DataTypes.h" 1
# 35 "/local/monniaux/packages/llvm-2.7/include/llvm/System/DataTypes.h"
# 1 "/usr/include/c++/4.3/cmath" 1 3
# 46 "/usr/include/c++/4.3/cmath" 3
       
# 47 "/usr/include/c++/4.3/cmath" 3




# 1 "/usr/include/math.h" 1 3 4
# 30 "/usr/include/math.h" 3 4
extern "C" {



# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
# 37 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
# 38 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/inf.h" 1 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/nan.h" 1 3 4
# 44 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 26 "/usr/include/bits/mathdef.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/mathdef.h" 2 3 4
# 38 "/usr/include/bits/mathdef.h" 3 4
typedef long double float_t;

typedef long double double_t;
# 48 "/usr/include/math.h" 2 3 4
# 71 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();






extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ();




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (__const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw (); extern double __fmax (double __x, double __y) throw ();


extern double fmin (double __x, double __y) throw (); extern double __fmin (double __x, double __y) throw ();



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 72 "/usr/include/math.h" 2 3 4
# 94 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();






extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ();




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (__const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw (); extern float __fmaxf (float __x, float __y) throw ();


extern float fminf (float __x, float __y) throw (); extern float __fminf (float __x, float __y) throw ();



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 95 "/usr/include/math.h" 2 3 4
# 141 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();






extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ();




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (__const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw (); extern long double __fmaxl (long double __x, long double __y) throw ();


extern long double fminl (long double __x, long double __y) throw (); extern long double __fminl (long double __x, long double __y) throw ();



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 142 "/usr/include/math.h" 2 3 4
# 157 "/usr/include/math.h" 3 4
extern int signgam;
# 198 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };
# 284 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 307 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 409 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathinline.h" 1 3 4
# 35 "/usr/include/bits/mathinline.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__signbitf (float __x) throw ()
{
  __extension__ union { float __f; int __i; } __u = { __f: __x };
  return __u.__i < 0;
}
extern __inline __attribute__ ((__gnu_inline__)) int
__signbit (double __x) throw ()
{
  __extension__ union { double __d; int __i[2]; } __u = { __d: __x };
  return __u.__i[1] < 0;
}
extern __inline __attribute__ ((__gnu_inline__)) int
__signbitl (long double __x) throw ()
{
  __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
  return (__u.__i[2] & 0x8000) != 0;
}
# 410 "/usr/include/math.h" 2 3 4
# 465 "/usr/include/math.h" 3 4
}
# 52 "/usr/include/c++/4.3/cmath" 2 3
# 82 "/usr/include/c++/4.3/cmath" 3
namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _Tp>
    _Tp __cmath_power(_Tp, unsigned int);

  template<typename _Tp>
    inline _Tp
    __pow_helper(_Tp __x, int __n)
    {
      return __n < 0
        ? _Tp(1)/__cmath_power(__x, -__n)
        : __cmath_power(__x, __n);
    }

  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }

  using ::acos;

  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;

  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;

  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;

  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }

  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<
    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
        && __is_arithmetic<_Up>::__value,
        _Tp>::__type, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;

  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;

  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;

  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;

  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;

  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }

  using ::frexp;

  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;

  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
  ldexp(_Tp __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }

  using ::log;

  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;

  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;

  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }

  using ::pow;

  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }


  inline double
  pow(double __x, int __i)
  { return __builtin_powi(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __builtin_powif(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __builtin_powil(__x, __n); }

  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<
    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
        && __is_arithmetic<_Up>::__value,
        _Tp>::__type, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;

  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;

  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;

  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }

}







namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp>
    inline int
    __capture_fpclassify(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __fpclassifyf (__f) : sizeof (__f) == sizeof (double) ? __fpclassify (__f) : __fpclassifyl (__f)); }

}
# 505 "/usr/include/c++/4.3/cmath" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    fpclassify(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return ::__gnu_cxx::__capture_fpclassify(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isfinite(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isfinite(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isinf(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isinf(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnan(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnan(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnormal(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnormal(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    signbit(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_signbit(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreaterequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreaterequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isless(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isless(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isunordered(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isunordered(__type(__f1), __type(__f2));
    }

}





# 1 "/usr/include/c++/4.3/bits/cmath.tcc" 1 3
# 40 "/usr/include/c++/4.3/bits/cmath.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp>
    inline _Tp
    __cmath_power(_Tp __x, unsigned int __n)
    {
      _Tp __y = __n % 2 ? __x : _Tp(1);

      while (__n >>= 1)
        {
          __x = __x * __x;
          if (__n % 2)
            __y = __y * __x;
        }

      return __y;
    }

}
# 622 "/usr/include/c++/4.3/cmath" 2 3
# 36 "/local/monniaux/packages/llvm-2.7/include/llvm/System/DataTypes.h" 2
# 55 "/local/monniaux/packages/llvm-2.7/include/llvm/System/DataTypes.h"
# 1 "/usr/include/sys/types.h" 1 3 4
# 29 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;
# 72 "/usr/include/sys/types.h" 3 4
typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 105 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;
# 116 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 141 "/usr/include/sys/types.h" 3 4
typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 201 "/usr/include/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 220 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 35 "/usr/include/sys/select.h" 2 3 4
# 46 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
# 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4
# 55 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4
extern "C" {
# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);


}
# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 30 "/usr/include/sys/sysmacros.h" 3 4
__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw ();


__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned int
gnu_dev_major (unsigned long long int __dev) throw ()
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned int
gnu_dev_minor (unsigned long long int __dev) throw ()
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) unsigned long long int
gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw ()
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
# 224 "/usr/include/sys/types.h" 2 3 4




typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 273 "/usr/include/sys/types.h" 3 4
}
# 56 "/local/monniaux/packages/llvm-2.7/include/llvm/System/DataTypes.h" 2



# 1 "/usr/include/inttypes.h" 1 3 4
# 274 "/usr/include/inttypes.h" 3 4
extern "C" {
# 288 "/usr/include/inttypes.h" 3 4
typedef struct
  {
    long long int quot;
    long long int rem;
  } imaxdiv_t;





extern intmax_t imaxabs (intmax_t __n) throw () __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      throw () __attribute__ ((__const__));


extern intmax_t strtoimax (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base) throw ();


extern uintmax_t strtoumax (__const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) throw ();


extern intmax_t wcstoimax (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();


extern uintmax_t wcstoumax (__const wchar_t *__restrict __nptr,
       wchar_t ** __restrict __endptr, int __base)
     throw ();
# 379 "/usr/include/inttypes.h" 3 4
__extension__
extern long long int __strtoll_internal (__const char *__restrict __nptr,
      char **__restrict __endptr,
      int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
strtoimax (__const char *__restrict nptr, char **__restrict endptr, int base) throw ()

{
  return __strtoll_internal (nptr, endptr, base, 0);
}

__extension__
extern unsigned long long int __strtoull_internal (__const char *
         __restrict __nptr,
         char **
         __restrict __endptr,
         int __base,
         int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
strtoumax (__const char *__restrict nptr, char **__restrict endptr, int base) throw ()

{
  return __strtoull_internal (nptr, endptr, base, 0);
}

__extension__
extern long long int __wcstoll_internal (__const wchar_t *
      __restrict __nptr,
      wchar_t **__restrict __endptr,
      int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
wcstoimax (__const wchar_t *__restrict nptr, wchar_t **__restrict endptr, int base) throw ()

{
  return __wcstoll_internal (nptr, endptr, base, 0);
}


__extension__
extern unsigned long long int __wcstoull_internal (__const wchar_t *
         __restrict __nptr,
         wchar_t **
         __restrict __endptr,
         int __base,
         int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
wcstoumax (__const wchar_t *__restrict nptr, wchar_t **__restrict endptr, int base) throw ()

{
  return __wcstoull_internal (nptr, endptr, base, 0);
}




}
# 60 "/local/monniaux/packages/llvm-2.7/include/llvm/System/DataTypes.h" 2
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/PointerLikeTypeTraits.h" 2

namespace llvm {




template <typename T>
class PointerLikeTypeTraits {



};


template<typename T>
class PointerLikeTypeTraits<T*> {
public:
  static inline void *getAsVoidPointer(T* P) { return P; }
  static inline T *getFromVoidPointer(void *P) {
    return static_cast<T*>(P);
  }







  enum { NumLowBitsAvailable = 2 };
};


template<typename T>
class PointerLikeTypeTraits<const T*> {
  typedef PointerLikeTypeTraits<T*> NonConst;

public:
  static inline const void *getAsVoidPointer(const T* P) {
    return NonConst::getAsVoidPointer(const_cast<T*>(P));
  }
  static inline const T *getFromVoidPointer(const void *P) {
    return NonConst::getFromVoidPointer(const_cast<void*>(P));
  }
  enum { NumLowBitsAvailable = NonConst::NumLowBitsAvailable };
};


template<>
class PointerLikeTypeTraits<uintptr_t> {
public:
  static inline void *getAsVoidPointer(uintptr_t P) {
    return reinterpret_cast<void*>(P);
  }
  static inline uintptr_t getFromVoidPointer(void *P) {
    return reinterpret_cast<uintptr_t>(P);
  }

  enum { NumLowBitsAvailable = 0 };
};

}
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/PointerIntPair.h" 2
# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/PointerIntPair.h" 2

namespace llvm {

template<typename T>
struct DenseMapInfo;
# 39 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/PointerIntPair.h"
template <typename PointerTy, unsigned IntBits, typename IntType=unsigned,
          typename PtrTraits = PointerLikeTypeTraits<PointerTy> >
class PointerIntPair {
  intptr_t Value;
  enum {

    PointerBitMask =
      ~(uintptr_t)(((intptr_t)1 << PtrTraits::NumLowBitsAvailable)-1),



    IntShift = (uintptr_t)PtrTraits::NumLowBitsAvailable-IntBits,


    IntMask = (uintptr_t)(((intptr_t)1 << IntBits)-1),


    ShiftedIntMask = (uintptr_t)(IntMask << IntShift)
  };
public:
  PointerIntPair() : Value(0) {}
  PointerIntPair(PointerTy Ptr, IntType Int) : Value(0) {
    ((IntBits <= PtrTraits::NumLowBitsAvailable && "PointerIntPair formed with integer size too large for pointer") ? static_cast<void> (0) : __assert_fail ("IntBits <= PtrTraits::NumLowBitsAvailable && \"PointerIntPair formed with integer size too large for pointer\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/PointerIntPair.h", 62, __PRETTY_FUNCTION__));

    setPointer(Ptr);
    setInt(Int);
  }

  PointerTy getPointer() const {
    return PtrTraits::getFromVoidPointer(
                         reinterpret_cast<void*>(Value & PointerBitMask));
  }

  IntType getInt() const {
    return (IntType)((Value >> IntShift) & IntMask);
  }

  void setPointer(PointerTy Ptr) {
    intptr_t PtrVal
      = reinterpret_cast<intptr_t>(PtrTraits::getAsVoidPointer(Ptr));
    (((PtrVal & ((1 << PtrTraits::NumLowBitsAvailable)-1)) == 0 && "Pointer is not sufficiently aligned") ? static_cast<void> (0) : __assert_fail ("(PtrVal & ((1 << PtrTraits::NumLowBitsAvailable)-1)) == 0 && \"Pointer is not sufficiently aligned\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/PointerIntPair.h", 80, __PRETTY_FUNCTION__));


    Value = PtrVal | (Value & ~PointerBitMask);
  }

  void setInt(IntType Int) {
    intptr_t IntVal = Int;
    ((IntVal < (1 << IntBits) && "Integer too large for field") ? static_cast<void> (0) : __assert_fail ("IntVal < (1 << IntBits) && \"Integer too large for field\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/PointerIntPair.h", 87, __PRETTY_FUNCTION__));


    Value &= ~ShiftedIntMask;
    Value |= IntVal << IntShift;
  }

  void *getOpaqueValue() const { return reinterpret_cast<void*>(Value); }
  void setFromOpaqueValue(void *Val) { Value = reinterpret_cast<intptr_t>(Val);}

  static PointerIntPair getFromOpaqueValue(void *V) {
    PointerIntPair P; P.setFromOpaqueValue(V); return P;
  }

  bool operator==(const PointerIntPair &RHS) const {return Value == RHS.Value;}
  bool operator!=(const PointerIntPair &RHS) const {return Value != RHS.Value;}
  bool operator<(const PointerIntPair &RHS) const {return Value < RHS.Value;}
  bool operator>(const PointerIntPair &RHS) const {return Value > RHS.Value;}
  bool operator<=(const PointerIntPair &RHS) const {return Value <= RHS.Value;}
  bool operator>=(const PointerIntPair &RHS) const {return Value >= RHS.Value;}
};

template <typename T> struct isPodLike;
template<typename PointerTy, unsigned IntBits, typename IntType>
struct isPodLike<PointerIntPair<PointerTy, IntBits, IntType> > {
   static const bool value = true;
};


template<typename PointerTy, unsigned IntBits, typename IntType>
struct DenseMapInfo<PointerIntPair<PointerTy, IntBits, IntType> > {
  typedef PointerIntPair<PointerTy, IntBits, IntType> Ty;
  static Ty getEmptyKey() {
    intptr_t Val = -1;
    Val <<= PointerLikeTypeTraits<PointerTy>::NumLowBitsAvailable;
    return Ty(reinterpret_cast<PointerTy>(Val), IntType((1 << IntBits)-1));
  }
  static Ty getTombstoneKey() {
    intptr_t Val = -2;
    Val <<= PointerLikeTypeTraits<PointerTy>::NumLowBitsAvailable;
    return Ty(reinterpret_cast<PointerTy>(Val), IntType(0));
  }
  static unsigned getHashValue(Ty V) {
    uintptr_t IV = reinterpret_cast<uintptr_t>(V.getOpaqueValue());
    return unsigned(IV) ^ unsigned(IV >> 9);
  }
  static bool isEqual(const Ty &LHS, const Ty &RHS) { return LHS == RHS; }
};


template<typename PointerTy, unsigned IntBits, typename IntType,
         typename PtrTraits>
class PointerLikeTypeTraits<PointerIntPair<PointerTy, IntBits, IntType,
                                           PtrTraits> > {
public:
  static inline void *
  getAsVoidPointer(const PointerIntPair<PointerTy, IntBits, IntType> &P) {
    return P.getOpaqueValue();
  }
  static inline PointerIntPair<PointerTy, IntBits, IntType>
  getFromVoidPointer(void *P) {
    return PointerIntPair<PointerTy, IntBits, IntType>::getFromOpaqueValue(P);
  }
  enum {
    NumLowBitsAvailable = PtrTraits::NumLowBitsAvailable - IntBits
  };
};

}
# 30 "/local/monniaux/packages/llvm-2.7/include/llvm/Use.h" 2
# 1 "/usr/include/c++/4.3/iterator" 1 3
# 63 "/usr/include/c++/4.3/iterator" 3
       
# 64 "/usr/include/c++/4.3/iterator" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 67 "/usr/include/c++/4.3/iterator" 2 3





# 1 "/usr/include/c++/4.3/bits/stream_iterator.h" 1 3
# 38 "/usr/include/c++/4.3/bits/stream_iterator.h" 3
       
# 39 "/usr/include/c++/4.3/bits/stream_iterator.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:

      istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(&__s)
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const
      {
 ;


 return _M_value;
      }

      const _Tp*
      operator->() const { return &(operator*()); }

      istream_iterator&
      operator++()
      {
 ;


 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {
 ;


 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }

    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };


  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }


  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
# 150 "/usr/include/c++/4.3/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}
# 181 "/usr/include/c++/4.3/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }



      ostream_iterator&
      operator=(const _Tp& __value)
      {
 ;


 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };

}
# 73 "/usr/include/c++/4.3/iterator" 2 3
# 31 "/local/monniaux/packages/llvm-2.7/include/llvm/Use.h" 2

namespace llvm {

class Value;
class User;
class Use;


enum Tag { noTag, tagOne, tagTwo, tagThree };


template<>
class PointerLikeTypeTraits<Use**> {
public:
  static inline void *getAsVoidPointer(Use** P) { return P; }
  static inline Use **getFromVoidPointer(void *P) {
    return static_cast<Use**>(P);
  }
  enum { NumLowBitsAvailable = 2 };
};







class Use {
public:


  void swap(Use &RHS);

private:

  Use(const Use &U);


  inline ~Use() {
    if (Val) removeFromList();
  }



  inline Use() {}
  enum PrevPtrTag { zeroDigitTag = noTag
                  , oneDigitTag = tagOne
                  , stopTag = tagTwo
                  , fullStopTag = tagThree };

public:

  operator Value*() const { return Val; }



  Value *get() const { return Val; }



  User *getUser() const;

  inline void set(Value *Val);

  Value *operator=(Value *RHS) {
    set(RHS);
    return RHS;
  }
  const Use &operator=(const Use &RHS) {
    set(RHS.Val);
    return *this;
  }

        Value *operator->() { return Val; }
  const Value *operator->() const { return Val; }

  Use *getNext() const { return Next; }




  static void zap(Use *Start, const Use *Stop, bool del = false);


  Use *getPrefix();
private:
  const Use* getImpliedUser() const;
  static Use *initTags(Use *Start, Use *Stop, ptrdiff_t Done = 0);

  Value *Val;
  Use *Next;
  PointerIntPair<Use**, 2, PrevPtrTag> Prev;

  void setPrev(Use **NewPrev) {
    Prev.setPointer(NewPrev);
  }
  void addToList(Use **List) {
    Next = *List;
    if (Next) Next->setPrev(&Next);
    setPrev(List);
    *List = this;
  }
  void removeFromList() {
    Use **StrippedPrev = Prev.getPointer();
    *StrippedPrev = Next;
    if (Next) Next->setPrev(StrippedPrev);
  }

  friend class Value;
  friend class User;
};



template<> struct simplify_type<Use> {
  typedef Value* SimpleType;
  static SimpleType getSimplifiedValue(const Use &Val) {
    return static_cast<SimpleType>(Val.get());
  }
};
template<> struct simplify_type<const Use> {
  typedef Value* SimpleType;
  static SimpleType getSimplifiedValue(const Use &Val) {
    return static_cast<SimpleType>(Val.get());
  }
};



template<typename UserTy>
class value_use_iterator : public std::iterator<std::forward_iterator_tag,
                                                UserTy*, ptrdiff_t> {
  typedef std::iterator<std::forward_iterator_tag, UserTy*, ptrdiff_t> super;
  typedef value_use_iterator<UserTy> _Self;

  Use *U;
  explicit value_use_iterator(Use *u) : U(u) {}
  friend class Value;
public:
  typedef typename super::reference reference;
  typedef typename super::pointer pointer;

  value_use_iterator(const _Self &I) : U(I.U) {}
  value_use_iterator() {}

  bool operator==(const _Self &x) const {
    return U == x.U;
  }
  bool operator!=(const _Self &x) const {
    return !operator==(x);
  }


  bool atEnd() const { return U == 0; }


  _Self &operator++() {
    ((U && "Cannot increment end iterator!") ? static_cast<void> (0) : __assert_fail ("U && \"Cannot increment end iterator!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Use.h", 188, __PRETTY_FUNCTION__));
    U = U->getNext();
    return *this;
  }
  _Self operator++(int) {
    _Self tmp = *this; ++*this; return tmp;
  }


  UserTy *operator*() const {
    ((U && "Cannot dereference end iterator!") ? static_cast<void> (0) : __assert_fail ("U && \"Cannot dereference end iterator!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Use.h", 198, __PRETTY_FUNCTION__));
    return U->getUser();
  }

  UserTy *operator->() const { return operator*(); }

  Use &getUse() const { return *U; }




  unsigned getOperandNo() const;
};


template<> struct simplify_type<value_use_iterator<User> > {
  typedef User* SimpleType;

  static SimpleType getSimplifiedValue(const value_use_iterator<User> &Val) {
    return *Val;
  }
};

template<> struct simplify_type<const value_use_iterator<User> >
 : public simplify_type<value_use_iterator<User> > {};

template<> struct simplify_type<value_use_iterator<const User> > {
  typedef const User* SimpleType;

  static SimpleType getSimplifiedValue(const
                                       value_use_iterator<const User> &Val) {
    return *Val;
  }
};

template<> struct simplify_type<const value_use_iterator<const User> >
  : public simplify_type<value_use_iterator<const User> > {};

}
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/Value.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h" 1
# 13 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h"
# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 14 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h" 2
# 1 "/usr/include/c++/4.3/cstring" 1 3
# 45 "/usr/include/c++/4.3/cstring" 3
       
# 46 "/usr/include/c++/4.3/cstring" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 49 "/usr/include/c++/4.3/cstring" 2 3
# 1 "/usr/include/string.h" 1 3 4
# 28 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4




extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern void *rawmemchr (__const void *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

# 121 "/usr/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (__const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 165 "/usr/include/string.h" 3 4


extern char *strchr (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

extern char *strrchr (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strchrnul (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strpbrk (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strstr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));




extern char *strcasestr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 281 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *index (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern char *rindex (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));



extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));






extern char *basename (__const char *__filename) throw () __attribute__ ((__nonnull__ (1)));
# 432 "/usr/include/string.h" 3 4
}
# 50 "/usr/include/c++/4.3/cstring" 2 3
# 78 "/usr/include/c++/4.3/cstring" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;

  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }

  using ::strchr;

  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }

  using ::strpbrk;

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }

  using ::strrchr;

  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }

  using ::strstr;

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }

}
# 15 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h" 2
# 1 "/usr/include/c++/4.3/utility" 1 3
# 64 "/usr/include/c++/4.3/utility" 3
       
# 65 "/usr/include/c++/4.3/utility" 3


# 1 "/usr/include/c++/4.3/bits/stl_relops.h" 1 3
# 72 "/usr/include/c++/4.3/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  namespace rel_ops
  {
# 88 "/usr/include/c++/4.3/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 101 "/usr/include/c++/4.3/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 114 "/usr/include/c++/4.3/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 127 "/usr/include/c++/4.3/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

  }

}
# 68 "/usr/include/c++/4.3/utility" 2 3
# 16 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h" 2


namespace llvm {
  template<typename T>
  class SmallVectorImpl;
  class APInt;
# 30 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h"
  class StringRef {
  public:
    typedef const char *iterator;
    typedef const char *const_iterator;
    static const size_t npos = ~size_t(0);
    typedef size_t size_type;

  private:

    const char *Data;


    size_t Length;




    size_t min(size_t a, size_t b) const { return a < b ? a : b; }
    size_t max(size_t a, size_t b) const { return a > b ? a : b; }

  public:




                 StringRef() : Data(0), Length(0) {}


                 StringRef(const char *Str)
      : Data(Str), Length(::strlen(Str)) {}


                 StringRef(const char *data, size_t length)
      : Data(data), Length(length) {}


                 StringRef(const std::string &Str)
      : Data(Str.data()), Length(Str.length()) {}





    iterator begin() const { return Data; }

    iterator end() const { return Data + Length; }







    const char *data() const { return Data; }


    bool empty() const { return Length == 0; }


    size_t size() const { return Length; }


    char front() const {
      ((!empty()) ? static_cast<void> (0) : __assert_fail ("!empty()", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h", 93, __PRETTY_FUNCTION__));
      return Data[0];
    }


    char back() const {
      ((!empty()) ? static_cast<void> (0) : __assert_fail ("!empty()", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h", 99, __PRETTY_FUNCTION__));
      return Data[Length-1];
    }



    bool equals(StringRef RHS) const {
      return (Length == RHS.Length &&
              memcmp(Data, RHS.Data, RHS.Length) == 0);
    }


    bool equals_lower(StringRef RHS) const {
      return Length == RHS.Length && compare_lower(RHS) == 0;
    }



    int compare(StringRef RHS) const {

      if (int Res = memcmp(Data, RHS.Data, min(Length, RHS.Length)))
        return Res < 0 ? -1 : 1;


      if (Length == RHS.Length)
        return 0;
      return Length < RHS.Length ? -1 : 1;
    }


    int compare_lower(StringRef RHS) const;
# 145 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h"
    unsigned edit_distance(StringRef Other, bool AllowReplacements = true);


    std::string str() const { return std::string(Data, Length); }





    char operator[](size_t Index) const {
      ((Index < Length && "Invalid index!") ? static_cast<void> (0) : __assert_fail ("Index < Length && \"Invalid index!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h", 155, __PRETTY_FUNCTION__));
      return Data[Index];
    }





    operator std::string() const {
      return str();
    }






    bool startswith(StringRef Prefix) const {
      return Length >= Prefix.Length &&
             memcmp(Data, Prefix.Data, Prefix.Length) == 0;
    }


    bool endswith(StringRef Suffix) const {
      return Length >= Suffix.Length &&
             memcmp(end() - Suffix.Length, Suffix.Data, Suffix.Length) == 0;
    }
# 191 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h"
    size_t find(char C, size_t From = 0) const {
      for (size_t i = min(From, Length), e = Length; i != e; ++i)
        if (Data[i] == C)
          return i;
      return npos;
    }





    size_t find(StringRef Str, size_t From = 0) const;





    size_t rfind(char C, size_t From = npos) const {
      From = min(From, Length);
      size_t i = From;
      while (i != 0) {
        --i;
        if (Data[i] == C)
          return i;
      }
      return npos;
    }





    size_t rfind(StringRef Str) const;



    size_type find_first_of(char C, size_t = 0) const { return find(C); }





    size_type find_first_of(StringRef Chars, size_t From = 0) const;



    size_type find_first_not_of(char C, size_t From = 0) const;





    size_type find_first_not_of(StringRef Chars, size_t From = 0) const;






    size_t count(char C) const {
      size_t Count = 0;
      for (size_t i = 0, e = Length; i != e; ++i)
        if (Data[i] == C)
          ++Count;
      return Count;
    }



    size_t count(StringRef Str) const;
# 270 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h"
    bool getAsInteger(unsigned Radix, long long &Result) const;
    bool getAsInteger(unsigned Radix, unsigned long long &Result) const;
    bool getAsInteger(unsigned Radix, int &Result) const;
    bool getAsInteger(unsigned Radix, unsigned &Result) const;
# 288 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h"
    bool getAsInteger(unsigned Radix, APInt &Result) const;
# 303 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h"
    StringRef substr(size_t Start, size_t N = npos) const {
      Start = min(Start, Length);
      return StringRef(Data + Start, min(N, Length - Start));
    }
# 318 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h"
    StringRef slice(size_t Start, size_t End) const {
      Start = min(Start, Length);
      End = min(max(Start, End), Length);
      return StringRef(Data + Start, End - Start);
    }
# 334 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h"
    std::pair<StringRef, StringRef> split(char Separator) const {
      size_t Idx = find(Separator);
      if (Idx == npos)
        return std::make_pair(*this, StringRef());
      return std::make_pair(slice(0, Idx), slice(Idx+1, npos));
    }
# 351 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h"
    std::pair<StringRef, StringRef> split(StringRef Separator) const {
      size_t Idx = find(Separator);
      if (Idx == npos)
        return std::make_pair(*this, StringRef());
      return std::make_pair(slice(0, Idx), slice(Idx + Separator.size(), npos));
    }
# 373 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h"
    void split(SmallVectorImpl<StringRef> &A,
               StringRef Separator, int MaxSplit = -1,
               bool KeepEmpty = true) const;
# 387 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringRef.h"
    std::pair<StringRef, StringRef> rsplit(char Separator) const {
      size_t Idx = rfind(Separator);
      if (Idx == npos)
        return std::make_pair(*this, StringRef());
      return std::make_pair(slice(0, Idx), slice(Idx+1, npos));
    }


  };




  inline bool operator==(StringRef LHS, StringRef RHS) {
    return LHS.equals(RHS);
  }

  inline bool operator!=(StringRef LHS, StringRef RHS) {
    return !(LHS == RHS);
  }

  inline bool operator<(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) == -1;
  }

  inline bool operator<=(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) != 1;
  }

  inline bool operator>(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) == 1;
  }

  inline bool operator>=(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) != -1;
  }



}
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/Value.h" 2



namespace llvm {

class Constant;
class Argument;
class Instruction;
class BasicBlock;
class GlobalValue;
class Function;
class GlobalVariable;
class GlobalAlias;
class InlineAsm;
class ValueSymbolTable;
class TypeSymbolTable;
template<typename ValueTy> class StringMapEntry;
template <typename ValueTy = Value>
class AssertingVH;
typedef StringMapEntry<Value*> ValueName;
class raw_ostream;
class AssemblyAnnotationWriter;
class ValueHandleBase;
class LLVMContext;
class Twine;
class MDNode;
# 64 "/local/monniaux/packages/llvm-2.7/include/llvm/Value.h"
class Value {
  const unsigned char SubclassID;
  unsigned char HasValueHandle : 1;
protected:




  unsigned char SubclassOptionalData : 7;

private:



  unsigned short SubclassData;

  PATypeHolder VTy;
  Use *UseList;

  friend class ValueSymbolTable;
  friend class ValueHandleBase;
  friend class AbstractTypeUser;
  ValueName *Name;

  void operator=(const Value &);
  Value(const Value &);

protected:


  virtual void printCustom(raw_ostream &O) const;

public:
  Value(const Type *Ty, unsigned scid);
  virtual ~Value();



  void dump() const;



  void print(raw_ostream &O, AssemblyAnnotationWriter *AAW = 0) const;



  inline const Type *getType() const { return VTy; }


  LLVMContext &getContext() const;


  inline bool hasName() const { return Name != 0; }
  ValueName *getValueName() const { return Name; }
# 128 "/local/monniaux/packages/llvm-2.7/include/llvm/Value.h"
  StringRef getName() const;




  std::string getNameStr() const;





  void setName(const Twine &Name);




  void takeName(Value *V);





  void replaceAllUsesWith(Value *V);



  void uncheckedReplaceAllUsesWith(Value *V);




  typedef value_use_iterator<User> use_iterator;
  typedef value_use_iterator<const User> use_const_iterator;

  bool use_empty() const { return UseList == 0; }
  use_iterator use_begin() { return use_iterator(UseList); }
  use_const_iterator use_begin() const { return use_const_iterator(UseList); }
  use_iterator use_end() { return use_iterator(0); }
  use_const_iterator use_end() const { return use_const_iterator(0); }
  User *use_back() { return *use_begin(); }
  const User *use_back() const { return *use_begin(); }





  bool hasOneUse() const {
    use_const_iterator I = use_begin(), E = use_end();
    if (I == E) return false;
    return ++I == E;
  }



  bool hasNUses(unsigned N) const;




  bool hasNUsesOrMore(unsigned N) const;

  bool isUsedInBasicBlock(const BasicBlock *BB) const;




  unsigned getNumUses() const;



  void addUse(Use &U) { U.addToList(&UseList); }





  enum ValueTy {
    ArgumentVal,
    BasicBlockVal,
    FunctionVal,
    GlobalAliasVal,
    GlobalVariableVal,
    UndefValueVal,
    BlockAddressVal,
    ConstantExprVal,
    ConstantAggregateZeroVal,
    ConstantIntVal,
    ConstantFPVal,
    ConstantArrayVal,
    ConstantStructVal,
    ConstantUnionVal,
    ConstantVectorVal,
    ConstantPointerNullVal,
    MDNodeVal,
    MDStringVal,
    NamedMDNodeVal,
    InlineAsmVal,
    PseudoSourceValueVal,
    FixedStackPseudoSourceValueVal,

    InstructionVal,




    ConstantFirstVal = FunctionVal,
    ConstantLastVal = ConstantPointerNullVal
  };
# 246 "/local/monniaux/packages/llvm-2.7/include/llvm/Value.h"
  unsigned getValueID() const {
    return SubclassID;
  }




  unsigned getRawSubclassOptionalData() const {
    return SubclassOptionalData;
  }



  bool hasSameSubclassOptionalData(const Value *V) const {
    return SubclassOptionalData == V->SubclassOptionalData;
  }



  void intersectOptionalDataWith(const Value *V) {
    SubclassOptionalData &= V->SubclassOptionalData;
  }


  static inline bool classof(const Value *) {
    return true;
  }



  const Type *getRawType() const { return VTy.getRawType(); }




  Value *stripPointerCasts();
  const Value *stripPointerCasts() const {
    return const_cast<Value*>(this)->stripPointerCasts();
  }






  Value *getUnderlyingObject(unsigned MaxLookup = 6);
  const Value *getUnderlyingObject(unsigned MaxLookup = 6) const {
    return const_cast<Value*>(this)->getUnderlyingObject(MaxLookup);
  }





  Value *DoPHITranslation(const BasicBlock *CurBB, const BasicBlock *PredBB);

  const Value *DoPHITranslation(const BasicBlock *CurBB,
                                const BasicBlock *PredBB) const{
    return const_cast<Value*>(this)->DoPHITranslation(CurBB, PredBB);
  }

protected:
  unsigned short getSubclassDataFromValue() const { return SubclassData; }
  void setValueSubclassData(unsigned short D) { SubclassData = D; }
};

inline raw_ostream &operator<<(raw_ostream &OS, const Value &V) {
  V.print(OS);
  return OS;
}

void Use::set(Value *V) {
  if (Val) removeFromList();
  Val = V;
  if (V) V->addUse(*this);
}





template <> inline bool isa_impl<Constant, Value>(const Value &Val) {
  return Val.getValueID() >= Value::ConstantFirstVal &&
         Val.getValueID() <= Value::ConstantLastVal;
}
template <> inline bool isa_impl<Argument, Value>(const Value &Val) {
  return Val.getValueID() == Value::ArgumentVal;
}
template <> inline bool isa_impl<InlineAsm, Value>(const Value &Val) {
  return Val.getValueID() == Value::InlineAsmVal;
}
template <> inline bool isa_impl<Instruction, Value>(const Value &Val) {
  return Val.getValueID() >= Value::InstructionVal;
}
template <> inline bool isa_impl<BasicBlock, Value>(const Value &Val) {
  return Val.getValueID() == Value::BasicBlockVal;
}
template <> inline bool isa_impl<Function, Value>(const Value &Val) {
  return Val.getValueID() == Value::FunctionVal;
}
template <> inline bool isa_impl<GlobalVariable, Value>(const Value &Val) {
  return Val.getValueID() == Value::GlobalVariableVal;
}
template <> inline bool isa_impl<GlobalAlias, Value>(const Value &Val) {
  return Val.getValueID() == Value::GlobalAliasVal;
}
template <> inline bool isa_impl<GlobalValue, Value>(const Value &Val) {
  return isa<GlobalVariable>(Val) || isa<Function>(Val) ||
         isa<GlobalAlias>(Val);
}
template <> inline bool isa_impl<MDNode, Value>(const Value &Val) {
  return Val.getValueID() == Value::MDNodeVal;
}



template<>
class PointerLikeTypeTraits<Value*> {
  typedef Value* PT;
public:
  static inline void *getAsVoidPointer(PT P) { return P; }
  static inline PT getFromVoidPointer(void *P) {
    return static_cast<PT>(P);
  }
  enum { NumLowBitsAvailable = 2 };
};

}
# 23 "/local/monniaux/packages/llvm-2.7/include/llvm/User.h" 2

namespace llvm {




template <class>
struct OperandTraits;

class User;


template <>
struct OperandTraits<User> {
  static inline Use *op_begin(User*);
  static inline Use *op_end(User*);
  static inline unsigned operands(const User*);
  template <class U>
  struct Layout {
    typedef U overlay;
  };
};

class User : public Value {
  User(const User &);
  void *operator new(size_t);
  template <unsigned>
  friend struct HungoffOperandTraits;
protected:





  Use *OperandList;



  unsigned NumOperands;

  void *operator new(size_t s, unsigned Us);
  void *operator new(size_t s, unsigned Us, bool Prefix);
  User(const Type *ty, unsigned vty, Use *OpList, unsigned NumOps)
    : Value(ty, vty), OperandList(OpList), NumOperands(NumOps) {}
  Use *allocHungoffUses(unsigned) const;
  void dropHungoffUses(Use *U) {
    if (OperandList == U) {
      OperandList = 0;
      NumOperands = 0;
    }
    Use::zap(U, U->getImpliedUser(), true);
  }
public:
  ~User() {
    if ((intptr_t(OperandList) & 1) == 0)
      Use::zap(OperandList, OperandList + NumOperands);
  }

  void operator delete(void *Usr);

  void operator delete(void*, unsigned) {
    ((0 && "Constructor throws?") ? static_cast<void> (0) : __assert_fail ("0 && \"Constructor throws?\"", "/local/monniaux/packages/llvm-2.7/include/llvm/User.h", 84, __PRETTY_FUNCTION__));
  }

  void operator delete(void*, unsigned, bool) {
    ((0 && "Constructor throws?") ? static_cast<void> (0) : __assert_fail ("0 && \"Constructor throws?\"", "/local/monniaux/packages/llvm-2.7/include/llvm/User.h", 88, __PRETTY_FUNCTION__));
  }
protected:
  template <int Idx, typename U> static Use &OpFrom(const U *that) {
    return Idx < 0
      ? OperandTraits<U>::op_end(const_cast<U*>(that))[Idx]
      : OperandTraits<U>::op_begin(const_cast<U*>(that))[Idx];
  }
  template <int Idx> Use &Op() {
    return OpFrom<Idx>(this);
  }
  template <int Idx> const Use &Op() const {
    return OpFrom<Idx>(this);
  }
public:
  Value *getOperand(unsigned i) const {
    ((i < NumOperands && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i < NumOperands && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/User.h", 104, __PRETTY_FUNCTION__));
    return OperandList[i];
  }
  void setOperand(unsigned i, Value *Val) {
    ((i < NumOperands && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i < NumOperands && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/User.h", 108, __PRETTY_FUNCTION__));
    (((!isa<Constant>((const Value*)this) || isa<GlobalValue>((const Value*)this)) && "Cannot mutate a constant with setOperand!") ? static_cast<void> (0) : __assert_fail ("(!isa<Constant>((const Value*)this) || isa<GlobalValue>((const Value*)this)) && \"Cannot mutate a constant with setOperand!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/User.h", 111, __PRETTY_FUNCTION__));


    OperandList[i] = Val;
  }
  const Use &getOperandUse(unsigned i) const {
    ((i < NumOperands && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i < NumOperands && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/User.h", 115, __PRETTY_FUNCTION__));
    return OperandList[i];
  }
  Use &getOperandUse(unsigned i) {
    ((i < NumOperands && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i < NumOperands && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/User.h", 119, __PRETTY_FUNCTION__));
    return OperandList[i];
  }

  unsigned getNumOperands() const { return NumOperands; }




  typedef Use* op_iterator;
  typedef const Use* const_op_iterator;

  inline op_iterator op_begin() { return OperandList; }
  inline const_op_iterator op_begin() const { return OperandList; }
  inline op_iterator op_end() { return OperandList+NumOperands; }
  inline const_op_iterator op_end() const { return OperandList+NumOperands; }
# 144 "/local/monniaux/packages/llvm-2.7/include/llvm/User.h"
  void dropAllReferences() {
    for (op_iterator i = op_begin(), e = op_end(); i != e; ++i)
      i->set(0);
  }




  void replaceUsesOfWith(Value *From, Value *To);


  static inline bool classof(const User *) { return true; }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) || isa<Constant>(V);
  }
};

inline Use *OperandTraits<User>::op_begin(User *U) {
  return U->op_begin();
}

inline Use *OperandTraits<User>::op_end(User *U) {
  return U->op_end();
}

inline unsigned OperandTraits<User>::operands(const User *U) {
  return U->getNumOperands();
}

template<> struct simplify_type<User::op_iterator> {
  typedef Value* SimpleType;

  static SimpleType getSimplifiedValue(const User::op_iterator &Val) {
    return static_cast<SimpleType>(Val->get());
  }
};

template<> struct simplify_type<const User::op_iterator>
  : public simplify_type<User::op_iterator> {};

template<> struct simplify_type<User::const_op_iterator> {
  typedef Value* SimpleType;

  static SimpleType getSimplifiedValue(const User::const_op_iterator &Val) {
    return static_cast<SimpleType>(Val->get());
  }
};

template<> struct simplify_type<const User::const_op_iterator>
  : public simplify_type<User::const_op_iterator> {};



template<typename UserTy>
unsigned value_use_iterator<UserTy>::getOperandNo() const {
  return U - U->getUser()->op_begin();
}

}
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/Constant.h" 2

namespace llvm {
  class APInt;

  template<typename T> class SmallVectorImpl;
  class LLVMContext;
# 42 "/local/monniaux/packages/llvm-2.7/include/llvm/Constant.h"
class Constant : public User {
  void operator=(const Constant &);
  Constant(const Constant &);

protected:
  Constant(const Type *ty, ValueTy vty, Use *Ops, unsigned NumOps)
    : User(ty, vty, Ops, NumOps) {}

  void destroyConstantImpl();

  void setOperand(unsigned i, Value *V) {
    User::setOperand(i, V);
  }
public:


  virtual bool isNullValue() const = 0;



  virtual bool isNegativeZeroValue() const { return isNullValue(); }



  bool canTrap() const;



  bool isConstantUsed() const;

  enum PossibleRelocationsTy {
    NoRelocation = 0,
    LocalRelocation = 1,
    GlobalRelocations = 2
  };
# 92 "/local/monniaux/packages/llvm-2.7/include/llvm/Constant.h"
  PossibleRelocationsTy getRelocationInfo() const;



  User *getOperand(unsigned i) {
    return static_cast<User*>(User::getOperand(i));
  }
  const User *getOperand(unsigned i) const {
    return static_cast<const User*>(User::getOperand(i));
  }





  void getVectorElements(SmallVectorImpl<Constant*> &Elts) const;
# 116 "/local/monniaux/packages/llvm-2.7/include/llvm/Constant.h"
  virtual void destroyConstant() { ((0 && "Not reached!") ? static_cast<void> (0) : __assert_fail ("0 && \"Not reached!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constant.h", 116, __PRETTY_FUNCTION__)); }


  static inline bool classof(const Constant *) { return true; }
  static inline bool classof(const GlobalValue *) { return true; }
  static inline bool classof(const Value *V) {
    return V->getValueID() >= ConstantFirstVal &&
           V->getValueID() <= ConstantLastVal;
  }
# 136 "/local/monniaux/packages/llvm-2.7/include/llvm/Constant.h"
  virtual void replaceUsesOfWithOnConstant(Value *, Value *, Use *) {



    ((getNumOperands() == 0 && "replaceUsesOfWithOnConstant must be " "implemented for all constants that have operands!") ? static_cast<void> (0) : __assert_fail ("getNumOperands() == 0 && \"replaceUsesOfWithOnConstant must be \" \"implemented for all constants that have operands!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constant.h", 141, __PRETTY_FUNCTION__));

    ((0 && "Constants that do not have operands cannot be using 'From'!") ? static_cast<void> (0) : __assert_fail ("0 && \"Constants that do not have operands cannot be using 'From'!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constant.h", 142, __PRETTY_FUNCTION__));
  }

  static Constant* getNullValue(const Type* Ty);




  static Constant* getAllOnesValue(const Type* Ty);



  static Constant* getIntegerValue(const Type* Ty, const APInt &V);
};

}
# 25 "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/OperandTraits.h" 1
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/OperandTraits.h"
namespace llvm {
# 30 "/local/monniaux/packages/llvm-2.7/include/llvm/OperandTraits.h"
template <unsigned ARITY>
struct FixedNumOperandTraits {
  static Use *op_begin(User* U) {
    return reinterpret_cast<Use*>(U) - ARITY;
  }
  static Use *op_end(User* U) {
    return reinterpret_cast<Use*>(U);
  }
  static unsigned operands(const User*) {
    return ARITY;
  }
  struct prefix {
    Use Ops[ARITY];
    prefix();
  };
  template <class U>
  struct Layout {
    struct overlay : public prefix, public U {
      overlay();
    };
  };
};





template <unsigned ARITY = 1>
struct OptionalOperandTraits : public FixedNumOperandTraits<ARITY> {
  static unsigned operands(const User *U) {
    return U->getNumOperands();
  }
};
# 72 "/local/monniaux/packages/llvm-2.7/include/llvm/OperandTraits.h"
template <unsigned MINARITY = 0>
struct VariadicOperandTraits {
  static Use *op_begin(User* U) {
    return reinterpret_cast<Use*>(U) - U->getNumOperands();
  }
  static Use *op_end(User* U) {
    return reinterpret_cast<Use*>(U);
  }
  static unsigned operands(const User *U) {
    return U->getNumOperands();
  }
};
# 99 "/local/monniaux/packages/llvm-2.7/include/llvm/OperandTraits.h"
template <unsigned MINARITY = 1>
struct HungoffOperandTraits {
  static Use *op_begin(User* U) {
    return U->OperandList;
  }
  static Use *op_end(User* U) {
    return U->OperandList + U->getNumOperands();
  }
  static unsigned operands(const User *U) {
    return U->getNumOperands();
  }
};
# 202 "/local/monniaux/packages/llvm-2.7/include/llvm/OperandTraits.h"
}
# 26 "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h" 1
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/MathExtras.h" 1
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/MathExtras.h"
namespace llvm {






inline uint32_t Hi_32(uint64_t Value) {
  return static_cast<uint32_t>(Value >> 32);
}


inline uint32_t Lo_32(uint64_t Value) {
  return static_cast<uint32_t>(Value);
}


inline bool isInt8 (int64_t Value) {
  return static_cast<int8_t>(Value) == Value;
}
inline bool isUInt8 (int64_t Value) {
  return static_cast<uint8_t>(Value) == Value;
}
inline bool isInt16 (int64_t Value) {
  return static_cast<int16_t>(Value) == Value;
}
inline bool isUInt16(int64_t Value) {
  return static_cast<uint16_t>(Value) == Value;
}
inline bool isInt32 (int64_t Value) {
  return static_cast<int32_t>(Value) == Value;
}
inline bool isUInt32(int64_t Value) {
  return static_cast<uint32_t>(Value) == Value;
}

template<unsigned N>
inline bool isInt(int64_t x) {
  return N >= 64 || (-(1LL<<(N-1)) <= x && x < (1LL<<(N-1)));
}

template<unsigned N>
inline bool isUint(uint64_t x) {
  return N >= 64 || x < (1ULL<<N);
}




inline bool isMask_32(uint32_t Value) {
  return Value && ((Value + 1) & Value) == 0;
}




inline bool isMask_64(uint64_t Value) {
  return Value && ((Value + 1) & Value) == 0;
}




inline bool isShiftedMask_32(uint32_t Value) {
  return isMask_32((Value - 1) | Value);
}



inline bool isShiftedMask_64(uint64_t Value) {
  return isMask_64((Value - 1) | Value);
}



inline bool isPowerOf2_32(uint32_t Value) {
  return Value && !(Value & (Value - 1));
}



inline bool isPowerOf2_64(uint64_t Value) {
  return Value && !(Value & (Value - int64_t(1L)));
}



inline uint16_t ByteSwap_16(uint16_t Value) {





  uint16_t Hi = Value << 8;
  uint16_t Lo = Value >> 8;
  return Hi | Lo;

}



inline uint32_t ByteSwap_32(uint32_t Value) {

  return __builtin_bswap32(Value);
# 132 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/MathExtras.h"
}



inline uint64_t ByteSwap_64(uint64_t Value) {

  return __builtin_bswap64(Value);







}





inline unsigned CountLeadingZeros_32(uint32_t Value) {
  unsigned Count;



  if (!Value) return 32;

  Count = __builtin_clz(Value);
# 173 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/MathExtras.h"
  return Count;
}





inline unsigned CountLeadingOnes_32(uint32_t Value) {
  return CountLeadingZeros_32(~Value);
}





inline unsigned CountLeadingZeros_64(uint64_t Value) {
  unsigned Count;



  if (!Value) return 64;

  Count = __builtin_clzll(Value);
# 225 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/MathExtras.h"
  return Count;
}





inline unsigned CountLeadingOnes_64(uint64_t Value) {
  return CountLeadingZeros_64(~Value);
}





inline unsigned CountTrailingZeros_32(uint32_t Value) {

  return Value ? __builtin_ctz(Value) : 32;
# 251 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/MathExtras.h"
}





inline unsigned CountTrailingOnes_32(uint32_t Value) {
  return CountTrailingZeros_32(~Value);
}





inline unsigned CountTrailingZeros_64(uint64_t Value) {

  return Value ? __builtin_ctzll(Value) : 64;
# 278 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/MathExtras.h"
}





inline unsigned CountTrailingOnes_64(uint64_t Value) {
  return CountTrailingZeros_64(~Value);
}




inline unsigned CountPopulation_32(uint32_t Value) {

  return __builtin_popcount(Value);





}



inline unsigned CountPopulation_64(uint64_t Value) {

  return __builtin_popcountll(Value);






}




inline unsigned Log2_32(uint32_t Value) {
  return 31 - CountLeadingZeros_32(Value);
}



inline unsigned Log2_64(uint64_t Value) {
  return 63 - CountLeadingZeros_64(Value);
}




inline unsigned Log2_32_Ceil(uint32_t Value) {
  return 32-CountLeadingZeros_32(Value-1);
}



inline unsigned Log2_64_Ceil(uint64_t Value) {
  return 64-CountLeadingZeros_64(Value-1);
}



inline uint64_t GreatestCommonDivisor64(uint64_t A, uint64_t B) {
  while (B) {
    uint64_t T = B;
    B = A % B;
    A = T;
  }
  return A;
}



inline double BitsToDouble(uint64_t Bits) {
  union {
    uint64_t L;
    double D;
  } T;
  T.L = Bits;
  return T.D;
}



inline float BitsToFloat(uint32_t Bits) {
  union {
    uint32_t I;
    float F;
  } T;
  T.I = Bits;
  return T.F;
}





inline uint64_t DoubleToBits(double Double) {
  union {
    uint64_t L;
    double D;
  } T;
  T.D = Double;
  return T.L;
}





inline uint32_t FloatToBits(float Float) {
  union {
    uint32_t I;
    float F;
  } T;
  T.F = Float;
  return T.I;
}


int IsNAN(float f);
int IsNAN(double d);


int IsInf(float f);
int IsInf(double d);



static inline uint64_t MinAlign(uint64_t A, uint64_t B) {

  return (A | B) & -(A | B);
}



static inline uint64_t NextPowerOf2(uint64_t A) {
  A |= (A >> 1);
  A |= (A >> 2);
  A |= (A >> 4);
  A |= (A >> 8);
  A |= (A >> 16);
  A |= (A >> 32);
  return A + 1;
}
# 434 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/MathExtras.h"
inline uint64_t RoundUpToAlignment(uint64_t Value, uint64_t Align) {
  return ((Value + Align - 1) / Align) * Align;
}




inline uint64_t OffsetToAlignment(uint64_t Value, uint64_t Align) {
  return RoundUpToAlignment(Value, Align) - Value;
}




inline int64_t abs64(int64_t x) {
  return (x < 0) ? -x : x;
}

}
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h" 2
# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h" 2
# 1 "/usr/include/c++/4.3/climits" 1 3
# 46 "/usr/include/c++/4.3/climits" 3
       
# 47 "/usr/include/c++/4.3/climits" 3

# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include-fixed/limits.h" 1 3 4
# 11 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include-fixed/limits.h" 1 3 4
# 122 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 153 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 36 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 37 "/usr/include/bits/local_lim.h" 2 3 4
# 154 "/usr/include/bits/posix1_lim.h" 2 3 4
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 150 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 35 "/usr/include/bits/xopen_lim.h" 2 3 4
# 154 "/usr/include/limits.h" 2 3 4
# 123 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include-fixed/syslimits.h" 2 3 4
# 12 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include-fixed/limits.h" 2 3 4
# 49 "/usr/include/c++/4.3/climits" 2 3
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h" 2
# 1 "/usr/include/c++/4.3/cstring" 1 3
# 45 "/usr/include/c++/4.3/cstring" 3
       
# 46 "/usr/include/c++/4.3/cstring" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 49 "/usr/include/c++/4.3/cstring" 2 3
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h" 2


namespace llvm {
  class Serializer;
  class Deserializer;
  class FoldingSetNodeID;
  class raw_ostream;
  class StringRef;

  template<typename T>
  class SmallVectorImpl;



  typedef uint64_t integerPart;

  const unsigned int host_char_bit = 8;
  const unsigned int integerPartWidth = host_char_bit *
    static_cast<unsigned int>(sizeof(integerPart));
# 72 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h"
class APInt {
  unsigned BitWidth;



  union {
    uint64_t VAL;
    uint64_t *pVal;
  };


  enum {

    APINT_BITS_PER_WORD = static_cast<unsigned int>(sizeof(uint64_t)) *
                          8,

    APINT_WORD_SIZE = static_cast<unsigned int>(sizeof(uint64_t))
  };




  APInt(uint64_t* val, unsigned bits) : BitWidth(bits), pVal(val) { }



  bool isSingleWord() const {
    return BitWidth <= APINT_BITS_PER_WORD;
  }



  static unsigned whichWord(unsigned bitPosition) {
    return bitPosition / APINT_BITS_PER_WORD;
  }




  static unsigned whichBit(unsigned bitPosition) {
    return bitPosition % APINT_BITS_PER_WORD;
  }






  static uint64_t maskBit(unsigned bitPosition) {
    return 1ULL << whichBit(bitPosition);
  }






  APInt& clearUnusedBits() {

    unsigned wordBits = BitWidth % APINT_BITS_PER_WORD;
    if (wordBits == 0)



      return *this;


    uint64_t mask = ~uint64_t(0ULL) >> (APINT_BITS_PER_WORD - wordBits);
    if (isSingleWord())
      VAL &= mask;
    else
      pVal[getNumWords() - 1] &= mask;
    return *this;
  }



  uint64_t getWord(unsigned bitPosition) const {
    return isSingleWord() ? VAL : pVal[whichWord(bitPosition)];
  }
# 165 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h"
  void fromString(unsigned numBits, const StringRef &str, uint8_t radix);






  static void divide(const APInt LHS, unsigned lhsWords,
                     const APInt &RHS, unsigned rhsWords,
                     APInt *Quotient, APInt *Remainder);


  void initSlowCase(unsigned numBits, uint64_t val, bool isSigned);


  void initSlowCase(const APInt& that);


  APInt shlSlowCase(unsigned shiftAmt) const;


  APInt AndSlowCase(const APInt& RHS) const;


  APInt OrSlowCase(const APInt& RHS) const;


  APInt XorSlowCase(const APInt& RHS) const;


  APInt& AssignSlowCase(const APInt& RHS);


  bool EqualSlowCase(const APInt& RHS) const;


  bool EqualSlowCase(uint64_t Val) const;


  unsigned countLeadingZerosSlowCase() const;


  unsigned countTrailingOnesSlowCase() const;


  unsigned countPopulationSlowCase() const;

public:
# 223 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h"
  APInt(unsigned numBits, uint64_t val, bool isSigned = false)
    : BitWidth(numBits), VAL(0) {
    ((BitWidth && "bitwidth too small") ? static_cast<void> (0) : __assert_fail ("BitWidth && \"bitwidth too small\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 225, __PRETTY_FUNCTION__));
    if (isSingleWord())
      VAL = val;
    else
      initSlowCase(numBits, val, isSigned);
    clearUnusedBits();
  }







  APInt(unsigned numBits, unsigned numWords, const uint64_t bigVal[]);
# 251 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h"
  APInt(unsigned numBits, const StringRef &str, uint8_t radix);



  APInt(const APInt& that)
    : BitWidth(that.BitWidth), VAL(0) {
    ((BitWidth && "bitwidth too small") ? static_cast<void> (0) : __assert_fail ("BitWidth && \"bitwidth too small\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 257, __PRETTY_FUNCTION__));
    if (isSingleWord())
      VAL = that.VAL;
    else
      initSlowCase(that);
  }


  ~APInt() {
    if (!isSingleWord())
      delete [] pVal;
  }



  explicit APInt() : BitWidth(1) {}



  void Profile(FoldingSetNodeID& id) const;


  void Emit(Serializer& S) const;


  void Read(Deserializer& D);







  bool isNegative() const {
    return (*this)[BitWidth - 1];
  }



  bool isNonNegative() const {
    return !isNegative();
  }





  bool isStrictlyPositive() const {
    return isNonNegative() && (*this) != 0;
  }



  bool isAllOnesValue() const {
    return countPopulation() == BitWidth;
  }




  bool isMaxValue() const {
    return countPopulation() == BitWidth;
  }




  bool isMaxSignedValue() const {
    return BitWidth == 1 ? VAL == 0 :
                          !isNegative() && countPopulation() == BitWidth - 1;
  }




  bool isMinValue() const {
    return countPopulation() == 0;
  }




  bool isMinSignedValue() const {
    return BitWidth == 1 ? VAL == 1 :
                           isNegative() && countPopulation() == 1;
  }


  bool isIntN(unsigned N) const {
    ((N && "N == 0 ???") ? static_cast<void> (0) : __assert_fail ("N && \"N == 0 ???\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 346, __PRETTY_FUNCTION__));
    if (N >= getBitWidth())
      return true;

    if (isSingleWord())
      return VAL == (VAL & (~0ULL >> (64 - N)));
    APInt Tmp(N, getNumWords(), pVal);
    Tmp.zext(getBitWidth());
    return Tmp == (*this);
  }


  bool isSignedIntN(unsigned N) const {
    ((N && "N == 0 ???") ? static_cast<void> (0) : __assert_fail ("N && \"N == 0 ???\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 359, __PRETTY_FUNCTION__));
    return getMinSignedBits() <= N;
  }


  bool isPowerOf2() const;


  bool isSignBit() const { return isMinSignedValue(); }



  bool getBoolValue() const {
    return *this != 0;
  }




  uint64_t getLimitedValue(uint64_t Limit = ~0ULL) const {
    return (getActiveBits() > 64 || getZExtValue() > Limit) ?
      Limit : getZExtValue();
  }





  static APInt getMaxValue(unsigned numBits) {
    return APInt(numBits, 0).set();
  }


  static APInt getSignedMaxValue(unsigned numBits) {
    return APInt(numBits, 0).set().clear(numBits - 1);
  }


  static APInt getMinValue(unsigned numBits) {
    return APInt(numBits, 0);
  }


  static APInt getSignedMinValue(unsigned numBits) {
    return APInt(numBits, 0).set(numBits - 1);
  }




  static APInt getSignBit(unsigned BitWidth) {
    return getSignedMinValue(BitWidth);
  }



  static APInt getAllOnesValue(unsigned numBits) {
    return APInt(numBits, 0).set();
  }



  static APInt getNullValue(unsigned numBits) {
    return APInt(numBits, 0);
  }




  APInt getHiBits(unsigned numBits) const;




  APInt getLoBits(unsigned numBits) const;
# 445 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h"
  static APInt getBitsSet(unsigned numBits, unsigned loBit, unsigned hiBit) {
    ((hiBit <= numBits && "hiBit out of range") ? static_cast<void> (0) : __assert_fail ("hiBit <= numBits && \"hiBit out of range\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 446, __PRETTY_FUNCTION__));
    ((loBit < numBits && "loBit out of range") ? static_cast<void> (0) : __assert_fail ("loBit < numBits && \"loBit out of range\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 447, __PRETTY_FUNCTION__));
    if (hiBit < loBit)
      return getLowBitsSet(numBits, hiBit) |
             getHighBitsSet(numBits, numBits-loBit);
    return getLowBitsSet(numBits, hiBit-loBit).shl(loBit);
  }





  static APInt getHighBitsSet(unsigned numBits, unsigned hiBitsSet) {
    ((hiBitsSet <= numBits && "Too many bits to set!") ? static_cast<void> (0) : __assert_fail ("hiBitsSet <= numBits && \"Too many bits to set!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 459, __PRETTY_FUNCTION__));

    if (hiBitsSet == 0)
      return APInt(numBits, 0);
    unsigned shiftAmt = numBits - hiBitsSet;

    if (numBits <= APINT_BITS_PER_WORD)
      return APInt(numBits, ~0ULL << shiftAmt);
    return (~APInt(numBits, 0)).shl(shiftAmt);
  }





  static APInt getLowBitsSet(unsigned numBits, unsigned loBitsSet) {
    ((loBitsSet <= numBits && "Too many bits to set!") ? static_cast<void> (0) : __assert_fail ("loBitsSet <= numBits && \"Too many bits to set!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 475, __PRETTY_FUNCTION__));

    if (loBitsSet == 0)
      return APInt(numBits, 0);
    if (loBitsSet == APINT_BITS_PER_WORD)
      return APInt(numBits, -1ULL);

    if (numBits < APINT_BITS_PER_WORD)
      return APInt(numBits, (1ULL << loBitsSet) - 1);
    return (~APInt(numBits, 0)).lshr(numBits - loBitsSet);
  }




  uint64_t getHashValue() const;




  const uint64_t* getRawData() const {
    if (isSingleWord())
      return &VAL;
    return &pVal[0];
  }






  const APInt operator++(int) {
    APInt API(*this);
    ++(*this);
    return API;
  }



  APInt& operator++();



  const APInt operator--(int) {
    APInt API(*this);
    --(*this);
    return API;
  }



  APInt& operator--();




  APInt operator~() const {
    APInt Result(*this);
    Result.flip();
    return Result;
  }




  APInt operator-() const {
    return APInt(BitWidth, 0) - (*this);
  }




  bool operator!() const;






  APInt& operator=(const APInt& RHS) {

    if (isSingleWord() && RHS.isSingleWord()) {
      VAL = RHS.VAL;
      BitWidth = RHS.BitWidth;
      return clearUnusedBits();
    }

    return AssignSlowCase(RHS);
  }






  APInt& operator=(uint64_t RHS);





  APInt& operator&=(const APInt& RHS);





  APInt& operator|=(const APInt& RHS);






  APInt& operator|=(uint64_t RHS) {
    if (isSingleWord()) {
      VAL |= RHS;
      clearUnusedBits();
    } else {
      pVal[0] |= RHS;
    }
    return *this;
  }





  APInt& operator^=(const APInt& RHS);




  APInt& operator*=(const APInt& RHS);




  APInt& operator+=(const APInt& RHS);




  APInt& operator-=(const APInt& RHS);




  APInt& operator<<=(unsigned shiftAmt) {
    *this = shl(shiftAmt);
    return *this;
  }







  APInt operator&(const APInt& RHS) const {
    ((BitWidth == RHS.BitWidth && "Bit widths must be the same") ? static_cast<void> (0) : __assert_fail ("BitWidth == RHS.BitWidth && \"Bit widths must be the same\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 635, __PRETTY_FUNCTION__));
    if (isSingleWord())
      return APInt(getBitWidth(), VAL & RHS.VAL);
    return AndSlowCase(RHS);
  }
  APInt And(const APInt& RHS) const {
    return this->operator&(RHS);
  }




  APInt operator|(const APInt& RHS) const {
    ((BitWidth == RHS.BitWidth && "Bit widths must be the same") ? static_cast<void> (0) : __assert_fail ("BitWidth == RHS.BitWidth && \"Bit widths must be the same\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 648, __PRETTY_FUNCTION__));
    if (isSingleWord())
      return APInt(getBitWidth(), VAL | RHS.VAL);
    return OrSlowCase(RHS);
  }
  APInt Or(const APInt& RHS) const {
    return this->operator|(RHS);
  }




  APInt operator^(const APInt& RHS) const {
    ((BitWidth == RHS.BitWidth && "Bit widths must be the same") ? static_cast<void> (0) : __assert_fail ("BitWidth == RHS.BitWidth && \"Bit widths must be the same\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 661, __PRETTY_FUNCTION__));
    if (isSingleWord())
      return APInt(BitWidth, VAL ^ RHS.VAL);
    return XorSlowCase(RHS);
  }
  APInt Xor(const APInt& RHS) const {
    return this->operator^(RHS);
  }



  APInt operator*(const APInt& RHS) const;



  APInt operator+(const APInt& RHS) const;
  APInt operator+(uint64_t RHS) const {
    return (*this) + APInt(BitWidth, RHS);
  }



  APInt operator-(const APInt& RHS) const;
  APInt operator-(uint64_t RHS) const {
    return (*this) - APInt(BitWidth, RHS);
  }

  APInt operator<<(unsigned Bits) const {
    return shl(Bits);
  }

  APInt operator<<(const APInt &Bits) const {
    return shl(Bits);
  }



  APInt ashr(unsigned shiftAmt) const;



  APInt lshr(unsigned shiftAmt) const;



  APInt shl(unsigned shiftAmt) const {
    ((shiftAmt <= BitWidth && "Invalid shift amount") ? static_cast<void> (0) : __assert_fail ("shiftAmt <= BitWidth && \"Invalid shift amount\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 707, __PRETTY_FUNCTION__));
    if (isSingleWord()) {
      if (shiftAmt == BitWidth)
        return APInt(BitWidth, 0);
      return APInt(BitWidth, VAL << shiftAmt);
    }
    return shlSlowCase(shiftAmt);
  }


  APInt rotl(unsigned rotateAmt) const;


  APInt rotr(unsigned rotateAmt) const;



  APInt ashr(const APInt &shiftAmt) const;



  APInt lshr(const APInt &shiftAmt) const;



  APInt shl(const APInt &shiftAmt) const;


  APInt rotl(const APInt &rotateAmt) const;


  APInt rotr(const APInt &rotateAmt) const;





  APInt udiv(const APInt& RHS) const;



  APInt sdiv(const APInt& RHS) const {
    if (isNegative())
      if (RHS.isNegative())
        return (-(*this)).udiv(-RHS);
      else
        return -((-(*this)).udiv(RHS));
    else if (RHS.isNegative())
      return -(this->udiv(-RHS));
    return this->udiv(RHS);
  }
# 766 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h"
  APInt urem(const APInt& RHS) const;



  APInt srem(const APInt& RHS) const {
    if (isNegative())
      if (RHS.isNegative())
        return -((-(*this)).urem(-RHS));
      else
        return -((-(*this)).urem(RHS));
    else if (RHS.isNegative())
      return this->urem(-RHS);
    return this->urem(RHS);
  }







  static void udivrem(const APInt &LHS, const APInt &RHS,
                      APInt &Quotient, APInt &Remainder);

  static void sdivrem(const APInt &LHS, const APInt &RHS,
                      APInt &Quotient, APInt &Remainder)
  {
    if (LHS.isNegative()) {
      if (RHS.isNegative())
        APInt::udivrem(-LHS, -RHS, Quotient, Remainder);
      else
        APInt::udivrem(-LHS, RHS, Quotient, Remainder);
      Quotient = -Quotient;
      Remainder = -Remainder;
    } else if (RHS.isNegative()) {
      APInt::udivrem(LHS, -RHS, Quotient, Remainder);
      Quotient = -Quotient;
    } else {
      APInt::udivrem(LHS, RHS, Quotient, Remainder);
    }
  }



  bool operator[](unsigned bitPosition) const;







  bool operator==(const APInt& RHS) const {
    ((BitWidth == RHS.BitWidth && "Comparison requires equal bit widths") ? static_cast<void> (0) : __assert_fail ("BitWidth == RHS.BitWidth && \"Comparison requires equal bit widths\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 819, __PRETTY_FUNCTION__));
    if (isSingleWord())
      return VAL == RHS.VAL;
    return EqualSlowCase(RHS);
  }





  bool operator==(uint64_t Val) const {
    if (isSingleWord())
      return VAL == Val;
    return EqualSlowCase(Val);
  }





  bool eq(const APInt &RHS) const {
    return (*this) == RHS;
  }





  bool operator!=(const APInt& RHS) const {
    return !((*this) == RHS);
  }





  bool operator!=(uint64_t Val) const {
    return !((*this) == Val);
  }





  bool ne(const APInt &RHS) const {
    return !((*this) == RHS);
  }





  bool ult(const APInt& RHS) const;





  bool slt(const APInt& RHS) const;





  bool ule(const APInt& RHS) const {
    return ult(RHS) || eq(RHS);
  }





  bool sle(const APInt& RHS) const {
    return slt(RHS) || eq(RHS);
  }





  bool ugt(const APInt& RHS) const {
    return !ult(RHS) && !eq(RHS);
  }





  bool sgt(const APInt& RHS) const {
    return !slt(RHS) && !eq(RHS);
  }





  bool uge(const APInt& RHS) const {
    return !ult(RHS);
  }





  bool sge(const APInt& RHS) const {
    return !slt(RHS);
  }



  bool intersects(const APInt &RHS) const {
    return (*this & RHS) != 0;
  }







  APInt &trunc(unsigned width);






  APInt &sext(unsigned width);





  APInt &zext(unsigned width);




  APInt &sextOrTrunc(unsigned width);




  APInt &zextOrTrunc(unsigned width);





  APInt& set() {
    if (isSingleWord()) {
      VAL = -1ULL;
      return clearUnusedBits();
    }


    for (unsigned i = 0; i < getNumWords(); ++i)
      pVal[i] = -1ULL;

    return clearUnusedBits();
  }



  APInt& set(unsigned bitPosition);


  APInt& clear() {
    if (isSingleWord())
      VAL = 0;
    else
      memset(pVal, 0, getNumWords() * APINT_WORD_SIZE);
    return *this;
  }



  APInt& clear(unsigned bitPosition);


  APInt& flip() {
    if (isSingleWord()) {
      VAL ^= -1ULL;
      return clearUnusedBits();
    }
    for (unsigned i = 0; i < getNumWords(); ++i)
      pVal[i] ^= -1ULL;
    return clearUnusedBits();
  }




  APInt& flip(unsigned bitPosition);






  unsigned getBitWidth() const {
    return BitWidth;
  }




  unsigned getNumWords() const {
    return getNumWords(BitWidth);
  }





  static unsigned getNumWords(unsigned BitWidth) {
    return (BitWidth + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;
  }





  unsigned getActiveBits() const {
    return BitWidth - countLeadingZeros();
  }




  unsigned getActiveWords() const {
    return whichWord(getActiveBits()-1) + 1;
  }
# 1060 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h"
  unsigned getMinSignedBits() const {
    if (isNegative())
      return BitWidth - countLeadingOnes() + 1;
    return getActiveBits()+1;
  }





  uint64_t getZExtValue() const {
    if (isSingleWord())
      return VAL;
    ((getActiveBits() <= 64 && "Too many bits for uint64_t") ? static_cast<void> (0) : __assert_fail ("getActiveBits() <= 64 && \"Too many bits for uint64_t\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 1073, __PRETTY_FUNCTION__));
    return pVal[0];
  }





  int64_t getSExtValue() const {
    if (isSingleWord())
      return int64_t(VAL << (APINT_BITS_PER_WORD - BitWidth)) >>
                     (APINT_BITS_PER_WORD - BitWidth);
    ((getMinSignedBits() <= 64 && "Too many bits for int64_t") ? static_cast<void> (0) : __assert_fail ("getMinSignedBits() <= 64 && \"Too many bits for int64_t\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h", 1085, __PRETTY_FUNCTION__));
    return int64_t(pVal[0]);
  }




  static unsigned getBitsNeeded(const StringRef& str, uint8_t radix);







  unsigned countLeadingZeros() const {
    if (isSingleWord()) {
      unsigned unusedBits = APINT_BITS_PER_WORD - BitWidth;
      return CountLeadingZeros_64(VAL) - unusedBits;
    }
    return countLeadingZerosSlowCase();
  }







  unsigned countLeadingOnes() const;
# 1123 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h"
  unsigned countTrailingZeros() const;
# 1132 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h"
  unsigned countTrailingOnes() const {
    if (isSingleWord())
      return CountTrailingOnes_64(VAL);
    return countTrailingOnesSlowCase();
  }







  unsigned countPopulation() const {
    if (isSingleWord())
      return CountPopulation_64(VAL);
    return countPopulationSlowCase();
  }




  void print(raw_ostream &OS, bool isSigned) const;



  void toString(SmallVectorImpl<char> &Str, unsigned Radix, bool Signed) const;



  void toStringUnsigned(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {
    toString(Str, Radix, false);
  }



  void toStringSigned(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {
    toString(Str, Radix, true);
  }




  std::string toString(unsigned Radix, bool Signed) const;



  APInt byteSwap() const;


  double roundToDouble(bool isSigned) const;


  double roundToDouble() const {
    return roundToDouble(false);
  }


  double signedRoundToDouble() const {
    return roundToDouble(true);
  }





  double bitsToDouble() const {
    union {
      uint64_t I;
      double D;
    } T;
    T.I = (isSingleWord() ? VAL : pVal[0]);
    return T.D;
  }





  float bitsToFloat() const {
    union {
      unsigned I;
      float F;
    } T;
    T.I = unsigned((isSingleWord() ? VAL : pVal[0]));
    return T.F;
  }





  APInt& doubleToBits(double V) {
    union {
      uint64_t I;
      double D;
    } T;
    T.D = V;
    if (isSingleWord())
      VAL = T.I;
    else
      pVal[0] = T.I;
    return clearUnusedBits();
  }





  APInt& floatToBits(float V) {
    union {
      unsigned I;
      float F;
    } T;
    T.F = V;
    if (isSingleWord())
      VAL = T.I;
    else
      pVal[0] = T.I;
    return clearUnusedBits();
  }






  unsigned logBase2() const {
    return BitWidth - 1 - countLeadingZeros();
  }


  unsigned ceilLogBase2() const {
    return BitWidth - (*this - 1).countLeadingZeros();
  }



  int32_t exactLogBase2() const {
    if (!isPowerOf2())
      return -1;
    return logBase2();
  }


  APInt sqrt() const;



  APInt abs() const {
    if (isNegative())
      return -(*this);
    return *this;
  }


  APInt multiplicativeInverse(const APInt& modulo) const;






  struct ms;
  ms magic() const;


  struct mu;
  mu magicu() const;
# 1314 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h"
  static void tcSet(integerPart *, integerPart, unsigned int);


  static void tcAssign(integerPart *, const integerPart *, unsigned int);


  static bool tcIsZero(const integerPart *, unsigned int);


  static int tcExtractBit(const integerPart *, unsigned int bit);





  static void tcExtract(integerPart *, unsigned int dstCount,
                        const integerPart *,
                        unsigned int srcBits, unsigned int srcLSB);


  static void tcSetBit(integerPart *, unsigned int bit);


  static void tcClearBit(integerPart *, unsigned int bit);




  static unsigned int tcLSB(const integerPart *, unsigned int);
  static unsigned int tcMSB(const integerPart *parts, unsigned int n);


  static void tcNegate(integerPart *, unsigned int);



  static integerPart tcAdd(integerPart *, const integerPart *,
                           integerPart carry, unsigned);



  static integerPart tcSubtract(integerPart *, const integerPart *,
                                integerPart carry, unsigned);
# 1369 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h"
  static int tcMultiplyPart(integerPart *dst, const integerPart *src,
                            integerPart multiplier, integerPart carry,
                            unsigned int srcParts, unsigned int dstParts,
                            bool add);





  static int tcMultiply(integerPart *, const integerPart *,
                        const integerPart *, unsigned);





  static unsigned int tcFullMultiply(integerPart *, const integerPart *,
                                     const integerPart *, unsigned, unsigned);
# 1398 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APInt.h"
  static int tcDivide(integerPart *lhs, const integerPart *rhs,
                      integerPart *remainder, integerPart *scratch,
                      unsigned int parts);



  static void tcShiftLeft(integerPart *, unsigned int parts,
                          unsigned int count);



  static void tcShiftRight(integerPart *, unsigned int parts,
                           unsigned int count);


  static void tcAnd(integerPart *, const integerPart *, unsigned int);
  static void tcOr(integerPart *, const integerPart *, unsigned int);
  static void tcXor(integerPart *, const integerPart *, unsigned int);
  static void tcComplement(integerPart *, unsigned int);


  static int tcCompare(const integerPart *, const integerPart *,
                       unsigned int);


  static integerPart tcIncrement(integerPart *, unsigned int);


  static void tcSetLeastSignificantBits(integerPart *, unsigned int,
                                        unsigned int bits);


  void dump() const;


};


struct APInt::ms {
  APInt m;
  unsigned s;
};


struct APInt::mu {
  APInt m;
  bool a;
  unsigned s;
};

inline bool operator==(uint64_t V1, const APInt& V2) {
  return V2 == V1;
}

inline bool operator!=(uint64_t V1, const APInt& V2) {
  return V2 != V1;
}

inline raw_ostream &operator<<(raw_ostream &OS, const APInt &I) {
  I.print(OS, true);
  return OS;
}

namespace APIntOps {


inline APInt smin(const APInt &A, const APInt &B) {
  return A.slt(B) ? A : B;
}


inline APInt smax(const APInt &A, const APInt &B) {
  return A.sgt(B) ? A : B;
}


inline APInt umin(const APInt &A, const APInt &B) {
  return A.ult(B) ? A : B;
}


inline APInt umax(const APInt &A, const APInt &B) {
  return A.ugt(B) ? A : B;
}


inline bool isIntN(unsigned N, const APInt& APIVal) {
  return APIVal.isIntN(N);
}


inline bool isSignedIntN(unsigned N, const APInt& APIVal) {
  return APIVal.isSignedIntN(N);
}



inline bool isMask(unsigned numBits, const APInt& APIVal) {
  return numBits <= APIVal.getBitWidth() &&
    APIVal == APInt::getLowBitsSet(APIVal.getBitWidth(), numBits);
}



inline bool isShiftedMask(unsigned numBits, const APInt& APIVal) {
  return isMask(numBits, (APIVal - APInt(numBits,1)) | APIVal);
}


inline APInt byteSwap(const APInt& APIVal) {
  return APIVal.byteSwap();
}


inline unsigned logBase2(const APInt& APIVal) {
  return APIVal.logBase2();
}





APInt GreatestCommonDivisor(const APInt& Val1, const APInt& Val2);



inline double RoundAPIntToDouble(const APInt& APIVal) {
  return APIVal.roundToDouble();
}



inline double RoundSignedAPIntToDouble(const APInt& APIVal) {
  return APIVal.signedRoundToDouble();
}


inline float RoundAPIntToFloat(const APInt& APIVal) {
  return float(RoundAPIntToDouble(APIVal));
}



inline float RoundSignedAPIntToFloat(const APInt& APIVal) {
  return float(APIVal.signedRoundToDouble());
}



APInt RoundDoubleToAPInt(double Double, unsigned width);



inline APInt RoundFloatToAPInt(float Float, unsigned width) {
  return RoundDoubleToAPInt(double(Float), width);
}



inline APInt ashr(const APInt& LHS, unsigned shiftAmt) {
  return LHS.ashr(shiftAmt);
}



inline APInt lshr(const APInt& LHS, unsigned shiftAmt) {
  return LHS.lshr(shiftAmt);
}



inline APInt shl(const APInt& LHS, unsigned shiftAmt) {
  return LHS.shl(shiftAmt);
}



inline APInt sdiv(const APInt& LHS, const APInt& RHS) {
  return LHS.sdiv(RHS);
}



inline APInt udiv(const APInt& LHS, const APInt& RHS) {
  return LHS.udiv(RHS);
}



inline APInt srem(const APInt& LHS, const APInt& RHS) {
  return LHS.srem(RHS);
}



inline APInt urem(const APInt& LHS, const APInt& RHS) {
  return LHS.urem(RHS);
}



inline APInt mul(const APInt& LHS, const APInt& RHS) {
  return LHS * RHS;
}



inline APInt add(const APInt& LHS, const APInt& RHS) {
  return LHS + RHS;
}



inline APInt sub(const APInt& LHS, const APInt& RHS) {
  return LHS - RHS;
}




inline APInt And(const APInt& LHS, const APInt& RHS) {
  return LHS & RHS;
}



inline APInt Or(const APInt& LHS, const APInt& RHS) {
  return LHS | RHS;
}



inline APInt Xor(const APInt& LHS, const APInt& RHS) {
  return LHS ^ RHS;
}



inline APInt Not(const APInt& APIVal) {
  return ~APIVal;
}

}

}
# 27 "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APFloat.h" 1
# 106 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APFloat.h"
namespace llvm {


  typedef signed short exponent_t;

  struct fltSemantics;
  class StringRef;




  enum lostFraction {
    lfExactlyZero,
    lfLessThanHalf,
    lfExactlyHalf,
    lfMoreThanHalf
  };

  class APFloat {
  public:


    static const fltSemantics IEEEhalf;
    static const fltSemantics IEEEsingle;
    static const fltSemantics IEEEdouble;
    static const fltSemantics IEEEquad;
    static const fltSemantics PPCDoubleDouble;
    static const fltSemantics x87DoubleExtended;


    static const fltSemantics Bogus;

    static unsigned int semanticsPrecision(const fltSemantics &);


    enum cmpResult {
      cmpLessThan,
      cmpEqual,
      cmpGreaterThan,
      cmpUnordered
    };


    enum roundingMode {
      rmNearestTiesToEven,
      rmTowardPositive,
      rmTowardNegative,
      rmTowardZero,
      rmNearestTiesToAway
    };



    enum opStatus {
      opOK = 0x00,
      opInvalidOp = 0x01,
      opDivByZero = 0x02,
      opOverflow = 0x04,
      opUnderflow = 0x08,
      opInexact = 0x10
    };


    enum fltCategory {
      fcInfinity,
      fcNaN,
      fcNormal,
      fcZero
    };

    enum uninitializedTag {
      uninitialized
    };


    APFloat(const fltSemantics &);
    APFloat(const fltSemantics &, const StringRef &);
    APFloat(const fltSemantics &, integerPart);
    APFloat(const fltSemantics &, fltCategory, bool negative);
    APFloat(const fltSemantics &, uninitializedTag);
    explicit APFloat(double d);
    explicit APFloat(float f);
    explicit APFloat(const APInt &, bool isIEEE = false);
    APFloat(const APFloat &);
    ~APFloat();


    static APFloat getZero(const fltSemantics &Sem, bool Negative = false) {
      return APFloat(Sem, fcZero, Negative);
    }
    static APFloat getInf(const fltSemantics &Sem, bool Negative = false) {
      return APFloat(Sem, fcInfinity, Negative);
    }






    static APFloat getNaN(const fltSemantics &Sem, bool Negative = false,
                          unsigned type = 0) {
      if (type) {
        APInt fill(64, type);
        return getQNaN(Sem, Negative, &fill);
      } else {
        return getQNaN(Sem, Negative, 0);
      }
    }


    static APFloat getQNaN(const fltSemantics &Sem,
                           bool Negative = false,
                           const APInt *payload = 0) {
      return makeNaN(Sem, false, Negative, payload);
    }


    static APFloat getSNaN(const fltSemantics &Sem,
                           bool Negative = false,
                           const APInt *payload = 0) {
      return makeNaN(Sem, true, Negative, payload);
    }





    static APFloat getLargest(const fltSemantics &Sem, bool Negative = false);






    static APFloat getSmallest(const fltSemantics &Sem, bool Negative = false);





    static APFloat getSmallestNormalized(const fltSemantics &Sem,
                                         bool Negative = false);



    void Profile(FoldingSetNodeID& NID) const;


    void Emit(Serializer& S) const;


    static APFloat ReadVal(Deserializer& D);


    opStatus add(const APFloat &, roundingMode);
    opStatus subtract(const APFloat &, roundingMode);
    opStatus multiply(const APFloat &, roundingMode);
    opStatus divide(const APFloat &, roundingMode);

    opStatus remainder(const APFloat &);

    opStatus mod(const APFloat &, roundingMode);
    opStatus fusedMultiplyAdd(const APFloat &, const APFloat &, roundingMode);


    void changeSign();
    void clearSign();
    void copySign(const APFloat &);


    opStatus convert(const fltSemantics &, roundingMode, bool *);
    opStatus convertToInteger(integerPart *, unsigned int, bool,
                              roundingMode, bool *) const;
    opStatus convertFromAPInt(const APInt &,
                              bool, roundingMode);
    opStatus convertFromSignExtendedInteger(const integerPart *, unsigned int,
                                            bool, roundingMode);
    opStatus convertFromZeroExtendedInteger(const integerPart *, unsigned int,
                                            bool, roundingMode);
    opStatus convertFromString(const StringRef&, roundingMode);
    APInt bitcastToAPInt() const;
    double convertToDouble() const;
    float convertToFloat() const;
# 297 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APFloat.h"
    cmpResult compare(const APFloat &) const;


    bool bitwiseIsEqual(const APFloat &) const;





    unsigned int convertToHexString(char *dst, unsigned int hexDigits,
                                    bool upperCase, roundingMode) const;


    fltCategory getCategory() const { return category; }
    const fltSemantics &getSemantics() const { return *semantics; }
    bool isZero() const { return category == fcZero; }
    bool isNonZero() const { return category != fcZero; }
    bool isNaN() const { return category == fcNaN; }
    bool isInfinity() const { return category == fcInfinity; }
    bool isNegative() const { return sign; }
    bool isPosZero() const { return isZero() && !isNegative(); }
    bool isNegZero() const { return isZero() && isNegative(); }

    APFloat& operator=(const APFloat &);


    uint32_t getHashValue() const;
# 345 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/APFloat.h"
    void toString(SmallVectorImpl<char> &Str,
                  unsigned FormatPrecision = 0,
                  unsigned FormatMaxPadding = 3) const;

  private:


    integerPart *significandParts();
    const integerPart *significandParts() const;
    unsigned int partCount() const;


    integerPart addSignificand(const APFloat &);
    integerPart subtractSignificand(const APFloat &, integerPart);
    lostFraction addOrSubtractSignificand(const APFloat &, bool subtract);
    lostFraction multiplySignificand(const APFloat &, const APFloat *);
    lostFraction divideSignificand(const APFloat &);
    void incrementSignificand();
    void initialize(const fltSemantics *);
    void shiftSignificandLeft(unsigned int);
    lostFraction shiftSignificandRight(unsigned int);
    unsigned int significandLSB() const;
    unsigned int significandMSB() const;
    void zeroSignificand();


    opStatus addOrSubtractSpecials(const APFloat &, bool subtract);
    opStatus divideSpecials(const APFloat &);
    opStatus multiplySpecials(const APFloat &);
    opStatus modSpecials(const APFloat &);


    static APFloat makeNaN(const fltSemantics &Sem, bool SNaN, bool Negative,
                           const APInt *fill);
    void makeNaN(bool SNaN = false, bool Neg = false, const APInt *fill = 0);
    opStatus normalize(roundingMode, lostFraction);
    opStatus addOrSubtract(const APFloat &, roundingMode, bool subtract);
    cmpResult compareAbsoluteValue(const APFloat &) const;
    opStatus handleOverflow(roundingMode);
    bool roundAwayFromZero(roundingMode, lostFraction, unsigned int) const;
    opStatus convertToSignExtendedInteger(integerPart *, unsigned int, bool,
                                          roundingMode, bool *) const;
    opStatus convertFromUnsignedParts(const integerPart *, unsigned int,
                                      roundingMode);
    opStatus convertFromHexadecimalString(const StringRef&, roundingMode);
    opStatus convertFromDecimalString (const StringRef&, roundingMode);
    char *convertNormalToHexString(char *, unsigned int, bool,
                                   roundingMode) const;
    opStatus roundSignificandWithExponent(const integerPart *, unsigned int,
                                          int, roundingMode);

    APInt convertHalfAPFloatToAPInt() const;
    APInt convertFloatAPFloatToAPInt() const;
    APInt convertDoubleAPFloatToAPInt() const;
    APInt convertQuadrupleAPFloatToAPInt() const;
    APInt convertF80LongDoubleAPFloatToAPInt() const;
    APInt convertPPCDoubleDoubleAPFloatToAPInt() const;
    void initFromAPInt(const APInt& api, bool isIEEE = false);
    void initFromHalfAPInt(const APInt& api);
    void initFromFloatAPInt(const APInt& api);
    void initFromDoubleAPInt(const APInt& api);
    void initFromQuadrupleAPInt(const APInt &api);
    void initFromF80LongDoubleAPInt(const APInt& api);
    void initFromPPCDoubleDoubleAPInt(const APInt& api);

    void assign(const APFloat &);
    void copySignificand(const APFloat &);
    void freeSignificand();


    const fltSemantics *semantics;



    union Significand
    {
      integerPart part;
      integerPart *parts;
    } significand;


    exponent_t exponent;




    fltCategory category: 3;


    unsigned int sign: 1;





    exponent_t exponent2 : 11;
    unsigned int sign2: 1;
  };
}
# 28 "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h" 1
# 17 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/type_traits.h" 1
# 27 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/type_traits.h"
namespace llvm {

namespace dont_use
{
# 40 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/type_traits.h"
    template<typename T> char is_class_helper(void(T::*)());
    template<typename T> double is_class_helper(...);
}

template <typename T>
struct is_class
{



 public:
    enum { value = sizeof(char) == sizeof(dont_use::is_class_helper<T>(0)) };
};




template <typename T>
struct isPodLike {


  static const bool value = !is_class<T>::value;
};


template<typename T, typename U>
struct isPodLike<std::pair<T, U> > {
  static const bool value = isPodLike<T>::value & isPodLike<U>::value;
};




template<typename T, typename U>
struct is_same {
  static const bool value = false;
};

template<typename T>
struct is_same<T, T> {
  static const bool value = true;
};


template<bool Cond, typename T = void>
struct enable_if_c {
  typedef T type;
};

template<typename T> struct enable_if_c<false, T> { };


template<typename Cond, typename T = void>
struct enable_if : public enable_if_c<Cond::value, T> { };

namespace dont_use {
  template<typename Base> char base_of_helper(const volatile Base*);
  template<typename Base> double base_of_helper(...);
}



template<typename Base, typename Derived>
struct is_base_of {
  static const bool value
    = is_class<Base>::value && is_class<Derived>::value &&
      sizeof(char) == sizeof(dont_use::base_of_helper<Base>((Derived*)0));
};



template <typename T> struct remove_pointer { typedef T type; };
template <typename T> struct remove_pointer<T*> { typedef T type; };
template <typename T> struct remove_pointer<T*const> { typedef T type; };
template <typename T> struct remove_pointer<T*volatile> { typedef T type; };
template <typename T> struct remove_pointer<T*const volatile> {
    typedef T type; };

template <bool, typename T, typename F>
struct conditional { typedef T type; };

template <typename T, typename F>
struct conditional<false, T, F> { typedef F type; };

}
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h" 2
# 1 "/usr/include/c++/4.3/algorithm" 1 3
# 64 "/usr/include/c++/4.3/algorithm" 3
       
# 65 "/usr/include/c++/4.3/algorithm" 3


# 1 "/usr/include/c++/4.3/bits/stl_algo.h" 1 3
# 65 "/usr/include/c++/4.3/bits/stl_algo.h" 3
# 1 "/usr/include/c++/4.3/cstdlib" 1 3
# 46 "/usr/include/c++/4.3/cstdlib" 3
       
# 47 "/usr/include/c++/4.3/cstdlib" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 50 "/usr/include/c++/4.3/cstdlib" 2 3
# 73 "/usr/include/c++/4.3/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 67 "/usr/include/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

# 240 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;





extern __inline __attribute__ ((__gnu_inline__)) double
atof (__const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}
extern __inline __attribute__ ((__gnu_inline__)) int
atoi (__const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
atol (__const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}




__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
atoll (__const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}

# 311 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 327 "/usr/include/stdlib.h" 3 4
extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 498 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));






extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) throw ();






extern int clearenv (void) throw ();
# 583 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 594 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 604 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 614 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 625 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 635 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;









extern int system (__const char *__command) ;






extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 662 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;






extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));



extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

# 727 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) throw () ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) throw () ;


extern int wctomb (char *__s, wchar_t __wchar) throw () ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 815 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 883 "/usr/include/stdlib.h" 3 4
}
# 74 "/usr/include/c++/4.3/cstdlib" 2 3
# 105 "/usr/include/c++/4.3/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }

}
# 162 "/usr/include/c++/4.3/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 195 "/usr/include/c++/4.3/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;

}

namespace std __attribute__ ((__visibility__ ("default"))) {


  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;

}
# 66 "/usr/include/c++/4.3/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/4.3/bits/algorithmfwd.h" 1 3
# 104 "/usr/include/c++/4.3/bits/algorithmfwd.h" 3
       
# 105 "/usr/include/c++/4.3/bits/algorithmfwd.h" 3





namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);




  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);
# 152 "/usr/include/c++/4.3/bits/algorithmfwd.h" 3
  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);







  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);
# 222 "/usr/include/c++/4.3/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);
# 283 "/usr/include/c++/4.3/bits/algorithmfwd.h" 3
  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);




  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  template<typename _FIter>
    void
    rotate(_FIter, _FIter, _FIter);

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 379 "/usr/include/c++/4.3/bits/algorithmfwd.h" 3
  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);

  template<typename _Tp>
    void
    swap(_Tp&, _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);

}

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);
# 478 "/usr/include/c++/4.3/bits/algorithmfwd.h" 3
  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter, _Generator&);

  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);

}
# 67 "/usr/include/c++/4.3/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/4.3/bits/stl_heap.h" 1 3
# 67 "/usr/include/c++/4.3/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _RandomAccessIterator, typename _Distance>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    { return std::__is_heap_until(__first, __n) == __n; }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    { return std::__is_heap_until(__first, __n, __comp) == __n; }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
# 152 "/usr/include/c++/4.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;
      ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
# 201 "/usr/include/c++/4.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value));
    }

  template<typename _RandomAccessIterator>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value));
    }
# 274 "/usr/include/c++/4.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      std::__pop_heap(__first, __last - 1, __last - 1);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value), __comp);
    }
# 347 "/usr/include/c++/4.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;

      std::__pop_heap(__first, __last - 1, __last - 1, __comp);
    }
# 369 "/usr/include/c++/4.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 409 "/usr/include/c++/4.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 448 "/usr/include/c++/4.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      while (__last - __first > 1)
 std::pop_heap(__first, _RandomAccessIterator(__last--));
    }
# 474 "/usr/include/c++/4.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      while (__last - __first > 1)
 std::pop_heap(__first, _RandomAccessIterator(__last--), __comp);
    }
# 568 "/usr/include/c++/4.3/bits/stl_heap.h" 3
}
# 68 "/usr/include/c++/4.3/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/4.3/bits/stl_tempbuf.h" 1 3
# 66 "/usr/include/c++/4.3/bits/stl_tempbuf.h" 3
# 1 "/usr/include/c++/4.3/bits/stl_construct.h" 1 3
# 67 "/usr/include/c++/4.3/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      if (!__has_trivial_destructor(_Value_type))
 for (; __first != __last; ++__first)
   std::_Destroy(&*__first);
    }







  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }

}
# 67 "/usr/include/c++/4.3/bits/stl_tempbuf.h" 2 3
# 1 "/usr/include/c++/4.3/bits/stl_uninitialized.h" 1 3
# 65 "/usr/include/c++/4.3/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<bool>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   if (true)
     {
       for (; __first != __last; ++__first, ++__cur)
  ::new(static_cast<void*>(&*__cur)) typename
      iterator_traits<_ForwardIterator>::value_type(*__first);
       return __cur;
     }
   if (false)
     {
       std::_Destroy(__result, __cur);
       ;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 110 "/usr/include/c++/4.3/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_pod(_ValueType1)
     && __is_pod(_ValueType2))>::
 uninitialized_copy(__first, __last, __result);
    }


  template<bool>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(&*__cur, __x);
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
       ;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 167 "/usr/include/c++/4.3/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_pod(_ValueType)>::
 uninitialized_fill(__first, __last, __x);
    }


  template<bool>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(&*__cur, __x);
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
       ;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 221 "/usr/include/c++/4.3/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_pod(_ValueType)>::
 uninitialized_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      if (true)
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__result, __cur, __alloc);
   ;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a((__first),
      (__last),
      __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
   ;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
   ;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 335 "/usr/include/c++/4.3/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      if (true)
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
   ;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      if (true)
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
   ;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      if (true)
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
   ;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      if (true)
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      if (false)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   ;
 }
    }

}
# 68 "/usr/include/c++/4.3/bits/stl_tempbuf.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 88 "/usr/include/c++/4.3/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 115 "/usr/include/c++/4.3/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      if (true)
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (!__is_pod(_Tp) && _M_len > 0)
     std::uninitialized_fill_n(_M_buffer, _M_len, *__first);
 }
      if (false)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   ;
 }
    }

}
# 69 "/usr/include/c++/4.3/bits/stl_algo.h" 2 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 87 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _Tp>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {

     
      if (__a < __b)
 if (__b < __c)
   return __b;
 else if (__a < __c)
   return __c;
 else
   return __a;
      else if (__a < __c)
 return __a;
      else if (__b < __c)
 return __c;
      else
 return __b;
    }
# 121 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {

     

      if (__comp(__a, __b))
 if (__comp(__b, __c))
   return __b;
 else if (__comp(__a, __c))
   return __c;
 else
   return __a;
      else if (__comp(__a, __c))
 return __a;
      else if (__comp(__b, __c))
 return __c;
      else
 return __b;
    }




  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
# 281 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }






  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!(*__lookAhead == __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
# 366 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !bool(__binary_pred(*__first, __val)))
        ++__first;

      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last
   && !bool(__binary_pred(*__first, __val)))
     ++__first;
 }
      return __last;
    }







  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!bool(__binary_pred(*__lookAhead, __val)))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2,
      __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1),
             __rlast1,
             _RevIterator2(__last2),
             __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 603 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 648 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }
# 684 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 720 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (!bool(__pred(*__first)))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 759 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      __first = std::find(__first, __last, __value);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!(*__first == __value))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
# 801 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      __first = std::find_if(__first, __last, __pred);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!bool(__pred(*__first)))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
# 840 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = (*__first);
      return ++__dest;
    }
# 879 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {

     

     


      ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__dest, *__first)))
   *++__dest = (*__first);
      return ++__dest;
    }






  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {

     



      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!bool(__binary_pred(*__first, *__next)))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!bool(__binary_pred(__value, *__first)))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {

     



      *__result = *__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__result, *__first)))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1106 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1132 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
        _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }


  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }


  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }


  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      const _Distance __n = __last - __first;
      const _Distance __k = __middle - __first;
      const _Distance __l = __n - __k;

      if (__k == __l)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      const _Distance __d = std::__gcd(__n, __k);

      for (_Distance __i = 0; __i < __d; __i++)
 {
   _ValueType __tmp = (*__first);
   _RandomAccessIterator __p = __first;

   if (__k < __l)
     {
       for (_Distance __j = 0; __j < __l / __d; __j++)
  {
    if (__p > __first + __l)
      {
        *__p = (*(__p - __l));
        __p -= __l;
      }

    *__p = (*(__p + __k));
    __p += __k;
  }
     }
   else
     {
       for (_Distance __j = 0; __j < __k / __d - 1; __j ++)
  {
    if (__p < __last - __k)
      {
        *__p = (*(__p + __k));
        __p += __k;
      }
    *__p = (*(__p - __l));
    __p -= __l;
  }
     }

   *__p = (__tmp);
   ++__first;
 }
    }
# 1324 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1357 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }




  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }


  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for (; __first != __last; ++__first)
     if (__pred(*__first))
       {
  *__result1 = *__first;
  ++__result1;
       }
     else
       {
  *__result2 = *__first;
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
# 1514 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(),
       _DistanceType(__buf.size()));
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }


  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }
# 1595 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     

     
      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 1660 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     

     

     

      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val,
         _Compare __comp)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }


  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__val < *__first)
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val);
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__comp(__val, *__first))
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val, __comp);
 }
    }


  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Tp __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _Tp __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }


  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }



  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);


       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2069 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2119 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

      ;


      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2167 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2217 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

      ;


      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2271 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
     
      ;
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2333 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

     

      ;

      ;


      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2394 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;


     
     
      ;
      ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 2427 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;


     
     

      ;

      ;


      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last,
    __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer,
    __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last,
    __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer, __buffer_end,
    __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }
# 2774 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     
      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 2828 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     

      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
        __first + __step_size,
        __first + __two_step,
        __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(__first, __first + __step_size,
       __first + __step_size, __last,
       __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result,
    __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::merge(__first, __first + __step_size,
       __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 3113 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3161 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3215 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3271 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*__i, *--__j)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3326 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3382 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*--__j, *__i)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3442 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3478 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3768 "/usr/include/c++/4.3/bits/stl_algo.h" 3
}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 3783 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
# 3803 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
# 3826 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
# 3854 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 3892 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 3923 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 3954 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 3985 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 4009 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 4048 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4118 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4191 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

      ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
# 4226 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !bool(__binary_pred(*__first, __val)))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
# 4267 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for (; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4302 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4334 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4365 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4396 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4423 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for (; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
# 4458 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4496 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4527 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 4554 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator& __rand)
    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }
# 4585 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 4618 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
# 4656 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 4693 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
# 4731 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
# 4768 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 4803 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 4843 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4905 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4964 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     
      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
# 5005 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     


      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5050 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5116 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5182 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5238 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5295 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5355 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5412 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 5477 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5533 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 5560 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }







  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 5614 "/usr/include/c++/4.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first))
   __result = __first;
      return __result;
    }

}
# 68 "/usr/include/c++/4.3/algorithm" 2 3
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h" 2
# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h" 2
# 1 "/usr/include/c++/4.3/cstring" 1 3
# 45 "/usr/include/c++/4.3/cstring" 3
       
# 46 "/usr/include/c++/4.3/cstring" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 49 "/usr/include/c++/4.3/cstring" 2 3
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h" 2
# 1 "/usr/include/c++/4.3/memory" 1 3
# 52 "/usr/include/c++/4.3/memory" 3
       
# 53 "/usr/include/c++/4.3/memory" 3






# 1 "/usr/include/c++/4.3/bits/stl_raw_storage_iter.h" 1 3
# 65 "/usr/include/c++/4.3/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(&*_M_iter, __element);
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_OutputIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };

}
# 60 "/usr/include/c++/4.3/memory" 2 3
# 95 "/usr/include/c++/4.3/memory" 3
# 1 "/usr/include/c++/4.3/backward/auto_ptr.h" 1 3
# 41 "/usr/include/c++/4.3/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 50 "/usr/include/c++/4.3/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } ;
# 89 "/usr/include/c++/4.3/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 115 "/usr/include/c++/4.3/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 127 "/usr/include/c++/4.3/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 138 "/usr/include/c++/4.3/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 155 "/usr/include/c++/4.3/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 173 "/usr/include/c++/4.3/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 183 "/usr/include/c++/4.3/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
# 213 "/usr/include/c++/4.3/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 227 "/usr/include/c++/4.3/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 242 "/usr/include/c++/4.3/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 263 "/usr/include/c++/4.3/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } ;



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } ;

}
# 96 "/usr/include/c++/4.3/memory" 2 3
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h" 2
# 47 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h"
namespace llvm {



class SmallVectorBase {
protected:
  void *BeginX, *EndX, *CapacityX;







  typedef char U;
  U FirstEl __attribute__((aligned));
# 73 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h"
protected:
  SmallVectorBase(size_t Size)
    : BeginX(&FirstEl), EndX(&FirstEl), CapacityX((char*)&FirstEl+Size) {}



  bool isSmall() const {
    return BeginX == static_cast<const void*>(&FirstEl);
  }


  size_t size_in_bytes() const {
    return size_t((char*)EndX - (char*)BeginX);
  }


  size_t capacity_in_bytes() const {
    return size_t((char*)CapacityX - (char*)BeginX);
  }



  void grow_pod(size_t MinSizeInBytes, size_t TSize);

public:
  bool empty() const { return BeginX == EndX; }
};


template <typename T>
class SmallVectorTemplateCommon : public SmallVectorBase {
protected:
  void setEnd(T *P) { this->EndX = P; }
public:
  SmallVectorTemplateCommon(size_t Size) : SmallVectorBase(Size) {}

  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef T value_type;
  typedef T *iterator;
  typedef const T *const_iterator;

  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;

  typedef T &reference;
  typedef const T &const_reference;
  typedef T *pointer;
  typedef const T *const_pointer;


  iterator begin() { return (iterator)this->BeginX; }
  const_iterator begin() const { return (const_iterator)this->BeginX; }
  iterator end() { return (iterator)this->EndX; }
  const_iterator end() const { return (const_iterator)this->EndX; }
protected:
  iterator capacity_ptr() { return (iterator)this->CapacityX; }
  const_iterator capacity_ptr() const { return (const_iterator)this->CapacityX;}
public:


  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const { return const_reverse_iterator(begin());}

  size_type size() const { return end()-begin(); }
  size_type max_size() const { return size_type(-1) / sizeof(T); }



  size_t capacity() const { return capacity_ptr() - begin(); }


  pointer data() { return pointer(begin()); }

  const_pointer data() const { return const_pointer(begin()); }

  reference operator[](unsigned idx) {
    ((begin() + idx < end()) ? static_cast<void> (0) : __assert_fail ("begin() + idx < end()", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h", 152, __PRETTY_FUNCTION__));
    return begin()[idx];
  }
  const_reference operator[](unsigned idx) const {
    ((begin() + idx < end()) ? static_cast<void> (0) : __assert_fail ("begin() + idx < end()", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h", 156, __PRETTY_FUNCTION__));
    return begin()[idx];
  }

  reference front() {
    return begin()[0];
  }
  const_reference front() const {
    return begin()[0];
  }

  reference back() {
    return end()[-1];
  }
  const_reference back() const {
    return end()[-1];
  }
};



template <typename T, bool isPodLike>
class SmallVectorTemplateBase : public SmallVectorTemplateCommon<T> {
public:
  SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}

  static void destroy_range(T *S, T *E) {
    while (S != E) {
      --E;
      E->~T();
    }
  }



  template<typename It1, typename It2>
  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {
    std::uninitialized_copy(I, E, Dest);
  }



  void grow(size_t MinSize = 0);
};


template <typename T, bool isPodLike>
void SmallVectorTemplateBase<T, isPodLike>::grow(size_t MinSize) {
  size_t CurCapacity = this->capacity();
  size_t CurSize = this->size();
  size_t NewCapacity = 2*CurCapacity;
  if (NewCapacity < MinSize)
    NewCapacity = MinSize;
  T *NewElts = static_cast<T*>(operator new(NewCapacity*sizeof(T)));


  this->uninitialized_copy(this->begin(), this->end(), NewElts);


  destroy_range(this->begin(), this->end());


  if (!this->isSmall())
    operator delete(this->begin());

  this->setEnd(NewElts+CurSize);
  this->BeginX = NewElts;
  this->CapacityX = this->begin()+NewCapacity;
}




template <typename T>
class SmallVectorTemplateBase<T, true> : public SmallVectorTemplateCommon<T> {
public:
  SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}


  static void destroy_range(T *, T *) {}



  template<typename It1, typename It2>
  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {


    memcpy(&*Dest, &*I, (E-I)*sizeof(T));
  }



  void grow(size_t MinSize = 0) {
    this->grow_pod(MinSize*sizeof(T), sizeof(T));
  }
};





template <typename T>
class SmallVectorImpl : public SmallVectorTemplateBase<T, isPodLike<T>::value> {
  typedef SmallVectorTemplateBase<T, isPodLike<T>::value > SuperClass;
public:
  typedef typename SuperClass::iterator iterator;
  typedef typename SuperClass::size_type size_type;


  explicit SmallVectorImpl(unsigned N)
    : SmallVectorTemplateBase<T, isPodLike<T>::value>(N*sizeof(T)) {
  }

  ~SmallVectorImpl() {

    this->destroy_range(this->begin(), this->end());


    if (!this->isSmall())
      operator delete(this->begin());
  }


  void clear() {
    this->destroy_range(this->begin(), this->end());
    this->EndX = this->BeginX;
  }

  void resize(unsigned N) {
    if (N < this->size()) {
      this->destroy_range(this->begin()+N, this->end());
      this->setEnd(this->begin()+N);
    } else if (N > this->size()) {
      if (this->capacity() < N)
        this->grow(N);
      this->construct_range(this->end(), this->begin()+N, T());
      this->setEnd(this->begin()+N);
    }
  }

  void resize(unsigned N, const T &NV) {
    if (N < this->size()) {
      this->destroy_range(this->begin()+N, this->end());
      this->setEnd(this->begin()+N);
    } else if (N > this->size()) {
      if (this->capacity() < N)
        this->grow(N);
      construct_range(this->end(), this->begin()+N, NV);
      this->setEnd(this->begin()+N);
    }
  }

  void reserve(unsigned N) {
    if (this->capacity() < N)
      this->grow(N);
  }

  void push_back(const T &Elt) {
    if (this->EndX < this->CapacityX) {
    Retry:
      new (this->end()) T(Elt);
      this->setEnd(this->end()+1);
      return;
    }
    this->grow();
    goto Retry;
  }

  void pop_back() {
    this->setEnd(this->end()-1);
    this->end()->~T();
  }

  T pop_back_val() {
    T Result = this->back();
    pop_back();
    return Result;
  }


  void swap(SmallVectorImpl &RHS);



  template<typename in_iter>
  void append(in_iter in_start, in_iter in_end) {
    size_type NumInputs = std::distance(in_start, in_end);

    if (NumInputs > size_type(this->capacity_ptr()-this->end()))
      this->grow(this->size()+NumInputs);




    std::uninitialized_copy(in_start, in_end, this->end());
    this->setEnd(this->end() + NumInputs);
  }



  void append(size_type NumInputs, const T &Elt) {

    if (NumInputs > size_type(this->capacity_ptr()-this->end()))
      this->grow(this->size()+NumInputs);


    std::uninitialized_fill_n(this->end(), NumInputs, Elt);
    this->setEnd(this->end() + NumInputs);
  }

  void assign(unsigned NumElts, const T &Elt) {
    clear();
    if (this->capacity() < NumElts)
      this->grow(NumElts);
    this->setEnd(this->begin()+NumElts);
    construct_range(this->begin(), this->end(), Elt);
  }

  iterator erase(iterator I) {
    iterator N = I;

    std::copy(I+1, this->end(), I);

    pop_back();
    return(N);
  }

  iterator erase(iterator S, iterator E) {
    iterator N = S;

    iterator I = std::copy(E, this->end(), S);

    this->destroy_range(I, this->end());
    this->setEnd(I);
    return(N);
  }

  iterator insert(iterator I, const T &Elt) {
    if (I == this->end()) {
      push_back(Elt);
      return this->end()-1;
    }

    if (this->EndX < this->CapacityX) {
    Retry:
      new (this->end()) T(this->back());
      this->setEnd(this->end()+1);

      std::copy_backward(I, this->end()-1, this->end());
      *I = Elt;
      return I;
    }
    size_t EltNo = I-this->begin();
    this->grow();
    I = this->begin()+EltNo;
    goto Retry;
  }

  iterator insert(iterator I, size_type NumToInsert, const T &Elt) {
    if (I == this->end()) {
      append(NumToInsert, Elt);
      return this->end()-1;
    }


    size_t InsertElt = I - this->begin();


    reserve(static_cast<unsigned>(this->size() + NumToInsert));


    I = this->begin()+InsertElt;





    if (size_t(this->end()-I) >= NumToInsert) {
      T *OldEnd = this->end();
      append(this->end()-NumToInsert, this->end());


      std::copy_backward(I, OldEnd-NumToInsert, OldEnd);

      std::fill_n(I, NumToInsert, Elt);
      return I;
    }





    T *OldEnd = this->end();
    this->setEnd(this->end() + NumToInsert);
    size_t NumOverwritten = OldEnd-I;
    this->uninitialized_copy(I, OldEnd, this->end()-NumOverwritten);


    std::fill_n(I, NumOverwritten, Elt);


    std::uninitialized_fill_n(OldEnd, NumToInsert-NumOverwritten, Elt);
    return I;
  }

  template<typename ItTy>
  iterator insert(iterator I, ItTy From, ItTy To) {
    if (I == this->end()) {
      append(From, To);
      return this->end()-1;
    }

    size_t NumToInsert = std::distance(From, To);

    size_t InsertElt = I - this->begin();


    reserve(static_cast<unsigned>(this->size() + NumToInsert));


    I = this->begin()+InsertElt;





    if (size_t(this->end()-I) >= NumToInsert) {
      T *OldEnd = this->end();
      append(this->end()-NumToInsert, this->end());


      std::copy_backward(I, OldEnd-NumToInsert, OldEnd);

      std::copy(From, To, I);
      return I;
    }





    T *OldEnd = this->end();
    this->setEnd(this->end() + NumToInsert);
    size_t NumOverwritten = OldEnd-I;
    this->uninitialized_copy(I, OldEnd, this->end()-NumOverwritten);


    std::copy(From, From+NumOverwritten, I);


    this->uninitialized_copy(From+NumOverwritten, To, OldEnd);
    return I;
  }

  const SmallVectorImpl
  &operator=(const SmallVectorImpl &RHS);

  bool operator==(const SmallVectorImpl &RHS) const {
    if (this->size() != RHS.size()) return false;
    return std::equal(this->begin(), this->end(), RHS.begin());
  }
  bool operator!=(const SmallVectorImpl &RHS) const {
    return !(*this == RHS);
  }

  bool operator<(const SmallVectorImpl &RHS) const {
    return std::lexicographical_compare(this->begin(), this->end(),
                                        RHS.begin(), RHS.end());
  }
# 535 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h"
  void set_size(unsigned N) {
    ((N <= this->capacity()) ? static_cast<void> (0) : __assert_fail ("N <= this->capacity()", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h", 536, __PRETTY_FUNCTION__));
    this->setEnd(this->begin() + N);
  }

private:
  static void construct_range(T *S, T *E, const T &Elt) {
    for (; S != E; ++S)
      new (S) T(Elt);
  }
};


template <typename T>
void SmallVectorImpl<T>::swap(SmallVectorImpl<T> &RHS) {
  if (this == &RHS) return;


  if (!this->isSmall() && !RHS.isSmall()) {
    std::swap(this->BeginX, RHS.BeginX);
    std::swap(this->EndX, RHS.EndX);
    std::swap(this->CapacityX, RHS.CapacityX);
    return;
  }
  if (RHS.size() > this->capacity())
    this->grow(RHS.size());
  if (this->size() > RHS.capacity())
    RHS.grow(this->size());


  size_t NumShared = this->size();
  if (NumShared > RHS.size()) NumShared = RHS.size();
  for (unsigned i = 0; i != static_cast<unsigned>(NumShared); ++i)
    std::swap((*this)[i], RHS[i]);


  if (this->size() > RHS.size()) {
    size_t EltDiff = this->size() - RHS.size();
    this->uninitialized_copy(this->begin()+NumShared, this->end(), RHS.end());
    RHS.setEnd(RHS.end()+EltDiff);
    this->destroy_range(this->begin()+NumShared, this->end());
    this->setEnd(this->begin()+NumShared);
  } else if (RHS.size() > this->size()) {
    size_t EltDiff = RHS.size() - this->size();
    this->uninitialized_copy(RHS.begin()+NumShared, RHS.end(), this->end());
    this->setEnd(this->end() + EltDiff);
    this->destroy_range(RHS.begin()+NumShared, RHS.end());
    RHS.setEnd(RHS.begin()+NumShared);
  }
}

template <typename T>
const SmallVectorImpl<T> &SmallVectorImpl<T>::
  operator=(const SmallVectorImpl<T> &RHS) {

  if (this == &RHS) return *this;



  size_t RHSSize = RHS.size();
  size_t CurSize = this->size();
  if (CurSize >= RHSSize) {

    iterator NewEnd;
    if (RHSSize)
      NewEnd = std::copy(RHS.begin(), RHS.begin()+RHSSize, this->begin());
    else
      NewEnd = this->begin();


    this->destroy_range(NewEnd, this->end());


    this->setEnd(NewEnd);
    return *this;
  }



  if (this->capacity() < RHSSize) {

    this->destroy_range(this->begin(), this->end());
    this->setEnd(this->begin());
    CurSize = 0;
    this->grow(RHSSize);
  } else if (CurSize) {

    std::copy(RHS.begin(), RHS.begin()+CurSize, this->begin());
  }


  this->uninitialized_copy(RHS.begin()+CurSize, RHS.end(),
                           this->begin()+CurSize);


  this->setEnd(this->begin()+RHSSize);
  return *this;
}
# 643 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallVector.h"
template <typename T, unsigned N>
class SmallVector : public SmallVectorImpl<T> {


  typedef typename SmallVectorImpl<T>::U U;
  enum {

    MinUs = (static_cast<unsigned int>(sizeof(T))*N +
             static_cast<unsigned int>(sizeof(U)) - 1) /
            static_cast<unsigned int>(sizeof(U)),




    NumInlineEltsElts = MinUs > 1 ? (MinUs - 1) : 1,



    NumTsAvailable = (NumInlineEltsElts+1)*static_cast<unsigned int>(sizeof(U))/
                     static_cast<unsigned int>(sizeof(T))
  };
  U InlineElts[NumInlineEltsElts];
public:
  SmallVector() : SmallVectorImpl<T>(NumTsAvailable) {
  }

  explicit SmallVector(unsigned Size, const T &Value = T())
    : SmallVectorImpl<T>(NumTsAvailable) {
    this->reserve(Size);
    while (Size--)
      this->push_back(Value);
  }

  template<typename ItTy>
  SmallVector(ItTy S, ItTy E) : SmallVectorImpl<T>(NumTsAvailable) {
    this->append(S, E);
  }

  SmallVector(const SmallVector &RHS) : SmallVectorImpl<T>(NumTsAvailable) {
    if (!RHS.empty())
      SmallVectorImpl<T>::operator=(RHS);
  }

  const SmallVector &operator=(const SmallVector &RHS) {
    SmallVectorImpl<T>::operator=(RHS);
    return *this;
  }

};

}

namespace std {

  template<typename T>
  inline void
  swap(llvm::SmallVectorImpl<T> &LHS, llvm::SmallVectorImpl<T> &RHS) {
    LHS.swap(RHS);
  }


  template<typename T, unsigned N>
  inline void
  swap(llvm::SmallVector<T, N> &LHS, llvm::SmallVector<T, N> &RHS) {
    LHS.swap(RHS);
  }
}
# 29 "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h" 2
# 1 "/usr/include/c++/4.3/vector" 1 3
# 64 "/usr/include/c++/4.3/vector" 3
       
# 65 "/usr/include/c++/4.3/vector" 3





# 1 "/usr/include/c++/4.3/bits/stl_vector.h" 1 3
# 69 "/usr/include/c++/4.3/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 _Tp* _M_start;
 _Tp* _M_finish;
 _Tp* _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
# 135 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      _Tp*
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(_Tp* __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
# 174 "/usr/include/c++/4.3/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef vector<_Tp, _Alloc> vector_type;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
# 232 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 247 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x._M_get_Tp_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 283 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 311 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 342 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 358 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
# 483 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 503 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
 else
   insert(end(), __new_size - size(), __x);
      }





      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
# 546 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 561 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 576 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 601 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 619 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 665 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      pointer
      data()
      { return pointer(this->_M_impl._M_start); }

      const_pointer
      data() const
      { return const_pointer(this->_M_impl._M_start); }
# 685 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
# 721 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
# 757 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 790 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 808 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 833 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 854 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 866 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      void



      swap(vector& __x)

      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   if (true)
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   if (false)
     {
       _M_deallocate(__result, __n);
       ;
     }
 }
# 925 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
# 989 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1029 "/usr/include/c++/4.3/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_insert_aux(iterator __position, const value_type& __x);







      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
    };
# 1107 "/usr/include/c++/4.3/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1124 "/usr/include/c++/4.3/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
# 1172 "/usr/include/c++/4.3/bits/stl_vector.h" 3
}
# 71 "/usr/include/c++/4.3/vector" 2 3
# 1 "/usr/include/c++/4.3/bits/stl_bvector.h" 1 3
# 65 "/usr/include/c++/4.3/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }
# 432 "/usr/include/c++/4.3/bits/stl_bvector.h" 3
      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };

}




namespace std __attribute__ ((__visibility__ ("default"))) {
# 477 "/usr/include/c++/4.3/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;

  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }

    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }






    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }
# 575 "/usr/include/c++/4.3/bits/stl_bvector.h" 3
    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }

    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }
# 637 "/usr/include/c++/4.3/bits/stl_bvector.h" 3
    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n);

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void



    swap(vector& __x)

    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }

    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }

    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }





    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };

}
# 72 "/usr/include/c++/4.3/vector" 2 3


# 1 "/usr/include/c++/4.3/bits/vector.tcc" 1 3
# 65 "/usr/include/c++/4.3/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
   (this->_M_impl._M_start),
   (this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {
# 113 "/usr/include/c++/4.3/bits/vector.tcc" 3
     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__last != end())
 std::copy(__last, end(), __first);
      _M_erase_at_end(__first.base() + (end() - __last));
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }
# 280 "/usr/include/c++/4.3/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)

    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      (*(this->_M_impl._M_finish - 1)));

   ++this->_M_impl._M_finish;

   _Tp __x_copy = __x;

   std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);



   *__position = __x_copy;



 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   if (true)
     {




       __new_finish =
  std::__uninitialized_move_a(this->_M_impl._M_start,
         __position.base(), __new_start,
         _M_get_Tp_allocator());

       this->_M_impl.construct(__new_finish, __x);

       ++__new_finish;
       __new_finish =
  std::__uninitialized_move_a(__position.base(),
         this->_M_impl._M_finish,
         __new_finish,
         _M_get_Tp_allocator());
     }
   if (false)
     {
       std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       ;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {



   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {

       value_type __x_copy = __x;

       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n, __old_finish);

    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       if (true)
  {
    __new_finish =
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __position.base(),
      __new_start,
      _M_get_Tp_allocator());



    std::__uninitialized_fill_n_a(__new_finish, __n, __x,

      _M_get_Tp_allocator());
    __new_finish += __n;
    __new_finish =
      std::__uninitialized_move_a(__position.base(),
      this->_M_impl._M_finish,
      __new_finish,
      _M_get_Tp_allocator());
  }
       if (false)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    ;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n, __old_finish);

      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  if (true)
    {
      __new_finish =
        std::__uninitialized_move_a(this->_M_impl._M_start,
        __position.base(),
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last,
        __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_move_a(__position.base(),
        this->_M_impl._M_finish,
        __new_finish,
        _M_get_Tp_allocator());
    }
  if (false)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      ;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }




  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
          iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

}
# 75 "/usr/include/c++/4.3/vector" 2 3
# 30 "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h" 2

namespace llvm {

class ArrayType;
class IntegerType;
class StructType;
class UnionType;
class PointerType;
class VectorType;

template<class ConstantClass, class TypeClass, class ValType>
struct ConstantCreator;
template<class ConstantClass, class TypeClass>
struct ConvertConstantType;





class ConstantInt : public Constant {
  void *operator new(size_t, unsigned);
  ConstantInt(const ConstantInt &);
  ConstantInt(const IntegerType *Ty, const APInt& V);
  APInt Val;
protected:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
public:
  static ConstantInt *getTrue(LLVMContext &Context);
  static ConstantInt *getFalse(LLVMContext &Context);



  static Constant *get(const Type *Ty, uint64_t V, bool isSigned = false);







  static ConstantInt *get(const IntegerType *Ty, uint64_t V,
                          bool isSigned = false);






  static ConstantInt *getSigned(const IntegerType *Ty, int64_t V);
  static Constant *getSigned(const Type *Ty, int64_t V);



  static ConstantInt *get(LLVMContext &Context, const APInt &V);



  static ConstantInt *get(const IntegerType *Ty, StringRef Str,
                          uint8_t radix);



  static Constant *get(const Type* Ty, const APInt& V);




  inline const APInt &getValue() const {
    return Val;
  }


  unsigned getBitWidth() const { return Val.getBitWidth(); }






  inline uint64_t getZExtValue() const {
    return Val.getZExtValue();
  }






  inline int64_t getSExtValue() const {
    return Val.getSExtValue();
  }





  bool equalsInt(uint64_t V) const {
    return Val == V;
  }




  inline const IntegerType *getType() const {
    return reinterpret_cast<const IntegerType*>(Value::getType());
  }
# 149 "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h"
  static bool isValueValidForType(const Type *Ty, uint64_t V);
  static bool isValueValidForType(const Type *Ty, int64_t V);





  virtual bool isNullValue() const {
    return Val == 0;
  }




  bool isZero() const {
    return Val == 0;
  }





  bool isOne() const {
    return Val == 1;
  }





  bool isAllOnesValue() const {
    return Val.isAllOnesValue();
  }






  bool isMaxValue(bool isSigned) const {
    if (isSigned)
      return Val.isMaxSignedValue();
    else
      return Val.isMaxValue();
  }






  bool isMinValue(bool isSigned) const {
    if (isSigned)
      return Val.isMinSignedValue();
    else
      return Val.isMinValue();
  }






  bool uge(uint64_t Num) {
    return Val.getActiveBits() > 64 || Val.getZExtValue() >= Num;
  }






  uint64_t getLimitedValue(uint64_t Limit = ~0ULL) const {
    return Val.getLimitedValue(Limit);
  }


  static inline bool classof(const ConstantInt *) { return true; }
  static bool classof(const Value *V) {
    return V->getValueID() == ConstantIntVal;
  }
};





class ConstantFP : public Constant {
  APFloat Val;
  void *operator new(size_t, unsigned);
  ConstantFP(const ConstantFP &);
  friend class LLVMContextImpl;
protected:
  ConstantFP(const Type *Ty, const APFloat& V);
protected:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
public:



  static Constant *getZeroValueForNegation(const Type *Ty);





  static Constant *get(const Type* Ty, double V);
  static Constant *get(const Type* Ty, StringRef Str);
  static ConstantFP *get(LLVMContext &Context, const APFloat &V);
  static ConstantFP *getNegativeZero(const Type* Ty);
  static ConstantFP *getInfinity(const Type *Ty, bool Negative = false);


  static bool isValueValidForType(const Type *Ty, const APFloat &V);
  inline const APFloat& getValueAPF() const { return Val; }




  virtual bool isNullValue() const;



  virtual bool isNegativeZeroValue() const {
    return Val.isZero() && Val.isNegative();
  }


  bool isZero() const { return Val.isZero(); }


  bool isNaN() const { return Val.isNaN(); }







  bool isExactlyValue(const APFloat &V) const;

  bool isExactlyValue(double V) const {
    bool ignored;

    if (&Val.getSemantics() == &APFloat::PPCDoubleDouble)
      return false;
    APFloat FV(V);
    FV.convert(Val.getSemantics(), APFloat::rmNearestTiesToEven, &ignored);
    return isExactlyValue(FV);
  }

  static inline bool classof(const ConstantFP *) { return true; }
  static bool classof(const Value *V) {
    return V->getValueID() == ConstantFPVal;
  }
};




class ConstantAggregateZero : public Constant {
  friend struct ConstantCreator<ConstantAggregateZero, Type, char>;
  void *operator new(size_t, unsigned);
  ConstantAggregateZero(const ConstantAggregateZero &);
protected:
  explicit ConstantAggregateZero(const Type *ty)
    : Constant(ty, ConstantAggregateZeroVal, 0, 0) {}
protected:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
public:
  static ConstantAggregateZero* get(const Type *Ty);



  virtual bool isNullValue() const { return true; }

  virtual void destroyConstant();



  static bool classof(const ConstantAggregateZero *) { return true; }
  static bool classof(const Value *V) {
    return V->getValueID() == ConstantAggregateZeroVal;
  }
};





class ConstantArray : public Constant {
  friend struct ConstantCreator<ConstantArray, ArrayType,
                                    std::vector<Constant*> >;
  ConstantArray(const ConstantArray &);
protected:
  ConstantArray(const ArrayType *T, const std::vector<Constant*> &Val);
public:

  static Constant *get(const ArrayType *T, const std::vector<Constant*> &V);
  static Constant *get(const ArrayType *T, Constant *const *Vals,
                       unsigned NumVals);







  static Constant *get(LLVMContext &Context, StringRef Initializer,
                       bool AddNull = true);


  public: inline Constant *getOperand(unsigned) const; inline void setOperand(unsigned, Constant*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;




  inline const ArrayType *getType() const {
    return reinterpret_cast<const ArrayType*>(Value::getType());
  }



  bool isString() const;






  bool isCString() const;




  std::string getAsString() const;




  virtual bool isNullValue() const { return false; }

  virtual void destroyConstant();
  virtual void replaceUsesOfWithOnConstant(Value *From, Value *To, Use *U);


  static inline bool classof(const ConstantArray *) { return true; }
  static bool classof(const Value *V) {
    return V->getValueID() == ConstantArrayVal;
  }
};

template <>
struct OperandTraits<ConstantArray> : public VariadicOperandTraits<> {
};

ConstantArray::op_iterator ConstantArray::op_begin() { return OperandTraits<ConstantArray>::op_begin(this); } ConstantArray::const_op_iterator ConstantArray::op_begin() const { return OperandTraits<ConstantArray>::op_begin(const_cast<ConstantArray*>(this)); } ConstantArray::op_iterator ConstantArray::op_end() { return OperandTraits<ConstantArray>::op_end(this); } ConstantArray::const_op_iterator ConstantArray::op_end() const { return OperandTraits<ConstantArray>::op_end(const_cast<ConstantArray*>(this)); } Constant *ConstantArray::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<ConstantArray>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ConstantArray>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h", 411, __PRETTY_FUNCTION__)); return cast<Constant>( OperandTraits<ConstantArray>::op_begin(const_cast<ConstantArray*>(this))[i_nocapture]); } void ConstantArray::setOperand(unsigned i_nocapture, Constant *Val_nocapture) { ((i_nocapture < OperandTraits<ConstantArray>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ConstantArray>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h", 411, __PRETTY_FUNCTION__)); OperandTraits<ConstantArray>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ConstantArray::getNumOperands() const { return OperandTraits<ConstantArray>::operands(this); } template <int Idx_nocapture> Use &ConstantArray::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ConstantArray::Op() const { return this->OpFrom<Idx_nocapture>(this); }




class ConstantStruct : public Constant {
  friend struct ConstantCreator<ConstantStruct, StructType,
                                    std::vector<Constant*> >;
  ConstantStruct(const ConstantStruct &);
protected:
  ConstantStruct(const StructType *T, const std::vector<Constant*> &Val);
public:

  static Constant *get(const StructType *T, const std::vector<Constant*> &V);
  static Constant *get(LLVMContext &Context,
                       const std::vector<Constant*> &V, bool Packed);
  static Constant *get(LLVMContext &Context,
                       Constant *const *Vals, unsigned NumVals, bool Packed);


  public: inline Constant *getOperand(unsigned) const; inline void setOperand(unsigned, Constant*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;



  inline const StructType *getType() const {
    return reinterpret_cast<const StructType*>(Value::getType());
  }




  virtual bool isNullValue() const {
    return false;
  }

  virtual void destroyConstant();
  virtual void replaceUsesOfWithOnConstant(Value *From, Value *To, Use *U);


  static inline bool classof(const ConstantStruct *) { return true; }
  static bool classof(const Value *V) {
    return V->getValueID() == ConstantStructVal;
  }
};

template <>
struct OperandTraits<ConstantStruct> : public VariadicOperandTraits<> {
};

ConstantStruct::op_iterator ConstantStruct::op_begin() { return OperandTraits<ConstantStruct>::op_begin(this); } ConstantStruct::const_op_iterator ConstantStruct::op_begin() const { return OperandTraits<ConstantStruct>::op_begin(const_cast<ConstantStruct*>(this)); } ConstantStruct::op_iterator ConstantStruct::op_end() { return OperandTraits<ConstantStruct>::op_end(this); } ConstantStruct::const_op_iterator ConstantStruct::op_end() const { return OperandTraits<ConstantStruct>::op_end(const_cast<ConstantStruct*>(this)); } Constant *ConstantStruct::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<ConstantStruct>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ConstantStruct>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h", 460, __PRETTY_FUNCTION__)); return cast<Constant>( OperandTraits<ConstantStruct>::op_begin(const_cast<ConstantStruct*>(this))[i_nocapture]); } void ConstantStruct::setOperand(unsigned i_nocapture, Constant *Val_nocapture) { ((i_nocapture < OperandTraits<ConstantStruct>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ConstantStruct>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h", 460, __PRETTY_FUNCTION__)); OperandTraits<ConstantStruct>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ConstantStruct::getNumOperands() const { return OperandTraits<ConstantStruct>::operands(this); } template <int Idx_nocapture> Use &ConstantStruct::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ConstantStruct::Op() const { return this->OpFrom<Idx_nocapture>(this); }




class ConstantUnion : public Constant {
  friend struct ConstantCreator<ConstantUnion, UnionType, Constant*>;
  ConstantUnion(const ConstantUnion &);
protected:
  ConstantUnion(const UnionType *T, Constant* Val);
public:

  static Constant *get(const UnionType *T, Constant* V);


  public: inline Constant *getOperand(unsigned) const; inline void setOperand(unsigned, Constant*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;



  inline const UnionType *getType() const {
    return reinterpret_cast<const UnionType*>(Value::getType());
  }




  virtual bool isNullValue() const {
    return false;
  }

  virtual void destroyConstant();
  virtual void replaceUsesOfWithOnConstant(Value *From, Value *To, Use *U);


  static inline bool classof(const ConstantUnion *) { return true; }
  static bool classof(const Value *V) {
    return V->getValueID() == ConstantUnionVal;
  }
};

template <>
struct OperandTraits<ConstantUnion> : public FixedNumOperandTraits<1> {
};

ConstantUnion::op_iterator ConstantUnion::op_begin() { return OperandTraits<ConstantUnion>::op_begin(this); } ConstantUnion::const_op_iterator ConstantUnion::op_begin() const { return OperandTraits<ConstantUnion>::op_begin(const_cast<ConstantUnion*>(this)); } ConstantUnion::op_iterator ConstantUnion::op_end() { return OperandTraits<ConstantUnion>::op_end(this); } ConstantUnion::const_op_iterator ConstantUnion::op_end() const { return OperandTraits<ConstantUnion>::op_end(const_cast<ConstantUnion*>(this)); } Constant *ConstantUnion::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<ConstantUnion>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ConstantUnion>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h", 504, __PRETTY_FUNCTION__)); return cast<Constant>( OperandTraits<ConstantUnion>::op_begin(const_cast<ConstantUnion*>(this))[i_nocapture]); } void ConstantUnion::setOperand(unsigned i_nocapture, Constant *Val_nocapture) { ((i_nocapture < OperandTraits<ConstantUnion>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ConstantUnion>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h", 504, __PRETTY_FUNCTION__)); OperandTraits<ConstantUnion>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ConstantUnion::getNumOperands() const { return OperandTraits<ConstantUnion>::operands(this); } template <int Idx_nocapture> Use &ConstantUnion::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ConstantUnion::Op() const { return this->OpFrom<Idx_nocapture>(this); }




class ConstantVector : public Constant {
  friend struct ConstantCreator<ConstantVector, VectorType,
                                    std::vector<Constant*> >;
  ConstantVector(const ConstantVector &);
protected:
  ConstantVector(const VectorType *T, const std::vector<Constant*> &Val);
public:

  static Constant *get(const VectorType *T, const std::vector<Constant*> &V);
  static Constant *get(const std::vector<Constant*> &V);
  static Constant *get(Constant *const *Vals, unsigned NumVals);


  public: inline Constant *getOperand(unsigned) const; inline void setOperand(unsigned, Constant*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;




  inline const VectorType *getType() const {
    return reinterpret_cast<const VectorType*>(Value::getType());
  }




  virtual bool isNullValue() const { return false; }





  bool isAllOnesValue() const;



  Constant *getSplatValue();

  virtual void destroyConstant();
  virtual void replaceUsesOfWithOnConstant(Value *From, Value *To, Use *U);


  static inline bool classof(const ConstantVector *) { return true; }
  static bool classof(const Value *V) {
    return V->getValueID() == ConstantVectorVal;
  }
};

template <>
struct OperandTraits<ConstantVector> : public VariadicOperandTraits<> {
};

ConstantVector::op_iterator ConstantVector::op_begin() { return OperandTraits<ConstantVector>::op_begin(this); } ConstantVector::const_op_iterator ConstantVector::op_begin() const { return OperandTraits<ConstantVector>::op_begin(const_cast<ConstantVector*>(this)); } ConstantVector::op_iterator ConstantVector::op_end() { return OperandTraits<ConstantVector>::op_end(this); } ConstantVector::const_op_iterator ConstantVector::op_end() const { return OperandTraits<ConstantVector>::op_end(const_cast<ConstantVector*>(this)); } Constant *ConstantVector::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<ConstantVector>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ConstantVector>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h", 560, __PRETTY_FUNCTION__)); return cast<Constant>( OperandTraits<ConstantVector>::op_begin(const_cast<ConstantVector*>(this))[i_nocapture]); } void ConstantVector::setOperand(unsigned i_nocapture, Constant *Val_nocapture) { ((i_nocapture < OperandTraits<ConstantVector>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ConstantVector>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h", 560, __PRETTY_FUNCTION__)); OperandTraits<ConstantVector>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ConstantVector::getNumOperands() const { return OperandTraits<ConstantVector>::operands(this); } template <int Idx_nocapture> Use &ConstantVector::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ConstantVector::Op() const { return this->OpFrom<Idx_nocapture>(this); }




class ConstantPointerNull : public Constant {
  friend struct ConstantCreator<ConstantPointerNull, PointerType, char>;
  void *operator new(size_t, unsigned);
  ConstantPointerNull(const ConstantPointerNull &);
protected:
  explicit ConstantPointerNull(const PointerType *T)
    : Constant(reinterpret_cast<const Type*>(T),
               Value::ConstantPointerNullVal, 0, 0) {}

protected:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
public:

  static ConstantPointerNull *get(const PointerType *T);



  virtual bool isNullValue() const { return true; }

  virtual void destroyConstant();




  inline const PointerType *getType() const {
    return reinterpret_cast<const PointerType*>(Value::getType());
  }


  static inline bool classof(const ConstantPointerNull *) { return true; }
  static bool classof(const Value *V) {
    return V->getValueID() == ConstantPointerNullVal;
  }
};



class BlockAddress : public Constant {
  void *operator new(size_t, unsigned);
  void *operator new(size_t s) { return User::operator new(s, 2); }
  BlockAddress(Function *F, BasicBlock *BB);
public:

  static BlockAddress *get(Function *F, BasicBlock *BB);



  static BlockAddress *get(BasicBlock *BB);


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;

  Function *getFunction() const { return (Function*)Op<0>().get(); }
  BasicBlock *getBasicBlock() const { return (BasicBlock*)Op<1>().get(); }



  virtual bool isNullValue() const { return false; }

  virtual void destroyConstant();
  virtual void replaceUsesOfWithOnConstant(Value *From, Value *To, Use *U);


  static inline bool classof(const BlockAddress *) { return true; }
  static inline bool classof(const Value *V) {
    return V->getValueID() == BlockAddressVal;
  }
};

template <>
struct OperandTraits<BlockAddress> : public FixedNumOperandTraits<2> {
};

BlockAddress::op_iterator BlockAddress::op_begin() { return OperandTraits<BlockAddress>::op_begin(this); } BlockAddress::const_op_iterator BlockAddress::op_begin() const { return OperandTraits<BlockAddress>::op_begin(const_cast<BlockAddress*>(this)); } BlockAddress::op_iterator BlockAddress::op_end() { return OperandTraits<BlockAddress>::op_end(this); } BlockAddress::const_op_iterator BlockAddress::op_end() const { return OperandTraits<BlockAddress>::op_end(const_cast<BlockAddress*>(this)); } Value *BlockAddress::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<BlockAddress>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<BlockAddress>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h", 641, __PRETTY_FUNCTION__)); return cast<Value>( OperandTraits<BlockAddress>::op_begin(const_cast<BlockAddress*>(this))[i_nocapture]); } void BlockAddress::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<BlockAddress>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<BlockAddress>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h", 641, __PRETTY_FUNCTION__)); OperandTraits<BlockAddress>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned BlockAddress::getNumOperands() const { return OperandTraits<BlockAddress>::operands(this); } template <int Idx_nocapture> Use &BlockAddress::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &BlockAddress::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 650 "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h"
class ConstantExpr : public Constant {
  friend struct ConstantCreator<ConstantExpr,Type,
                            std::pair<unsigned, std::vector<Constant*> > >;
  friend struct ConvertConstantType<ConstantExpr, Type>;

protected:
  ConstantExpr(const Type *ty, unsigned Opcode, Use *Ops, unsigned NumOps)
    : Constant(ty, ConstantExprVal, Ops, NumOps) {

    setValueSubclassData(Opcode);
  }



  static Constant *getTy(const Type *Ty, unsigned Opcode,
                         Constant *C1, Constant *C2,
                         unsigned Flags = 0);
  static Constant *getCompareTy(unsigned short pred, Constant *C1,
                                Constant *C2);
  static Constant *getSelectTy(const Type *Ty,
                               Constant *C1, Constant *C2, Constant *C3);
  static Constant *getGetElementPtrTy(const Type *Ty, Constant *C,
                                      Value* const *Idxs, unsigned NumIdxs);
  static Constant *getInBoundsGetElementPtrTy(const Type *Ty, Constant *C,
                                              Value* const *Idxs,
                                              unsigned NumIdxs);
  static Constant *getExtractElementTy(const Type *Ty, Constant *Val,
                                       Constant *Idx);
  static Constant *getInsertElementTy(const Type *Ty, Constant *Val,
                                      Constant *Elt, Constant *Idx);
  static Constant *getShuffleVectorTy(const Type *Ty, Constant *V1,
                                      Constant *V2, Constant *Mask);
  static Constant *getExtractValueTy(const Type *Ty, Constant *Agg,
                                     const unsigned *Idxs, unsigned NumIdxs);
  static Constant *getInsertValueTy(const Type *Ty, Constant *Agg,
                                    Constant *Val,
                                    const unsigned *Idxs, unsigned NumIdxs);

public:
# 699 "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h"
  static Constant *getAlignOf(const Type* Ty);





  static Constant *getSizeOf(const Type* Ty);




  static Constant *getOffsetOf(const StructType* STy, unsigned FieldNo);




  static Constant *getOffsetOf(const Type* Ty, Constant *FieldNo);

  static Constant *getNeg(Constant *C);
  static Constant *getFNeg(Constant *C);
  static Constant *getNot(Constant *C);
  static Constant *getAdd(Constant *C1, Constant *C2);
  static Constant *getFAdd(Constant *C1, Constant *C2);
  static Constant *getSub(Constant *C1, Constant *C2);
  static Constant *getFSub(Constant *C1, Constant *C2);
  static Constant *getMul(Constant *C1, Constant *C2);
  static Constant *getFMul(Constant *C1, Constant *C2);
  static Constant *getUDiv(Constant *C1, Constant *C2);
  static Constant *getSDiv(Constant *C1, Constant *C2);
  static Constant *getFDiv(Constant *C1, Constant *C2);
  static Constant *getURem(Constant *C1, Constant *C2);
  static Constant *getSRem(Constant *C1, Constant *C2);
  static Constant *getFRem(Constant *C1, Constant *C2);
  static Constant *getAnd(Constant *C1, Constant *C2);
  static Constant *getOr(Constant *C1, Constant *C2);
  static Constant *getXor(Constant *C1, Constant *C2);
  static Constant *getShl(Constant *C1, Constant *C2);
  static Constant *getLShr(Constant *C1, Constant *C2);
  static Constant *getAShr(Constant *C1, Constant *C2);
  static Constant *getTrunc (Constant *C, const Type *Ty);
  static Constant *getSExt (Constant *C, const Type *Ty);
  static Constant *getZExt (Constant *C, const Type *Ty);
  static Constant *getFPTrunc (Constant *C, const Type *Ty);
  static Constant *getFPExtend(Constant *C, const Type *Ty);
  static Constant *getUIToFP (Constant *C, const Type *Ty);
  static Constant *getSIToFP (Constant *C, const Type *Ty);
  static Constant *getFPToUI (Constant *C, const Type *Ty);
  static Constant *getFPToSI (Constant *C, const Type *Ty);
  static Constant *getPtrToInt(Constant *C, const Type *Ty);
  static Constant *getIntToPtr(Constant *C, const Type *Ty);
  static Constant *getBitCast (Constant *C, const Type *Ty);

  static Constant *getNSWNeg(Constant *C);
  static Constant *getNUWNeg(Constant *C);
  static Constant *getNSWAdd(Constant *C1, Constant *C2);
  static Constant *getNUWAdd(Constant *C1, Constant *C2);
  static Constant *getNSWSub(Constant *C1, Constant *C2);
  static Constant *getNUWSub(Constant *C1, Constant *C2);
  static Constant *getNSWMul(Constant *C1, Constant *C2);
  static Constant *getNUWMul(Constant *C1, Constant *C2);
  static Constant *getExactSDiv(Constant *C1, Constant *C2);


  public: inline Constant *getOperand(unsigned) const; inline void setOperand(unsigned, Constant*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;



  static Constant *getCast(
    unsigned ops,
    Constant *C,
    const Type *Ty
  );


  static Constant *getZExtOrBitCast(
    Constant *C,
    const Type *Ty
  );


  static Constant *getSExtOrBitCast(
    Constant *C,
    const Type *Ty
  );


  static Constant *getTruncOrBitCast(
    Constant *C,
    const Type *Ty
  );


  static Constant *getPointerCast(
    Constant *C,
    const Type *Ty
  );


  static Constant *getIntegerCast(
    Constant *C,
    const Type *Ty,
    bool isSigned
  );


  static Constant *getFPCast(
    Constant *C,
    const Type *Ty
  );


  bool isCast() const;


  bool isCompare() const;



  bool hasIndices() const;






  bool isGEPWithNoNotionalOverIndexing() const;



  static Constant *getSelect(Constant *C, Constant *V1, Constant *V2) {
    return getSelectTy(V1->getType(), C, V1, V2);
  }




  static Constant *get(unsigned Opcode, Constant *C1, Constant *C2,
                       unsigned Flags = 0);


  static Constant *getCompare(unsigned short pred, Constant *C1, Constant *C2);




  static Constant *getICmp(unsigned short pred, Constant *LHS, Constant *RHS);
  static Constant *getFCmp(unsigned short pred, Constant *LHS, Constant *RHS);




  static Constant *getGetElementPtr(Constant *C,
                                    Constant *const *IdxList, unsigned NumIdx);
  static Constant *getGetElementPtr(Constant *C,
                                    Value* const *IdxList, unsigned NumIdx);



  static Constant *getInBoundsGetElementPtr(Constant *C,
                                            Constant *const *IdxList,
                                            unsigned NumIdx);
  static Constant *getInBoundsGetElementPtr(Constant *C,
                                            Value* const *IdxList,
                                            unsigned NumIdx);

  static Constant *getExtractElement(Constant *Vec, Constant *Idx);
  static Constant *getInsertElement(Constant *Vec, Constant *Elt,Constant *Idx);
  static Constant *getShuffleVector(Constant *V1, Constant *V2, Constant *Mask);
  static Constant *getExtractValue(Constant *Agg,
                                   const unsigned *IdxList, unsigned NumIdx);
  static Constant *getInsertValue(Constant *Agg, Constant *Val,
                                  const unsigned *IdxList, unsigned NumIdx);



  virtual bool isNullValue() const { return false; }


  unsigned getOpcode() const { return getSubclassDataFromValue(); }



  unsigned getPredicate() const;



  const SmallVector<unsigned, 4> &getIndices() const;


  const char *getOpcodeName() const;



  Constant *getWithOperandReplaced(unsigned OpNo, Constant *Op) const;




  Constant *getWithOperands(const std::vector<Constant*> &Ops) const {
    return getWithOperands(&Ops[0], (unsigned)Ops.size());
  }
  Constant *getWithOperands(Constant *const *Ops, unsigned NumOps) const;

  virtual void destroyConstant();
  virtual void replaceUsesOfWithOnConstant(Value *From, Value *To, Use *U);


  static inline bool classof(const ConstantExpr *) { return true; }
  static inline bool classof(const Value *V) {
    return V->getValueID() == ConstantExprVal;
  }

private:


  void setValueSubclassData(unsigned short D) {
    Value::setValueSubclassData(D);
  }
};

template <>
struct OperandTraits<ConstantExpr> : public VariadicOperandTraits<1> {
};

ConstantExpr::op_iterator ConstantExpr::op_begin() { return OperandTraits<ConstantExpr>::op_begin(this); } ConstantExpr::const_op_iterator ConstantExpr::op_begin() const { return OperandTraits<ConstantExpr>::op_begin(const_cast<ConstantExpr*>(this)); } ConstantExpr::op_iterator ConstantExpr::op_end() { return OperandTraits<ConstantExpr>::op_end(this); } ConstantExpr::const_op_iterator ConstantExpr::op_end() const { return OperandTraits<ConstantExpr>::op_end(const_cast<ConstantExpr*>(this)); } Constant *ConstantExpr::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<ConstantExpr>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ConstantExpr>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h", 923, __PRETTY_FUNCTION__)); return cast<Constant>( OperandTraits<ConstantExpr>::op_begin(const_cast<ConstantExpr*>(this))[i_nocapture]); } void ConstantExpr::setOperand(unsigned i_nocapture, Constant *Val_nocapture) { ((i_nocapture < OperandTraits<ConstantExpr>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ConstantExpr>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Constants.h", 923, __PRETTY_FUNCTION__)); OperandTraits<ConstantExpr>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ConstantExpr::getNumOperands() const { return OperandTraits<ConstantExpr>::operands(this); } template <int Idx_nocapture> Use &ConstantExpr::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ConstantExpr::Op() const { return this->OpFrom<Idx_nocapture>(this); }







class UndefValue : public Constant {
  friend struct ConstantCreator<UndefValue, Type, char>;
  void *operator new(size_t, unsigned);
  UndefValue(const UndefValue &);
protected:
  explicit UndefValue(const Type *T) : Constant(T, UndefValueVal, 0, 0) {}
protected:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
public:



  static UndefValue *get(const Type *T);



  virtual bool isNullValue() const { return false; }

  virtual void destroyConstant();


  static inline bool classof(const UndefValue *) { return true; }
  static bool classof(const Value *V) {
    return V->getValueID() == UndefValueVal;
  }
};
}
# 6 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/DerivedTypes.h" 1
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/DerivedTypes.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h" 1
# 16 "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/GraphTraits.h" 1
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/GraphTraits.h"
namespace llvm {




template<class GraphType>
struct GraphTraits {
# 57 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/GraphTraits.h"
  typedef typename GraphType::UnknownGraphTypeError NodeType;
};
# 74 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/GraphTraits.h"
template <class GraphType>
struct Inverse {
  const GraphType &Graph;

  inline Inverse(const GraphType &G) : Graph(G) {}
};



template<class T>
struct GraphTraits<Inverse<Inverse<T> > > {
  typedef typename GraphTraits<T>::NodeType NodeType;
  typedef typename GraphTraits<T>::ChildIteratorType ChildIteratorType;

  static NodeType *getEntryNode(Inverse<Inverse<T> > *G) {
    return GraphTraits<T>::getEntryNode(G->Graph.Graph);
  }

  static ChildIteratorType child_begin(NodeType* N) {
    return GraphTraits<T>::child_begin(N);
  }

  static ChildIteratorType child_end(NodeType* N) {
    return GraphTraits<T>::child_end(N);
  }
};

}
# 17 "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h" 2



namespace llvm {

class DerivedType;
class PointerType;
class IntegerType;
class TypeMapBase;
class raw_ostream;
class Module;
class LLVMContext;
# 60 "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h"
class Type : public AbstractTypeUser {
public:







  enum TypeID {

    VoidTyID = 0,
    FloatTyID,
    DoubleTyID,
    X86_FP80TyID,
    FP128TyID,
    PPC_FP128TyID,
    LabelTyID,
    MetadataTyID,



    IntegerTyID,
    FunctionTyID,
    StructTyID,
    UnionTyID,
    ArrayTyID,
    PointerTyID,
    OpaqueTyID,
    VectorTyID,

    NumTypeIDs,
    LastPrimitiveTyID = MetadataTyID,
    FirstDerivedTyID = IntegerTyID
  };

private:
  TypeID ID : 8;
  bool Abstract : 1;
  unsigned SubclassData : 23;






  mutable unsigned RefCount;


  LLVMContext &Context;
  friend class LLVMContextImpl;

  const Type *getForwardedTypeInternal() const;



  void destroy() const;

protected:
  explicit Type(LLVMContext &C, TypeID id) :
                             ID(id), Abstract(false), SubclassData(0),
                             RefCount(0), Context(C),
                             ForwardType(0), NumContainedTys(0),
                             ContainedTys(0) {}
  virtual ~Type() {
    ((AbstractTypeUsers.empty() && "Abstract types remain") ? static_cast<void> (0) : __assert_fail ("AbstractTypeUsers.empty() && \"Abstract types remain\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h", 125, __PRETTY_FUNCTION__));
  }



  inline void setAbstract(bool Val) { Abstract = Val; }

  unsigned getRefCount() const { return RefCount; }

  unsigned getSubclassData() const { return SubclassData; }
  void setSubclassData(unsigned val) { SubclassData = val; }




  mutable const Type *ForwardType;





  mutable std::vector<AbstractTypeUser *> AbstractTypeUsers;





  unsigned NumContainedTys;
# 165 "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h"
  PATypeHandle *ContainedTys;

public:
  void print(raw_ostream &O) const;


  void dump() const;



  void dump(const Module *Context) const;


  LLVMContext &getContext() const { return Context; }







  std::string getDescription() const;




  inline TypeID getTypeID() const { return ID; }


  bool isVoidTy() const { return ID == VoidTyID; }


  bool isFloatTy() const { return ID == FloatTyID; }


  bool isDoubleTy() const { return ID == DoubleTyID; }


  bool isX86_FP80Ty() const { return ID == X86_FP80TyID; }


  bool isFP128Ty() const { return ID == FP128TyID; }


  bool isPPC_FP128Ty() const { return ID == PPC_FP128TyID; }



  bool isFloatingPointTy() const { return ID == FloatTyID || ID == DoubleTyID ||
      ID == X86_FP80TyID || ID == FP128TyID || ID == PPC_FP128TyID; }



  bool isFPOrFPVectorTy() const;


  bool isLabelTy() const { return ID == LabelTyID; }


  bool isMetadataTy() const { return ID == MetadataTyID; }



  bool isIntegerTy() const { return ID == IntegerTyID; }


  bool isIntegerTy(unsigned Bitwidth) const;




  bool isIntOrIntVectorTy() const;



  bool isFunctionTy() const { return ID == FunctionTyID; }



  bool isStructTy() const { return ID == StructTyID; }



  bool isUnionTy() const { return ID == UnionTyID; }



  bool isArrayTy() const { return ID == ArrayTyID; }



  bool isPointerTy() const { return ID == PointerTyID; }



  bool isOpaqueTy() const { return ID == OpaqueTyID; }



  bool isVectorTy() const { return ID == VectorTyID; }




  inline bool isAbstract() const { return Abstract; }






  bool canLosslesslyBitCastTo(const Type *Ty) const;





  inline bool isPrimitiveType() const { return ID <= LastPrimitiveTyID; }
  inline bool isDerivedType() const { return ID >= FirstDerivedTyID; }




  inline bool isFirstClassType() const {


    return ID != FunctionTyID && ID != VoidTyID && ID != OpaqueTyID;
  }





  inline bool isSingleValueType() const {
    return (ID != VoidTyID && ID <= LastPrimitiveTyID) ||
            ID == IntegerTyID || ID == PointerTyID || ID == VectorTyID;
  }






  inline bool isAggregateType() const {
    return ID == StructTyID || ID == ArrayTyID || ID == UnionTyID;
  }





  bool isSized() const {

    if (ID == IntegerTyID || isFloatingPointTy() || ID == PointerTyID)
      return true;


    if (ID != StructTyID && ID != ArrayTyID && ID != VectorTyID &&
        ID != UnionTyID)
      return false;


    return !isAbstract() || isSizedDerivedType();
  }
# 340 "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h"
  unsigned getPrimitiveSizeInBits() const;




  unsigned getScalarSizeInBits() const;




  int getFPMantissaWidth() const;





  const Type *getForwardedType() const {
    if (!ForwardType) return 0;
    return getForwardedTypeInternal();
  }




  const Type *getVAArgsPromotedType(LLVMContext &C) const;



  const Type *getScalarType() const;




  typedef PATypeHandle *subtype_iterator;
  subtype_iterator subtype_begin() const { return ContainedTys; }
  subtype_iterator subtype_end() const { return &ContainedTys[NumContainedTys];}





  const Type *getContainedType(unsigned i) const {
    ((i < NumContainedTys && "Index out of range!") ? static_cast<void> (0) : __assert_fail ("i < NumContainedTys && \"Index out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h", 382, __PRETTY_FUNCTION__));
    return ContainedTys[i].get();
  }



  unsigned getNumContainedTypes() const { return NumContainedTys; }







  static const Type *getPrimitiveType(LLVMContext &C, TypeID IDNumber);




  static const Type *getVoidTy(LLVMContext &C);
  static const Type *getLabelTy(LLVMContext &C);
  static const Type *getFloatTy(LLVMContext &C);
  static const Type *getDoubleTy(LLVMContext &C);
  static const Type *getMetadataTy(LLVMContext &C);
  static const Type *getX86_FP80Ty(LLVMContext &C);
  static const Type *getFP128Ty(LLVMContext &C);
  static const Type *getPPC_FP128Ty(LLVMContext &C);
  static const IntegerType *getInt1Ty(LLVMContext &C);
  static const IntegerType *getInt8Ty(LLVMContext &C);
  static const IntegerType *getInt16Ty(LLVMContext &C);
  static const IntegerType *getInt32Ty(LLVMContext &C);
  static const IntegerType *getInt64Ty(LLVMContext &C);





  static const PointerType *getFloatPtrTy(LLVMContext &C, unsigned AS = 0);
  static const PointerType *getDoublePtrTy(LLVMContext &C, unsigned AS = 0);
  static const PointerType *getX86_FP80PtrTy(LLVMContext &C, unsigned AS = 0);
  static const PointerType *getFP128PtrTy(LLVMContext &C, unsigned AS = 0);
  static const PointerType *getPPC_FP128PtrTy(LLVMContext &C, unsigned AS = 0);
  static const PointerType *getInt1PtrTy(LLVMContext &C, unsigned AS = 0);
  static const PointerType *getInt8PtrTy(LLVMContext &C, unsigned AS = 0);
  static const PointerType *getInt16PtrTy(LLVMContext &C, unsigned AS = 0);
  static const PointerType *getInt32PtrTy(LLVMContext &C, unsigned AS = 0);
  static const PointerType *getInt64PtrTy(LLVMContext &C, unsigned AS = 0);


  static inline bool classof(const Type *) { return true; }

  void addRef() const {
    ((isAbstract() && "Cannot add a reference to a non-abstract type!") ? static_cast<void> (0) : __assert_fail ("isAbstract() && \"Cannot add a reference to a non-abstract type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h", 434, __PRETTY_FUNCTION__));
    ++RefCount;
  }

  void dropRef() const {
    ((isAbstract() && "Cannot drop a reference to a non-abstract type!") ? static_cast<void> (0) : __assert_fail ("isAbstract() && \"Cannot drop a reference to a non-abstract type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h", 439, __PRETTY_FUNCTION__));
    ((RefCount && "No objects are currently referencing this object!") ? static_cast<void> (0) : __assert_fail ("RefCount && \"No objects are currently referencing this object!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h", 440, __PRETTY_FUNCTION__));



    if (--RefCount == 0 && AbstractTypeUsers.empty())
      this->destroy();
  }




  void addAbstractTypeUser(AbstractTypeUser *U) const;







  void removeAbstractTypeUser(AbstractTypeUser *U) const;



  const PointerType *getPointerTo(unsigned AddrSpace = 0) const;

private:



  bool isSizedDerivedType() const;

  virtual void refineAbstractType(const DerivedType *OldTy, const Type *NewTy);
  virtual void typeBecameConcrete(const DerivedType *AbsTy);

protected:


  void PromoteAbstractToConcrete();
  friend class TypeMapBase;
};






inline void PATypeHandle::addUser() {
  ((Ty && "Type Handle has a null type!") ? static_cast<void> (0) : __assert_fail ("Ty && \"Type Handle has a null type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h", 487, __PRETTY_FUNCTION__));
  if (Ty->isAbstract())
    Ty->addAbstractTypeUser(User);
}
inline void PATypeHandle::removeUser() {
  if (Ty->isAbstract())
    Ty->removeAbstractTypeUser(User);
}
# 503 "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h"
inline Type* PATypeHolder::get() const {
  const Type *NewTy = Ty->getForwardedType();
  if (!NewTy) return const_cast<Type*>(Ty);
  return *const_cast<PATypeHolder*>(this) = NewTy;
}

inline void PATypeHolder::addRef() {
  ((Ty && "Type Holder has a null type!") ? static_cast<void> (0) : __assert_fail ("Ty && \"Type Holder has a null type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Type.h", 510, __PRETTY_FUNCTION__));
  if (Ty->isAbstract())
    Ty->addRef();
}

inline void PATypeHolder::dropRef() {
  if (Ty->isAbstract())
    Ty->dropRef();
}






template <> struct GraphTraits<Type*> {
  typedef Type NodeType;
  typedef Type::subtype_iterator ChildIteratorType;

  static inline NodeType *getEntryNode(Type *T) { return T; }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return N->subtype_begin();
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return N->subtype_end();
  }
};

template <> struct GraphTraits<const Type*> {
  typedef const Type NodeType;
  typedef Type::subtype_iterator ChildIteratorType;

  static inline NodeType *getEntryNode(const Type *T) { return T; }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return N->subtype_begin();
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return N->subtype_end();
  }
};

template <> inline bool isa_impl<PointerType, Type>(const Type &Ty) {
  return Ty.getTypeID() == Type::PointerTyID;
}

raw_ostream &operator<<(raw_ostream &OS, const Type &T);

}
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/DerivedTypes.h" 2

namespace llvm {

class Value;
template<class ValType, class TypeClass> class TypeMap;
class FunctionValType;
class ArrayValType;
class StructValType;
class UnionValType;
class PointerValType;
class VectorValType;
class IntegerValType;
class APInt;
class LLVMContext;

class DerivedType : public Type {
  friend class Type;

protected:
  explicit DerivedType(LLVMContext &C, TypeID id) : Type(C, id) {}





  void notifyUsesThatTypeBecameConcrete();





  void dropAllTypeUses();



  void unlockedRefineAbstractTypeTo(const Type *NewType);

public:
# 71 "/local/monniaux/packages/llvm-2.7/include/llvm/DerivedTypes.h"
  void refineAbstractTypeTo(const Type *NewType);

  void dump() const { Type::dump(); }


  static inline bool classof(const DerivedType *) { return true; }
  static inline bool classof(const Type *T) {
    return T->isDerivedType();
  }
};





class IntegerType : public DerivedType {
  friend class LLVMContextImpl;

protected:
  explicit IntegerType(LLVMContext &C, unsigned NumBits) :
      DerivedType(C, IntegerTyID) {
    setSubclassData(NumBits);
  }
  friend class TypeMap<IntegerValType, IntegerType>;
public:

  enum {
    MIN_INT_BITS = 1,
    MAX_INT_BITS = (1<<23)-1


  };






  static const IntegerType* get(LLVMContext &C, unsigned NumBits);


  unsigned getBitWidth() const { return getSubclassData(); }




  uint64_t getBitMask() const {
    return ~uint64_t(0UL) >> (64-getBitWidth());
  }



  uint64_t getSignBit() const {
    return 1ULL << (getBitWidth()-1);
  }




  APInt getMask() const;





  bool isPowerOf2ByteWidth() const;


  static inline bool classof(const IntegerType *) { return true; }
  static inline bool classof(const Type *T) {
    return T->getTypeID() == IntegerTyID;
  }
};




class FunctionType : public DerivedType {
  friend class TypeMap<FunctionValType, FunctionType>;
  bool isVarArgs;

  FunctionType(const FunctionType &);
  const FunctionType &operator=(const FunctionType &);
  FunctionType(const Type *Result, const std::vector<const Type*> &Params,
               bool IsVarArgs);

public:



  static FunctionType *get(
    const Type *Result,
    const std::vector<const Type*> &Params,
    bool isVarArg
  );



  static FunctionType *get(
    const Type *Result,
    bool isVarArg
  ) {
    return get(Result, std::vector<const Type *>(), isVarArg);
  }



  static bool isValidReturnType(const Type *RetTy);



  static bool isValidArgumentType(const Type *ArgTy);

  inline bool isVarArg() const { return isVarArgs; }
  inline const Type *getReturnType() const { return ContainedTys[0]; }

  typedef Type::subtype_iterator param_iterator;
  param_iterator param_begin() const { return ContainedTys + 1; }
  param_iterator param_end() const { return &ContainedTys[NumContainedTys]; }


  const Type *getParamType(unsigned i) const { return ContainedTys[i+1]; }




  unsigned getNumParams() const { return NumContainedTys - 1; }


  virtual void refineAbstractType(const DerivedType *OldTy, const Type *NewTy);
  virtual void typeBecameConcrete(const DerivedType *AbsTy);


  static inline bool classof(const FunctionType *) { return true; }
  static inline bool classof(const Type *T) {
    return T->getTypeID() == FunctionTyID;
  }
};




class CompositeType : public DerivedType {
protected:
  inline explicit CompositeType(LLVMContext &C, TypeID id) :
    DerivedType(C, id) { }
public:




  virtual const Type *getTypeAtIndex(const Value *V) const = 0;
  virtual const Type *getTypeAtIndex(unsigned Idx) const = 0;
  virtual bool indexValid(const Value *V) const = 0;
  virtual bool indexValid(unsigned Idx) const = 0;


  static inline bool classof(const CompositeType *) { return true; }
  static inline bool classof(const Type *T) {
    return T->getTypeID() == ArrayTyID ||
           T->getTypeID() == StructTyID ||
           T->getTypeID() == PointerTyID ||
           T->getTypeID() == VectorTyID ||
           T->getTypeID() == UnionTyID;
  }
};




class StructType : public CompositeType {
  friend class TypeMap<StructValType, StructType>;
  StructType(const StructType &);
  const StructType &operator=(const StructType &);
  StructType(LLVMContext &C,
             const std::vector<const Type*> &Types, bool isPacked);
public:



  static StructType *get(LLVMContext &Context,
                         const std::vector<const Type*> &Params,
                         bool isPacked=false);



  static StructType *get(LLVMContext &Context, bool isPacked=false) {
    return get(Context, std::vector<const Type*>(), isPacked);
  }





  static StructType *get(LLVMContext &Context,
                         const Type *type, ...) __attribute__((sentinel));



  static bool isValidElementType(const Type *ElemTy);


  typedef Type::subtype_iterator element_iterator;
  element_iterator element_begin() const { return ContainedTys; }
  element_iterator element_end() const { return &ContainedTys[NumContainedTys];}


  unsigned getNumElements() const { return NumContainedTys; }
  const Type *getElementType(unsigned N) const {
    ((N < NumContainedTys && "Element number out of range!") ? static_cast<void> (0) : __assert_fail ("N < NumContainedTys && \"Element number out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/DerivedTypes.h", 280, __PRETTY_FUNCTION__));
    return ContainedTys[N];
  }




  virtual const Type *getTypeAtIndex(const Value *V) const;
  virtual const Type *getTypeAtIndex(unsigned Idx) const;
  virtual bool indexValid(const Value *V) const;
  virtual bool indexValid(unsigned Idx) const;


  virtual void refineAbstractType(const DerivedType *OldTy, const Type *NewTy);
  virtual void typeBecameConcrete(const DerivedType *AbsTy);


  static inline bool classof(const StructType *) { return true; }
  static inline bool classof(const Type *T) {
    return T->getTypeID() == StructTyID;
  }

  bool isPacked() const { return (0 != getSubclassData()) ? true : false; }
};





class UnionType : public CompositeType {
  friend class TypeMap<UnionValType, UnionType>;
  UnionType(const UnionType &);
  const UnionType &operator=(const UnionType &);
  UnionType(LLVMContext &C, const Type* const* Types, unsigned NumTypes);
public:


  static UnionType *get(const Type* const* Types, unsigned NumTypes);



  static UnionType *get(const Type *type, ...) __attribute__((sentinel));



  static bool isValidElementType(const Type *ElemTy);



  int getElementTypeIndex(const Type *ElemTy) const;


  typedef Type::subtype_iterator element_iterator;
  element_iterator element_begin() const { return ContainedTys; }
  element_iterator element_end() const { return &ContainedTys[NumContainedTys];}


  unsigned getNumElements() const { return NumContainedTys; }
  const Type *getElementType(unsigned N) const {
    ((N < NumContainedTys && "Element number out of range!") ? static_cast<void> (0) : __assert_fail ("N < NumContainedTys && \"Element number out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/DerivedTypes.h", 339, __PRETTY_FUNCTION__));
    return ContainedTys[N];
  }




  virtual const Type *getTypeAtIndex(const Value *V) const;
  virtual const Type *getTypeAtIndex(unsigned Idx) const;
  virtual bool indexValid(const Value *V) const;
  virtual bool indexValid(unsigned Idx) const;


  virtual void refineAbstractType(const DerivedType *OldTy, const Type *NewTy);
  virtual void typeBecameConcrete(const DerivedType *AbsTy);


  static inline bool classof(const UnionType *) { return true; }
  static inline bool classof(const Type *T) {
    return T->getTypeID() == UnionTyID;
  }
};
# 371 "/local/monniaux/packages/llvm-2.7/include/llvm/DerivedTypes.h"
class SequentialType : public CompositeType {
  PATypeHandle ContainedType;
  SequentialType(const SequentialType &);
  const SequentialType &operator=(const SequentialType &);


  SequentialType* this_() { return this; }
protected:
  SequentialType(TypeID TID, const Type *ElType)
    : CompositeType(ElType->getContext(), TID), ContainedType(ElType, this_()) {
    ContainedTys = &ContainedType;
    NumContainedTys = 1;
  }

public:
  inline const Type *getElementType() const { return ContainedTys[0]; }

  virtual bool indexValid(const Value *V) const;
  virtual bool indexValid(unsigned) const {
    return true;
  }




  virtual const Type *getTypeAtIndex(const Value *) const {
    return ContainedTys[0];
  }
  virtual const Type *getTypeAtIndex(unsigned) const {
    return ContainedTys[0];
  }


  static inline bool classof(const SequentialType *) { return true; }
  static inline bool classof(const Type *T) {
    return T->getTypeID() == ArrayTyID ||
           T->getTypeID() == PointerTyID ||
           T->getTypeID() == VectorTyID;
  }
};




class ArrayType : public SequentialType {
  friend class TypeMap<ArrayValType, ArrayType>;
  uint64_t NumElements;

  ArrayType(const ArrayType &);
  const ArrayType &operator=(const ArrayType &);
  ArrayType(const Type *ElType, uint64_t NumEl);
public:



  static ArrayType *get(const Type *ElementType, uint64_t NumElements);



  static bool isValidElementType(const Type *ElemTy);

  inline uint64_t getNumElements() const { return NumElements; }


  virtual void refineAbstractType(const DerivedType *OldTy, const Type *NewTy);
  virtual void typeBecameConcrete(const DerivedType *AbsTy);


  static inline bool classof(const ArrayType *) { return true; }
  static inline bool classof(const Type *T) {
    return T->getTypeID() == ArrayTyID;
  }
};



class VectorType : public SequentialType {
  friend class TypeMap<VectorValType, VectorType>;
  unsigned NumElements;

  VectorType(const VectorType &);
  const VectorType &operator=(const VectorType &);
  VectorType(const Type *ElType, unsigned NumEl);
public:



  static VectorType *get(const Type *ElementType, unsigned NumElements);





  static VectorType *getInteger(const VectorType *VTy) {
    unsigned EltBits = VTy->getElementType()->getPrimitiveSizeInBits();
    const Type *EltTy = IntegerType::get(VTy->getContext(), EltBits);
    return VectorType::get(EltTy, VTy->getNumElements());
  }





  static VectorType *getExtendedElementVectorType(const VectorType *VTy) {
    unsigned EltBits = VTy->getElementType()->getPrimitiveSizeInBits();
    const Type *EltTy = IntegerType::get(VTy->getContext(), EltBits * 2);
    return VectorType::get(EltTy, VTy->getNumElements());
  }





  static VectorType *getTruncatedElementVectorType(const VectorType *VTy) {
    unsigned EltBits = VTy->getElementType()->getPrimitiveSizeInBits();
    (((EltBits & 1) == 0 && "Cannot truncate vector element with odd bit-width") ? static_cast<void> (0) : __assert_fail ("(EltBits & 1) == 0 && \"Cannot truncate vector element with odd bit-width\"", "/local/monniaux/packages/llvm-2.7/include/llvm/DerivedTypes.h", 487, __PRETTY_FUNCTION__));

    const Type *EltTy = IntegerType::get(VTy->getContext(), EltBits / 2);
    return VectorType::get(EltTy, VTy->getNumElements());
  }



  static bool isValidElementType(const Type *ElemTy);


  inline unsigned getNumElements() const { return NumElements; }


  inline unsigned getBitWidth() const {
    return NumElements * getElementType()->getPrimitiveSizeInBits();
  }


  virtual void refineAbstractType(const DerivedType *OldTy, const Type *NewTy);
  virtual void typeBecameConcrete(const DerivedType *AbsTy);


  static inline bool classof(const VectorType *) { return true; }
  static inline bool classof(const Type *T) {
    return T->getTypeID() == VectorTyID;
  }
};




class PointerType : public SequentialType {
  friend class TypeMap<PointerValType, PointerType>;
  unsigned AddressSpace;

  PointerType(const PointerType &);
  const PointerType &operator=(const PointerType &);
  explicit PointerType(const Type *ElType, unsigned AddrSpace);
public:


  static PointerType *get(const Type *ElementType, unsigned AddressSpace);



  static PointerType *getUnqual(const Type *ElementType) {
    return PointerType::get(ElementType, 0);
  }



  static bool isValidElementType(const Type *ElemTy);


  inline unsigned getAddressSpace() const { return AddressSpace; }


  virtual void refineAbstractType(const DerivedType *OldTy, const Type *NewTy);
  virtual void typeBecameConcrete(const DerivedType *AbsTy);


  static inline bool classof(const PointerType *) { return true; }
  static inline bool classof(const Type *T) {
    return T->getTypeID() == PointerTyID;
  }
};




class OpaqueType : public DerivedType {
  friend class LLVMContextImpl;
  OpaqueType(const OpaqueType &);
  const OpaqueType &operator=(const OpaqueType &);
  OpaqueType(LLVMContext &C);
public:


  static OpaqueType *get(LLVMContext &C);


  static inline bool classof(const OpaqueType *) { return true; }
  static inline bool classof(const Type *T) {
    return T->getTypeID() == OpaqueTyID;
  }
};

}
# 7 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h" 1
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Function.h" 1
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/Function.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalValue.h" 1
# 23 "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalValue.h"
namespace llvm {

class PointerType;
class Module;

class GlobalValue : public Constant {
  GlobalValue(const GlobalValue &);
public:

  enum LinkageTypes {
    ExternalLinkage = 0,
    AvailableExternallyLinkage,
    LinkOnceAnyLinkage,
    LinkOnceODRLinkage,
    WeakAnyLinkage,
    WeakODRLinkage,
    AppendingLinkage,
    InternalLinkage,
    PrivateLinkage,
    LinkerPrivateLinkage,
    DLLImportLinkage,
    DLLExportLinkage,
    ExternalWeakLinkage,
    CommonLinkage
  };


  enum VisibilityTypes {
    DefaultVisibility = 0,
    HiddenVisibility,
    ProtectedVisibility
  };

protected:
  GlobalValue(const Type *ty, ValueTy vty, Use *Ops, unsigned NumOps,
              LinkageTypes linkage, const Twine &Name)
    : Constant(ty, vty, Ops, NumOps), Parent(0),
      Linkage(linkage), Visibility(DefaultVisibility), Alignment(0) {
    setName(Name);
  }

  Module *Parent;


  LinkageTypes Linkage : 5;
  unsigned Visibility : 2;
  unsigned Alignment : 16;
  std::string Section;
public:
  ~GlobalValue() {
    removeDeadConstantUsers();
  }

  unsigned getAlignment() const { return Alignment; }
  void setAlignment(unsigned Align) {
    (((Align & (Align-1)) == 0 && "Alignment is not a power of 2!") ? static_cast<void> (0) : __assert_fail ("(Align & (Align-1)) == 0 && \"Alignment is not a power of 2!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalValue.h", 78, __PRETTY_FUNCTION__));
    Alignment = Align;
  }

  VisibilityTypes getVisibility() const { return VisibilityTypes(Visibility); }
  bool hasDefaultVisibility() const { return Visibility == DefaultVisibility; }
  bool hasHiddenVisibility() const { return Visibility == HiddenVisibility; }
  bool hasProtectedVisibility() const {
    return Visibility == ProtectedVisibility;
  }
  void setVisibility(VisibilityTypes V) { Visibility = V; }

  bool hasSection() const { return !Section.empty(); }
  const std::string &getSection() const { return Section; }
  void setSection(StringRef S) { Section = S; }






  bool use_empty_except_constants();


  inline const PointerType *getType() const {
    return reinterpret_cast<const PointerType*>(User::getType());
  }

  static LinkageTypes getLinkOnceLinkage(bool ODR) {
    return ODR ? LinkOnceODRLinkage : LinkOnceAnyLinkage;
  }
  static LinkageTypes getWeakLinkage(bool ODR) {
    return ODR ? WeakODRLinkage : WeakAnyLinkage;
  }

  static bool isExternalLinkage(LinkageTypes Linkage) {
    return Linkage == ExternalLinkage;
  }
  static bool isAvailableExternallyLinkage(LinkageTypes Linkage) {
    return Linkage == AvailableExternallyLinkage;
  }
  static bool isLinkOnceLinkage(LinkageTypes Linkage) {
    return Linkage == LinkOnceAnyLinkage || Linkage == LinkOnceODRLinkage;
  }
  static bool isWeakLinkage(LinkageTypes Linkage) {
    return Linkage == WeakAnyLinkage || Linkage == WeakODRLinkage;
  }
  static bool isAppendingLinkage(LinkageTypes Linkage) {
    return Linkage == AppendingLinkage;
  }
  static bool isInternalLinkage(LinkageTypes Linkage) {
    return Linkage == InternalLinkage;
  }
  static bool isPrivateLinkage(LinkageTypes Linkage) {
    return Linkage == PrivateLinkage;
  }
  static bool isLinkerPrivateLinkage(LinkageTypes Linkage) {
    return Linkage==LinkerPrivateLinkage;
  }
  static bool isLocalLinkage(LinkageTypes Linkage) {
    return isInternalLinkage(Linkage) || isPrivateLinkage(Linkage) ||
      isLinkerPrivateLinkage(Linkage);
  }
  static bool isDLLImportLinkage(LinkageTypes Linkage) {
    return Linkage == DLLImportLinkage;
  }
  static bool isDLLExportLinkage(LinkageTypes Linkage) {
    return Linkage == DLLExportLinkage;
  }
  static bool isExternalWeakLinkage(LinkageTypes Linkage) {
    return Linkage == ExternalWeakLinkage;
  }
  static bool isCommonLinkage(LinkageTypes Linkage) {
    return Linkage == CommonLinkage;
  }




  static bool mayBeOverridden(LinkageTypes Linkage) {
    return (Linkage == WeakAnyLinkage ||
            Linkage == LinkOnceAnyLinkage ||
            Linkage == CommonLinkage ||
            Linkage == ExternalWeakLinkage);
  }



  static bool isWeakForLinker(LinkageTypes Linkage) {
    return (Linkage == AvailableExternallyLinkage ||
            Linkage == WeakAnyLinkage ||
            Linkage == WeakODRLinkage ||
            Linkage == LinkOnceAnyLinkage ||
            Linkage == LinkOnceODRLinkage ||
            Linkage == CommonLinkage ||
            Linkage == ExternalWeakLinkage);
  }

  bool hasExternalLinkage() const { return isExternalLinkage(Linkage); }
  bool hasAvailableExternallyLinkage() const {
    return isAvailableExternallyLinkage(Linkage);
  }
  bool hasLinkOnceLinkage() const {
    return isLinkOnceLinkage(Linkage);
  }
  bool hasWeakLinkage() const {
    return isWeakLinkage(Linkage);
  }
  bool hasAppendingLinkage() const { return isAppendingLinkage(Linkage); }
  bool hasInternalLinkage() const { return isInternalLinkage(Linkage); }
  bool hasPrivateLinkage() const { return isPrivateLinkage(Linkage); }
  bool hasLinkerPrivateLinkage() const { return isLinkerPrivateLinkage(Linkage); }
  bool hasLocalLinkage() const { return isLocalLinkage(Linkage); }
  bool hasDLLImportLinkage() const { return isDLLImportLinkage(Linkage); }
  bool hasDLLExportLinkage() const { return isDLLExportLinkage(Linkage); }
  bool hasExternalWeakLinkage() const { return isExternalWeakLinkage(Linkage); }
  bool hasCommonLinkage() const { return isCommonLinkage(Linkage); }

  void setLinkage(LinkageTypes LT) { Linkage = LT; }
  LinkageTypes getLinkage() const { return Linkage; }

  bool mayBeOverridden() const { return mayBeOverridden(Linkage); }

  bool isWeakForLinker() const { return isWeakForLinker(Linkage); }



  virtual void copyAttributesFrom(const GlobalValue *Src);
# 216 "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalValue.h"
  bool isMaterializable() const;




  bool isDematerializable() const;




  bool Materialize(std::string *ErrInfo = 0);




  void Dematerialize();





  virtual bool isNullValue() const { return false; }


  virtual void destroyConstant();



  virtual bool isDeclaration() const = 0;



  virtual void removeFromParent() = 0;



  virtual void eraseFromParent() = 0;



  inline Module *getParent() { return Parent; }
  inline const Module *getParent() const { return Parent; }





  void removeDeadConstantUsers() const;


  static inline bool classof(const GlobalValue *) { return true; }
  static inline bool classof(const Value *V) {
    return V->getValueID() == Value::FunctionVal ||
           V->getValueID() == Value::GlobalVariableVal ||
           V->getValueID() == Value::GlobalAliasVal;
  }
};

}
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/Function.h" 2

# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/BasicBlock.h" 1
# 17 "/local/monniaux/packages/llvm-2.7/include/llvm/BasicBlock.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.h" 1
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist_node.h" 1
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist_node.h"
namespace llvm {

template<typename NodeTy>
struct ilist_traits;



template<typename NodeTy>
class ilist_half_node {
  friend struct ilist_traits<NodeTy>;
  NodeTy *Prev;
protected:
  NodeTy *getPrev() { return Prev; }
  const NodeTy *getPrev() const { return Prev; }
  void setPrev(NodeTy *P) { Prev = P; }
  ilist_half_node() : Prev(0) {}
};

template<typename NodeTy>
struct ilist_nextprev_traits;




template<typename NodeTy>
class ilist_node : private ilist_half_node<NodeTy> {
  friend struct ilist_nextprev_traits<NodeTy>;
  friend struct ilist_traits<NodeTy>;
  NodeTy *Next;
  NodeTy *getNext() { return Next; }
  const NodeTy *getNext() const { return Next; }
  void setNext(NodeTy *N) { Next = N; }
protected:
  ilist_node() : Next(0) {}
};

}
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.h" 2

namespace llvm {

class LLVMContext;
class MDNode;

template<typename ValueSubClass, typename ItemParentClass>
  class SymbolTableListTraits;

class Instruction : public User, public ilist_node<Instruction> {
  void operator=(const Instruction &);
  Instruction(const Instruction &);

  BasicBlock *Parent;

  enum {


    HasMetadataBit = 1 << 15
  };
public:

  ~Instruction();



  Instruction *use_back() { return cast<Instruction>(*use_begin());}
  const Instruction *use_back() const { return cast<Instruction>(*use_begin());}

  inline const BasicBlock *getParent() const { return Parent; }
  inline BasicBlock *getParent() { return Parent; }




  void removeFromParent();




  void eraseFromParent();



  void insertBefore(Instruction *InsertPos);



  void insertAfter(Instruction *InsertPos);




  void moveBefore(Instruction *MovePos);






  unsigned getOpcode() const { return getValueID() - InstructionVal; }

  const char *getOpcodeName() const { return getOpcodeName(getOpcode()); }
  bool isTerminator() const { return isTerminator(getOpcode()); }
  bool isBinaryOp() const { return isBinaryOp(getOpcode()); }
  bool isShift() { return isShift(getOpcode()); }
  bool isCast() const { return isCast(getOpcode()); }

  static const char* getOpcodeName(unsigned OpCode);

  static inline bool isTerminator(unsigned OpCode) {
    return OpCode >= TermOpsBegin && OpCode < TermOpsEnd;
  }

  static inline bool isBinaryOp(unsigned Opcode) {
    return Opcode >= BinaryOpsBegin && Opcode < BinaryOpsEnd;
  }


  static inline bool isShift(unsigned Opcode) {
    return Opcode >= Shl && Opcode <= AShr;
  }



  inline bool isLogicalShift() const {
    return getOpcode() == Shl || getOpcode() == LShr;
  }


  inline bool isArithmeticShift() const {
    return getOpcode() == AShr;
  }


  static inline bool isCast(unsigned OpCode) {
    return OpCode >= CastOpsBegin && OpCode < CastOpsEnd;
  }







  bool hasMetadata() const {
    return (getSubclassDataFromValue() & HasMetadataBit) != 0;
  }



  MDNode *getMetadata(unsigned KindID) const {
    if (!hasMetadata()) return 0;
    return getMetadataImpl(KindID);
  }



  MDNode *getMetadata(const char *Kind) const {
    if (!hasMetadata()) return 0;
    return getMetadataImpl(Kind);
  }




  void getAllMetadata(SmallVectorImpl<std::pair<unsigned, MDNode*> > &MDs)const{
    if (hasMetadata())
      getAllMetadataImpl(MDs);
  }




  void setMetadata(unsigned KindID, MDNode *Node);
  void setMetadata(const char *Kind, MDNode *Node);

private:

  MDNode *getMetadataImpl(unsigned KindID) const;
  MDNode *getMetadataImpl(const char *Kind) const;
  void getAllMetadataImpl(SmallVectorImpl<std::pair<unsigned,MDNode*> > &)const;
  void removeAllMetadata();
public:
# 176 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.h"
  bool isAssociative() const { return isAssociative(getOpcode(), getType()); }
  static bool isAssociative(unsigned op, const Type *Ty);
# 186 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.h"
  bool isCommutative() const { return isCommutative(getOpcode()); }
  static bool isCommutative(unsigned op);



  bool mayWriteToMemory() const;



  bool mayReadFromMemory() const;



  bool mayThrow() const;







  bool mayHaveSideEffects() const {
    return mayWriteToMemory() || mayThrow();
  }
# 229 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.h"
  bool isSafeToSpeculativelyExecute() const;






  Instruction *clone() const;




  bool isIdenticalTo(const Instruction *I) const;




  bool isIdenticalToWhenDefined(const Instruction *I) const;
# 256 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.h"
  bool isSameOperationAs(const Instruction *I) const;





  bool isUsedOutsideOfBlock(const BasicBlock *BB) const;



  static inline bool classof(const Instruction *) { return true; }
  static inline bool classof(const Value *V) {
    return V->getValueID() >= Value::InstructionVal;
  }




  enum TermOps {



# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def" 1
# 96 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def"
 TermOpsBegin = 1,
Ret = 1,
Br = 2,
Switch = 3,
IndirectBr = 4,
Invoke = 5,
Unwind = 6,
Unreachable = 7,
  TermOpsEnd = 7 +1























 







 

















 

















 
# 279 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.h" 2
  };

  enum BinaryOps {



# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def" 1
# 96 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def"








 


 BinaryOpsBegin = 8,
Add = 8,
FAdd = 9,
Sub = 10,
FSub = 11,
Mul = 12,
FMul = 13,
UDiv = 14,
SDiv = 15,
FDiv = 16,
URem = 17,
SRem = 18,
FRem = 19,


Shl = 20,
LShr = 21,
AShr = 22,
And = 23,
Or = 24,
Xor = 25,
  BinaryOpsEnd = 25 +1







 

















 

















 
# 286 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.h" 2
  };

  enum MemoryOps {



# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def" 1
# 96 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def"








 























 


 MemoryOpsBegin = 26,
Alloca = 26,
Load = 27,
Store = 28,
GetElementPtr = 29,
  MemoryOpsEnd = 29 +1

















 

















 
# 293 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.h" 2
  };

  enum CastOps {



# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def" 1
# 96 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def"








 























 







 




 CastOpsBegin = 30,
Trunc = 30,
ZExt = 31,
SExt = 32,
FPToUI = 33,
FPToSI = 34,
UIToFP = 35,
SIToFP = 36,
FPTrunc = 37,
FPExt = 38,
PtrToInt = 39,
IntToPtr = 40,
BitCast = 41,
  CastOpsEnd = 41 +1

















 
# 300 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.h" 2
  };

  enum OtherOps {



# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def" 1
# 96 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def"








 























 







 

















 


 OtherOpsBegin = 42,
ICmp = 42,
FCmp = 43,
PHI = 44,
Call = 45,
Select = 46,
UserOp1 = 47,
UserOp2 = 48,
VAArg = 49,
ExtractElement = 50,
InsertElement = 51,
ShuffleVector = 52,
ExtractValue = 53,
InsertValue = 54,

  OtherOpsEnd = 54 +1
# 307 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.h" 2
  };
private:


  void setValueSubclassData(unsigned short D) {
    Value::setValueSubclassData(D);
  }
  unsigned short getSubclassDataFromValue() const {
    return Value::getSubclassDataFromValue();
  }

  void setHasMetadata(bool V) {
    setValueSubclassData((getSubclassDataFromValue() & ~HasMetadataBit) |
                         (V ? HasMetadataBit : 0));
  }

  friend class SymbolTableListTraits<Instruction, BasicBlock>;
  void setParent(BasicBlock *P);
protected:




  void setInstructionSubclassData(unsigned short D) {
    (((D & HasMetadataBit) == 0 && "Out of range value put into field") ? static_cast<void> (0) : __assert_fail ("(D & HasMetadataBit) == 0 && \"Out of range value put into field\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.h", 331, __PRETTY_FUNCTION__));
    setValueSubclassData((getSubclassDataFromValue() & HasMetadataBit) | D);
  }

  unsigned getSubclassDataFromInstruction() const {
    return getSubclassDataFromValue() & ~HasMetadataBit;
  }

  Instruction(const Type *Ty, unsigned iType, Use *Ops, unsigned NumOps,
              Instruction *InsertBefore = 0);
  Instruction(const Type *Ty, unsigned iType, Use *Ops, unsigned NumOps,
              BasicBlock *InsertAtEnd);
  virtual Instruction *clone_impl() const = 0;

};


template<>
class PointerLikeTypeTraits<Instruction*> {
  typedef Instruction* PT;
public:
  static inline void *getAsVoidPointer(PT P) { return P; }
  static inline PT getFromVoidPointer(void *P) {
    return static_cast<PT>(P);
  }
  enum { NumLowBitsAvailable = 2 };
};

}
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/BasicBlock.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/SymbolTableListTraits.h" 1
# 28 "/local/monniaux/packages/llvm-2.7/include/llvm/SymbolTableListTraits.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h" 1
# 41 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h"
# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 42 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h" 2


namespace llvm {

template<typename NodeTy, typename Traits> class iplist;
template<typename NodeTy> class ilist_iterator;




template<typename NodeTy>
struct ilist_nextprev_traits {
  static NodeTy *getPrev(NodeTy *N) { return N->getPrev(); }
  static NodeTy *getNext(NodeTy *N) { return N->getNext(); }
  static const NodeTy *getPrev(const NodeTy *N) { return N->getPrev(); }
  static const NodeTy *getNext(const NodeTy *N) { return N->getNext(); }

  static void setPrev(NodeTy *N, NodeTy *Prev) { N->setPrev(Prev); }
  static void setNext(NodeTy *N, NodeTy *Next) { N->setNext(Next); }
};

template<typename NodeTy>
struct ilist_traits;







template<typename NodeTy>
struct ilist_sentinel_traits {

  static NodeTy *createSentinel() { return new NodeTy(); }


  static void destroySentinel(NodeTy *N) { delete N; }




  static NodeTy *provideInitialHead() { return 0; }




  static NodeTy *ensureHead(NodeTy *&Head) {
    if (!Head) {
      Head = ilist_traits<NodeTy>::createSentinel();
      ilist_traits<NodeTy>::noteHead(Head, Head);
      ilist_traits<NodeTy>::setNext(Head, 0);
      return Head;
    }
    return ilist_traits<NodeTy>::getPrev(Head);
  }


  static void noteHead(NodeTy *NewHead, NodeTy *Sentinel) {
    ilist_traits<NodeTy>::setPrev(NewHead, Sentinel);
  }
};




template<typename NodeTy>
struct ilist_node_traits {
  static NodeTy *createNode(const NodeTy &V) { return new NodeTy(V); }
  static void deleteNode(NodeTy *V) { delete V; }

  void addNodeToList(NodeTy *) {}
  void removeNodeFromList(NodeTy *) {}
  void transferNodesFromList(ilist_node_traits & ,
                             ilist_iterator<NodeTy> ,
                             ilist_iterator<NodeTy> ) {}
};





template<typename NodeTy>
struct ilist_default_traits : public ilist_nextprev_traits<NodeTy>,
                              public ilist_sentinel_traits<NodeTy>,
                              public ilist_node_traits<NodeTy> {
};



template<typename NodeTy>
struct ilist_traits : public ilist_default_traits<NodeTy> {};


template<typename Ty>
struct ilist_traits<const Ty> : public ilist_traits<Ty> {};




template<typename NodeTy>
class ilist_iterator
  : public std::iterator<std::bidirectional_iterator_tag, NodeTy, ptrdiff_t> {

public:
  typedef ilist_traits<NodeTy> Traits;
  typedef std::iterator<std::bidirectional_iterator_tag,
                        NodeTy, ptrdiff_t> super;

  typedef typename super::value_type value_type;
  typedef typename super::difference_type difference_type;
  typedef typename super::pointer pointer;
  typedef typename super::reference reference;
private:
  pointer NodePtr;





  void operator[](difference_type) const;
  void operator+(difference_type) const;
  void operator-(difference_type) const;
  void operator+=(difference_type) const;
  void operator-=(difference_type) const;
  template<class T> void operator<(T) const;
  template<class T> void operator<=(T) const;
  template<class T> void operator>(T) const;
  template<class T> void operator>=(T) const;
  template<class T> void operator-(T) const;
public:

  ilist_iterator(pointer NP) : NodePtr(NP) {}
  ilist_iterator(reference NR) : NodePtr(&NR) {}
  ilist_iterator() : NodePtr(0) {}



  template<class node_ty>
  ilist_iterator(const ilist_iterator<node_ty> &RHS)
    : NodePtr(RHS.getNodePtrUnchecked()) {}



  template<class node_ty>
  const ilist_iterator &operator=(const ilist_iterator<node_ty> &RHS) {
    NodePtr = RHS.getNodePtrUnchecked();
    return *this;
  }


  operator pointer() const {
    return NodePtr;
  }

  reference operator*() const {
    return *NodePtr;
  }
  pointer operator->() const { return &operator*(); }


  bool operator==(const ilist_iterator &RHS) const {
    return NodePtr == RHS.NodePtr;
  }
  bool operator!=(const ilist_iterator &RHS) const {
    return NodePtr != RHS.NodePtr;
  }


  ilist_iterator &operator--() {
    NodePtr = Traits::getPrev(NodePtr);
    ((NodePtr && "--'d off the beginning of an ilist!") ? static_cast<void> (0) : __assert_fail ("NodePtr && \"--'d off the beginning of an ilist!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h", 212, __PRETTY_FUNCTION__));
    return *this;
  }
  ilist_iterator &operator++() {
    NodePtr = Traits::getNext(NodePtr);
    return *this;
  }
  ilist_iterator operator--(int) {
    ilist_iterator tmp = *this;
    --*this;
    return tmp;
  }
  ilist_iterator operator++(int) {
    ilist_iterator tmp = *this;
    ++*this;
    return tmp;
  }


  pointer getNodePtrUnchecked() const { return NodePtr; }
};



template<typename T>
void operator-(int, ilist_iterator<T>);
template<typename T>
void operator-(ilist_iterator<T>,int);

template<typename T>
void operator+(int, ilist_iterator<T>);
template<typename T>
void operator+(ilist_iterator<T>,int);



template<typename T>
bool operator!=(const T* LHS, const ilist_iterator<const T> &RHS) {
  return LHS != RHS.getNodePtrUnchecked();
}
template<typename T>
bool operator==(const T* LHS, const ilist_iterator<const T> &RHS) {
  return LHS == RHS.getNodePtrUnchecked();
}
template<typename T>
bool operator!=(T* LHS, const ilist_iterator<T> &RHS) {
  return LHS != RHS.getNodePtrUnchecked();
}
template<typename T>
bool operator==(T* LHS, const ilist_iterator<T> &RHS) {
  return LHS == RHS.getNodePtrUnchecked();
}





template<typename From> struct simplify_type;

template<typename NodeTy> struct simplify_type<ilist_iterator<NodeTy> > {
  typedef NodeTy* SimpleType;

  static SimpleType getSimplifiedValue(const ilist_iterator<NodeTy> &Node) {
    return &*Node;
  }
};
template<typename NodeTy> struct simplify_type<const ilist_iterator<NodeTy> > {
  typedef NodeTy* SimpleType;

  static SimpleType getSimplifiedValue(const ilist_iterator<NodeTy> &Node) {
    return &*Node;
  }
};
# 309 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h"
template<typename NodeTy, typename Traits=ilist_traits<NodeTy> >
class iplist : public Traits {
  mutable NodeTy *Head;





  NodeTy *getTail() { return this->ensureHead(Head); }
  const NodeTy *getTail() const { return this->ensureHead(Head); }
  void setTail(NodeTy *N) const { this->noteHead(Head, N); }



  void CreateLazySentinel() const {
    this->ensureHead(Head);
  }

  static bool op_less(NodeTy &L, NodeTy &R) { return L < R; }
  static bool op_equal(NodeTy &L, NodeTy &R) { return L == R; }



  iplist(const iplist &);
  void operator=(const iplist &);

public:
  typedef NodeTy *pointer;
  typedef const NodeTy *const_pointer;
  typedef NodeTy &reference;
  typedef const NodeTy &const_reference;
  typedef NodeTy value_type;
  typedef ilist_iterator<NodeTy> iterator;
  typedef ilist_iterator<const NodeTy> const_iterator;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;

  iplist() : Head(this->provideInitialHead()) {}
  ~iplist() {
    if (!Head) return;
    clear();
    Traits::destroySentinel(getTail());
  }


  iterator begin() {
    CreateLazySentinel();
    return iterator(Head);
  }
  const_iterator begin() const {
    CreateLazySentinel();
    return const_iterator(Head);
  }
  iterator end() {
    CreateLazySentinel();
    return iterator(getTail());
  }
  const_iterator end() const {
    CreateLazySentinel();
    return const_iterator(getTail());
  }


  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const { return const_reverse_iterator(begin());}



  size_type max_size() const { return size_type(-1); }
  bool empty() const { return Head == 0 || Head == getTail(); }


  reference front() {
    ((!empty() && "Called front() on empty list!") ? static_cast<void> (0) : __assert_fail ("!empty() && \"Called front() on empty list!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h", 386, __PRETTY_FUNCTION__));
    return *Head;
  }
  const_reference front() const {
    ((!empty() && "Called front() on empty list!") ? static_cast<void> (0) : __assert_fail ("!empty() && \"Called front() on empty list!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h", 390, __PRETTY_FUNCTION__));
    return *Head;
  }
  reference back() {
    ((!empty() && "Called back() on empty list!") ? static_cast<void> (0) : __assert_fail ("!empty() && \"Called back() on empty list!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h", 394, __PRETTY_FUNCTION__));
    return *this->getPrev(getTail());
  }
  const_reference back() const {
    ((!empty() && "Called back() on empty list!") ? static_cast<void> (0) : __assert_fail ("!empty() && \"Called back() on empty list!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h", 398, __PRETTY_FUNCTION__));
    return *this->getPrev(getTail());
  }

  void swap(iplist &RHS) {
    ((0 && "Swap does not use list traits callback correctly yet!") ? static_cast<void> (0) : __assert_fail ("0 && \"Swap does not use list traits callback correctly yet!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h", 403, __PRETTY_FUNCTION__));
    std::swap(Head, RHS.Head);
  }

  iterator insert(iterator where, NodeTy *New) {
    NodeTy *CurNode = where.getNodePtrUnchecked();
    NodeTy *PrevNode = this->getPrev(CurNode);
    this->setNext(New, CurNode);
    this->setPrev(New, PrevNode);

    if (CurNode != Head)
      this->setNext(PrevNode, New);
    else
      Head = New;
    this->setPrev(CurNode, New);

    this->addNodeToList(New);
    return New;
  }

  iterator insertAfter(iterator where, NodeTy *New) {
    if (empty())
      return insert(begin(), New);
    else
      return insert(++where, New);
  }

  NodeTy *remove(iterator &IT) {
    ((IT != end() && "Cannot remove end of list!") ? static_cast<void> (0) : __assert_fail ("IT != end() && \"Cannot remove end of list!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h", 431, __PRETTY_FUNCTION__));
    NodeTy *Node = &*IT;
    NodeTy *NextNode = this->getNext(Node);
    NodeTy *PrevNode = this->getPrev(Node);

    if (Node != Head)
      this->setNext(PrevNode, NextNode);
    else
      Head = NextNode;
    this->setPrev(NextNode, PrevNode);
    IT = NextNode;
    this->removeNodeFromList(Node);






    this->setNext(Node, 0);
    this->setPrev(Node, 0);
    return Node;
  }

  NodeTy *remove(const iterator &IT) {
    iterator MutIt = IT;
    return remove(MutIt);
  }


  iterator erase(iterator where) {
    this->deleteNode(remove(where));
    return where;
  }


private:



  void transfer(iterator position, iplist &L2, iterator first, iterator last) {
    ((first != last && "Should be checked by callers") ? static_cast<void> (0) : __assert_fail ("first != last && \"Should be checked by callers\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h", 471, __PRETTY_FUNCTION__));

    if (position != last) {


      NodeTy *ThisSentinel = getTail();
      setTail(0);
      NodeTy *L2Sentinel = L2.getTail();
      L2.setTail(0);


      NodeTy *First = &*first, *Prev = this->getPrev(First);
      NodeTy *Next = last.getNodePtrUnchecked(), *Last = this->getPrev(Next);
      if (Prev)
        this->setNext(Prev, Next);
      else
        L2.Head = Next;
      this->setPrev(Next, Prev);


      NodeTy *PosNext = position.getNodePtrUnchecked();
      NodeTy *PosPrev = this->getPrev(PosNext);


      if (PosPrev)
        this->setNext(PosPrev, First);
      else
        Head = First;
      this->setPrev(First, PosPrev);


      this->setNext(Last, PosNext);
      this->setPrev(PosNext, Last);

      this->transferNodesFromList(L2, First, PosNext);


      L2.setTail(L2Sentinel);
      setTail(ThisSentinel);
    }
  }

public:





  size_type size() const {
    if (Head == 0) return 0;
    return std::distance(begin(), end());
  }

  iterator erase(iterator first, iterator last) {
    while (first != last)
      first = erase(first);
    return last;
  }

  void clear() { if (Head) erase(begin(), end()); }


  void push_front(NodeTy *val) { insert(begin(), val); }
  void push_back(NodeTy *val) { insert(end(), val); }
  void pop_front() {
    ((!empty() && "pop_front() on empty list!") ? static_cast<void> (0) : __assert_fail ("!empty() && \"pop_front() on empty list!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h", 536, __PRETTY_FUNCTION__));
    erase(begin());
  }
  void pop_back() {
    ((!empty() && "pop_back() on empty list!") ? static_cast<void> (0) : __assert_fail ("!empty() && \"pop_back() on empty list!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h", 540, __PRETTY_FUNCTION__));
    iterator t = end(); erase(--t);
  }


  template<class InIt> void insert(iterator where, InIt first, InIt last) {
    for (; first != last; ++first) insert(where, *first);
  }


  void splice(iterator where, iplist &L2) {
    if (!L2.empty())
      transfer(where, L2, L2.begin(), L2.end());
  }
  void splice(iterator where, iplist &L2, iterator first) {
    iterator last = first; ++last;
    if (where == first || where == last) return;
    transfer(where, L2, first, last);
  }
  void splice(iterator where, iplist &L2, iterator first, iterator last) {
    if (first != last) transfer(where, L2, first, last);
  }
# 572 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/ilist.h"
  void erase(const NodeTy &val) {
    for (iterator I = begin(), E = end(); I != E; ) {
      iterator next = I; ++next;
      if (*I == val) erase(I);
      I = next;
    }
  }
  template<class Pr1> void erase_if(Pr1 pred) {
    for (iterator I = begin(), E = end(); I != E; ) {
      iterator next = I; ++next;
      if (pred(*I)) erase(I);
      I = next;
    }
  }

  template<class Pr2> void unique(Pr2 pred) {
    if (empty()) return;
    for (iterator I = begin(), E = end(), Next = begin(); ++Next != E;) {
      if (pred(*I))
        erase(Next);
      else
        I = Next;
      Next = I;
    }
  }
  void unique() { unique(op_equal); }

  template<class Pr3> void merge(iplist &right, Pr3 pred) {
    iterator first1 = begin(), last1 = end();
    iterator first2 = right.begin(), last2 = right.end();
    while (first1 != last1 && first2 != last2)
      if (pred(*first2, *first1)) {
        iterator next = first2;
        transfer(first1, right, first2, ++next);
        first2 = next;
      } else {
        ++first1;
      }
    if (first2 != last2) transfer(last1, right, first2, last2);
  }
  void merge(iplist &right) { return merge(right, op_less); }

  template<class Pr3> void sort(Pr3 pred);
  void sort() { sort(op_less); }
  void reverse();
};


template<typename NodeTy>
struct ilist : public iplist<NodeTy> {
  typedef typename iplist<NodeTy>::size_type size_type;
  typedef typename iplist<NodeTy>::iterator iterator;

  ilist() {}
  ilist(const ilist &right) {
    insert(this->begin(), right.begin(), right.end());
  }
  explicit ilist(size_type count) {
    insert(this->begin(), count, NodeTy());
  }
  ilist(size_type count, const NodeTy &val) {
    insert(this->begin(), count, val);
  }
  template<class InIt> ilist(InIt first, InIt last) {
    insert(this->begin(), first, last);
  }


  using iplist<NodeTy>::insert;
  using iplist<NodeTy>::push_front;
  using iplist<NodeTy>::push_back;


  iterator insert(iterator where, const NodeTy &val) {
    return insert(where, this->createNode(val));
  }



  void push_front(const NodeTy &val) { insert(this->begin(), val); }
  void push_back(const NodeTy &val) { insert(this->end(), val); }


  template<class InIt> void insert(iterator where, InIt first, InIt last) {
    for (; first != last; ++first) insert(where, *first);
  }
  void insert(iterator where, size_type count, const NodeTy &val) {
    for (; count != 0; --count) insert(where, val);
  }


  void assign(size_type count, const NodeTy &val) {
    iterator I = this->begin();
    for (; I != this->end() && count != 0; ++I, --count)
      *I = val;
    if (count != 0)
      insert(this->end(), val, val);
    else
      erase(I, this->end());
  }
  template<class InIt> void assign(InIt first1, InIt last1) {
    iterator first2 = this->begin(), last2 = this->end();
    for ( ; first1 != last1 && first2 != last2; ++first1, ++first2)
      *first1 = *first2;
    if (first2 == last2)
      erase(first1, last1);
    else
      insert(last1, first2, last2);
  }



  void resize(size_type newsize, NodeTy val) {
    iterator i = this->begin();
    size_type len = 0;
    for ( ; i != this->end() && len < newsize; ++i, ++len) ;

    if (len == newsize)
      erase(i, this->end());
    else
      insert(this->end(), newsize - len, val);
  }
  void resize(size_type newsize) { resize(newsize, NodeTy()); }
};

}

namespace std {

  template<class Ty>
  void swap(llvm::iplist<Ty> &Left, llvm::iplist<Ty> &Right) {
    Left.swap(Right);
  }
}
# 29 "/local/monniaux/packages/llvm-2.7/include/llvm/SymbolTableListTraits.h" 2

namespace llvm {
class ValueSymbolTable;

template<typename NodeTy> class ilist_iterator;
template<typename NodeTy, typename Traits> class iplist;
template<typename Ty> struct ilist_traits;




template<typename ValueSubClass, typename ItemParentClass>
class SymbolTableListTraits : public ilist_default_traits<ValueSubClass> {
  typedef ilist_traits<ValueSubClass> TraitsClass;
public:
  SymbolTableListTraits() {}



  ItemParentClass *getListOwner() {
    typedef iplist<ValueSubClass> ItemParentClass::*Sublist;
    Sublist Sub(ItemParentClass::
                getSublistAccess(static_cast<ValueSubClass*>(0)));
    size_t Offset(size_t(&((ItemParentClass*)0->*Sub)));
    iplist<ValueSubClass>* Anchor(static_cast<iplist<ValueSubClass>*>(this));
    return reinterpret_cast<ItemParentClass*>(reinterpret_cast<char*>(Anchor)-
                                              Offset);
  }

  static iplist<ValueSubClass> &getList(ItemParentClass *Par) {
    return Par->*(Par->getSublistAccess((ValueSubClass*)0));
  }

  static ValueSymbolTable *getSymTab(ItemParentClass *Par) {
    return Par ? toPtr(Par->getValueSymbolTable()) : 0;
  }

  void addNodeToList(ValueSubClass *V);
  void removeNodeFromList(ValueSubClass *V);
  void transferNodesFromList(ilist_traits<ValueSubClass> &L2,
                             ilist_iterator<ValueSubClass> first,
                             ilist_iterator<ValueSubClass> last);

  template<typename TPtr>
  void setSymTabObject(TPtr *, TPtr);
  static ValueSymbolTable *toPtr(ValueSymbolTable *P) { return P; }
  static ValueSymbolTable *toPtr(ValueSymbolTable &R) { return &R; }
};

}
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/BasicBlock.h" 2

# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h" 1
# 15 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h"
# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 16 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h" 2


namespace llvm {
  template <typename T>
  class SmallVectorImpl;
  class StringRef;
  class raw_ostream;
# 80 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h"
  class Twine {

    enum NodeKind {


      NullKind,


      EmptyKind,


      TwineKind,


      CStringKind,


      StdStringKind,


      StringRefKind,



      DecUIKind,


      DecIKind,



      DecULKind,


      DecLKind,



      DecULLKind,


      DecLLKind,



      UHexKind
    };

  private:


    const void *LHS;


    const void *RHS;

    unsigned char LHSKind;

    unsigned char RHSKind;

  private:

    explicit Twine(NodeKind Kind)
      : LHSKind(Kind), RHSKind(EmptyKind) {
      ((isNullary() && "Invalid kind!") ? static_cast<void> (0) : __assert_fail ("isNullary() && \"Invalid kind!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h", 144, __PRETTY_FUNCTION__));
    }


    explicit Twine(const Twine &_LHS, const Twine &_RHS)
      : LHS(&_LHS), RHS(&_RHS), LHSKind(TwineKind), RHSKind(TwineKind) {
      ((isValid() && "Invalid twine!") ? static_cast<void> (0) : __assert_fail ("isValid() && \"Invalid twine!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h", 150, __PRETTY_FUNCTION__));
    }


    explicit Twine(const void *_LHS, NodeKind _LHSKind,
                   const void *_RHS, NodeKind _RHSKind)
      : LHS(_LHS), RHS(_RHS), LHSKind(_LHSKind), RHSKind(_RHSKind) {
      ((isValid() && "Invalid twine!") ? static_cast<void> (0) : __assert_fail ("isValid() && \"Invalid twine!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h", 157, __PRETTY_FUNCTION__));
    }


    bool isNull() const {
      return getLHSKind() == NullKind;
    }


    bool isEmpty() const {
      return getLHSKind() == EmptyKind;
    }


    bool isNullary() const {
      return isNull() || isEmpty();
    }


    bool isUnary() const {
      return getRHSKind() == EmptyKind && !isNullary();
    }


    bool isBinary() const {
      return getLHSKind() != NullKind && getRHSKind() != EmptyKind;
    }



    bool isValid() const {

      if (isNullary() && getRHSKind() != EmptyKind)
        return false;


      if (getRHSKind() == NullKind)
        return false;


      if (getRHSKind() != EmptyKind && getLHSKind() == EmptyKind)
        return false;


      if (getLHSKind() == TwineKind &&
          !static_cast<const Twine*>(LHS)->isBinary())
        return false;
      if (getRHSKind() == TwineKind &&
          !static_cast<const Twine*>(RHS)->isBinary())
        return false;

      return true;
    }


    NodeKind getLHSKind() const { return (NodeKind) LHSKind; }


    NodeKind getRHSKind() const { return (NodeKind) RHSKind; }


    void printOneChild(raw_ostream &OS, const void *Ptr, NodeKind Kind) const;


    void printOneChildRepr(raw_ostream &OS, const void *Ptr,
                           NodeKind Kind) const;

  public:




                 Twine() : LHSKind(EmptyKind), RHSKind(EmptyKind) {
      ((isValid() && "Invalid twine!") ? static_cast<void> (0) : __assert_fail ("isValid() && \"Invalid twine!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h", 230, __PRETTY_FUNCTION__));
    }






                 Twine(const char *Str)
      : RHSKind(EmptyKind) {
      if (Str[0] != '\0') {
        LHS = Str;
        LHSKind = CStringKind;
      } else
        LHSKind = EmptyKind;

      ((isValid() && "Invalid twine!") ? static_cast<void> (0) : __assert_fail ("isValid() && \"Invalid twine!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h", 246, __PRETTY_FUNCTION__));
    }


                 Twine(const std::string &Str)
      : LHS(&Str), LHSKind(StdStringKind), RHSKind(EmptyKind) {
      ((isValid() && "Invalid twine!") ? static_cast<void> (0) : __assert_fail ("isValid() && \"Invalid twine!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h", 252, __PRETTY_FUNCTION__));
    }


                 Twine(const StringRef &Str)
      : LHS(&Str), LHSKind(StringRefKind), RHSKind(EmptyKind) {
      ((isValid() && "Invalid twine!") ? static_cast<void> (0) : __assert_fail ("isValid() && \"Invalid twine!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h", 258, __PRETTY_FUNCTION__));
    }


    explicit Twine(const unsigned int &Val)
      : LHS(&Val), LHSKind(DecUIKind), RHSKind(EmptyKind) {
    }


    explicit Twine(const int &Val)
      : LHS(&Val), LHSKind(DecIKind), RHSKind(EmptyKind) {
    }


    explicit Twine(const unsigned long &Val)
      : LHS(&Val), LHSKind(DecULKind), RHSKind(EmptyKind) {
    }


    explicit Twine(const long &Val)
      : LHS(&Val), LHSKind(DecLKind), RHSKind(EmptyKind) {
    }


    explicit Twine(const unsigned long long &Val)
      : LHS(&Val), LHSKind(DecULLKind), RHSKind(EmptyKind) {
    }


    explicit Twine(const long long &Val)
      : LHS(&Val), LHSKind(DecLLKind), RHSKind(EmptyKind) {
    }







                 Twine(const char *_LHS, const StringRef &_RHS)
      : LHS(_LHS), RHS(&_RHS), LHSKind(CStringKind), RHSKind(StringRefKind) {
      ((isValid() && "Invalid twine!") ? static_cast<void> (0) : __assert_fail ("isValid() && \"Invalid twine!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h", 299, __PRETTY_FUNCTION__));
    }


                 Twine(const StringRef &_LHS, const char *_RHS)
      : LHS(&_LHS), RHS(_RHS), LHSKind(StringRefKind), RHSKind(CStringKind) {
      ((isValid() && "Invalid twine!") ? static_cast<void> (0) : __assert_fail ("isValid() && \"Invalid twine!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h", 305, __PRETTY_FUNCTION__));
    }



    static Twine createNull() {
      return Twine(NullKind);
    }






    static Twine utohexstr(const uint64_t &Val) {
      return Twine(&Val, UHexKind, 0, EmptyKind);
    }







    bool isTriviallyEmpty() const {
      return isNullary();
    }



    bool isSingleStringRef() const {
      if (getRHSKind() != EmptyKind) return false;

      switch (getLHSKind()) {
      case EmptyKind:
      case CStringKind:
      case StdStringKind:
      case StringRefKind:
        return true;
      default:
        return false;
      }
    }





    Twine concat(const Twine &Suffix) const;






    std::string str() const;



    void toVector(SmallVectorImpl<char> &Out) const;



    StringRef getSingleStringRef() const {
      ((isSingleStringRef() &&"This cannot be had as a single stringref!") ? static_cast<void> (0) : __assert_fail ("isSingleStringRef() &&\"This cannot be had as a single stringref!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h", 369, __PRETTY_FUNCTION__));
      switch (getLHSKind()) {
      default: ((0 && "Out of sync with isSingleStringRef") ? static_cast<void> (0) : __assert_fail ("0 && \"Out of sync with isSingleStringRef\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Twine.h", 371, __PRETTY_FUNCTION__));
      case EmptyKind: return StringRef();
      case CStringKind: return StringRef((const char*)LHS);
      case StdStringKind: return StringRef(*(const std::string*)LHS);
      case StringRefKind: return *(const StringRef*)LHS;
      }
    }




    StringRef toStringRef(SmallVectorImpl<char> &Out) const;



    void print(raw_ostream &OS) const;


    void dump() const;


    void printRepr(raw_ostream &OS) const;


    void dumpRepr() const;


  };




  inline Twine Twine::concat(const Twine &Suffix) const {

    if (isNull() || Suffix.isNull())
      return Twine(NullKind);


    if (isEmpty())
      return Suffix;
    if (Suffix.isEmpty())
      return *this;



    const void *NewLHS = this, *NewRHS = &Suffix;
    NodeKind NewLHSKind = TwineKind, NewRHSKind = TwineKind;
    if (isUnary()) {
      NewLHS = LHS;
      NewLHSKind = getLHSKind();
    }
    if (Suffix.isUnary()) {
      NewRHS = Suffix.LHS;
      NewRHSKind = Suffix.getLHSKind();
    }

    return Twine(NewLHS, NewLHSKind, NewRHS, NewRHSKind);
  }

  inline Twine operator+(const Twine &LHS, const Twine &RHS) {
    return LHS.concat(RHS);
  }




  inline Twine operator+(const char *LHS, const StringRef &RHS) {
    return Twine(LHS, RHS);
  }




  inline Twine operator+(const StringRef &LHS, const char *RHS) {
    return Twine(LHS, RHS);
  }

  inline raw_ostream &operator<<(raw_ostream &OS, const Twine &RHS) {
    RHS.print(OS);
    return OS;
  }


}
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/BasicBlock.h" 2


namespace llvm {

class TerminatorInst;
class LLVMContext;
class BlockAddress;

template<> struct ilist_traits<Instruction>
  : public SymbolTableListTraits<Instruction, BasicBlock> {




  Instruction *createSentinel() const {
# 44 "/local/monniaux/packages/llvm-2.7/include/llvm/BasicBlock.h"
    return static_cast<Instruction*>(&Sentinel);
  }
  static void destroySentinel(Instruction*) {}

  Instruction *provideInitialHead() const { return createSentinel(); }
  Instruction *ensureHead(Instruction*) const { return createSentinel(); }
  static void noteHead(Instruction*, Instruction*) {}
private:
  mutable ilist_half_node<Instruction> Sentinel;
};
# 69 "/local/monniaux/packages/llvm-2.7/include/llvm/BasicBlock.h"
class BasicBlock : public Value,
                   public ilist_node<BasicBlock> {
  friend class BlockAddress;
public:
  typedef iplist<Instruction> InstListType;
private:
  InstListType InstList;
  Function *Parent;

  void setParent(Function *parent);
  friend class SymbolTableListTraits<BasicBlock, Function>;

  BasicBlock(const BasicBlock &);
  void operator=(const BasicBlock &);





  explicit BasicBlock(LLVMContext &C, const Twine &Name = "",
                      Function *Parent = 0, BasicBlock *InsertBefore = 0);
public:

  LLVMContext &getContext() const;


  typedef InstListType::iterator iterator;
  typedef InstListType::const_iterator const_iterator;




  static BasicBlock *Create(LLVMContext &Context, const Twine &Name = "",
                            Function *Parent = 0,BasicBlock *InsertBefore = 0) {
    return new BasicBlock(Context, Name, Parent, InsertBefore);
  }
  ~BasicBlock();



  const Function *getParent() const { return Parent; }
        Function *getParent() { return Parent; }




  User *use_back() { return cast<User>(*use_begin());}
  const User *use_back() const { return cast<User>(*use_begin());}





  TerminatorInst *getTerminator();
  const TerminatorInst *getTerminator() const;






  Instruction* getFirstNonPHI();
  const Instruction* getFirstNonPHI() const {
    return const_cast<BasicBlock*>(this)->getFirstNonPHI();
  }




  void removeFromParent();




  void eraseFromParent();



  void moveBefore(BasicBlock *MovePos);



  void moveAfter(BasicBlock *MovePos);




  BasicBlock *getSinglePredecessor();
  const BasicBlock *getSinglePredecessor() const {
    return const_cast<BasicBlock*>(this)->getSinglePredecessor();
  }






  BasicBlock *getUniquePredecessor();
  const BasicBlock *getUniquePredecessor() const {
    return const_cast<BasicBlock*>(this)->getUniquePredecessor();
  }




  inline iterator begin() { return InstList.begin(); }
  inline const_iterator begin() const { return InstList.begin(); }
  inline iterator end () { return InstList.end(); }
  inline const_iterator end () const { return InstList.end(); }

  inline size_t size() const { return InstList.size(); }
  inline bool empty() const { return InstList.empty(); }
  inline const Instruction &front() const { return InstList.front(); }
  inline Instruction &front() { return InstList.front(); }
  inline const Instruction &back() const { return InstList.back(); }
  inline Instruction &back() { return InstList.back(); }




  const InstListType &getInstList() const { return InstList; }
        InstListType &getInstList() { return InstList; }


  static iplist<Instruction> BasicBlock::*getSublistAccess(Instruction*) {
    return &BasicBlock::InstList;
  }


  ValueSymbolTable *getValueSymbolTable();


  static inline bool classof(const BasicBlock *) { return true; }
  static inline bool classof(const Value *V) {
    return V->getValueID() == Value::BasicBlockVal;
  }
# 214 "/local/monniaux/packages/llvm-2.7/include/llvm/BasicBlock.h"
  void dropAllReferences();







  void removePredecessor(BasicBlock *Pred, bool DontDeleteUselessPHIs = false);
# 239 "/local/monniaux/packages/llvm-2.7/include/llvm/BasicBlock.h"
  BasicBlock *splitBasicBlock(iterator I, const Twine &BBName = "");



  bool hasAddressTaken() const { return getSubclassDataFromValue() != 0; }

private:



  void AdjustBlockAddressRefCount(int Amt) {
    setValueSubclassData(getSubclassDataFromValue()+Amt);
    (((int)(signed char)getSubclassDataFromValue() >= 0 && "Refcount wrap-around") ? static_cast<void> (0) : __assert_fail ("(int)(signed char)getSubclassDataFromValue() >= 0 && \"Refcount wrap-around\"", "/local/monniaux/packages/llvm-2.7/include/llvm/BasicBlock.h", 252, __PRETTY_FUNCTION__));

  }


  void setValueSubclassData(unsigned short D) {
    Value::setValueSubclassData(D);
  }
};

}
# 24 "/local/monniaux/packages/llvm-2.7/include/llvm/Function.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Argument.h" 1
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/Argument.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Attributes.h" 1
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/Attributes.h"
# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/Attributes.h" 2


namespace llvm {
class Type;


typedef unsigned Attributes;

namespace Attribute {







const Attributes None = 0;
const Attributes ZExt = 1<<0;
const Attributes SExt = 1<<1;
const Attributes NoReturn = 1<<2;
const Attributes InReg = 1<<3;
const Attributes StructRet = 1<<4;
const Attributes NoUnwind = 1<<5;
const Attributes NoAlias = 1<<6;
const Attributes ByVal = 1<<7;
const Attributes Nest = 1<<8;
const Attributes ReadNone = 1<<9;
const Attributes ReadOnly = 1<<10;
const Attributes NoInline = 1<<11;
const Attributes AlwaysInline = 1<<12;
const Attributes OptimizeForSize = 1<<13;
const Attributes StackProtect = 1<<14;
const Attributes StackProtectReq = 1<<15;
const Attributes Alignment = 31<<16;


const Attributes NoCapture = 1<<21;
const Attributes NoRedZone = 1<<22;
const Attributes NoImplicitFloat = 1<<23;

const Attributes Naked = 1<<24;
const Attributes InlineHint = 1<<25;

const Attributes StackAlignment = 7<<26;






const Attributes ParameterOnly = ByVal | Nest | StructRet | NoCapture;



const Attributes FunctionOnly = NoReturn | NoUnwind | ReadNone | ReadOnly |
  NoInline | AlwaysInline | OptimizeForSize | StackProtect | StackProtectReq |
  NoRedZone | NoImplicitFloat | Naked | InlineHint | StackAlignment;


const Attributes VarArgsIncompatible = StructRet;


const Attributes MutuallyIncompatible[4] = {
  ByVal | InReg | Nest | StructRet,
  ZExt | SExt,
  ReadNone | ReadOnly,
  NoInline | AlwaysInline
};


Attributes typeIncompatible(const Type *Ty);



inline Attributes constructAlignmentFromInt(unsigned i) {

  if (i == 0)
    return 0;

  ((isPowerOf2_32(i) && "Alignment must be a power of two.") ? static_cast<void> (0) : __assert_fail ("isPowerOf2_32(i) && \"Alignment must be a power of two.\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Attributes.h", 99, __PRETTY_FUNCTION__));
  ((i <= 0x40000000 && "Alignment too large.") ? static_cast<void> (0) : __assert_fail ("i <= 0x40000000 && \"Alignment too large.\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Attributes.h", 100, __PRETTY_FUNCTION__));
  return (Log2_32(i)+1) << 16;
}


inline unsigned getAlignmentFromAttrs(Attributes A) {
  Attributes Align = A & Attribute::Alignment;
  if (Align == 0)
    return 0;

  return 1U << ((Align >> 16) - 1);
}



inline Attributes constructStackAlignmentFromInt(unsigned i) {

  if (i == 0)
    return 0;

  ((isPowerOf2_32(i) && "Alignment must be a power of two.") ? static_cast<void> (0) : __assert_fail ("isPowerOf2_32(i) && \"Alignment must be a power of two.\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Attributes.h", 120, __PRETTY_FUNCTION__));
  ((i <= 0x100 && "Alignment too large.") ? static_cast<void> (0) : __assert_fail ("i <= 0x100 && \"Alignment too large.\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Attributes.h", 121, __PRETTY_FUNCTION__));
  return (Log2_32(i)+1) << 26;
}



inline unsigned getStackAlignmentFromAttrs(Attributes A) {
  Attributes StackAlign = A & Attribute::StackAlignment;
  if (StackAlign == 0)
    return 0;

  return 1U << ((StackAlign >> 26) - 1);
}






std::string getAsString(Attributes Attrs);
}



struct AttributeWithIndex {
  Attributes Attrs;
  unsigned Index;



  static AttributeWithIndex get(unsigned Idx, Attributes Attrs) {
    AttributeWithIndex P;
    P.Index = Idx;
    P.Attrs = Attrs;
    return P;
  }
};





class AttributeListImpl;



class AttrListPtr {


  AttributeListImpl *AttrList;
public:
  AttrListPtr() : AttrList(0) {}
  AttrListPtr(const AttrListPtr &P);
  const AttrListPtr &operator=(const AttrListPtr &RHS);
  ~AttrListPtr();






  static AttrListPtr get(const AttributeWithIndex *Attr, unsigned NumAttrs);



  template <typename Iter>
  static AttrListPtr get(const Iter &I, const Iter &E) {
    if (I == E) return AttrListPtr();
    return get(&*I, static_cast<unsigned>(E-I));
  }




  AttrListPtr addAttr(unsigned Idx, Attributes Attrs) const;




  AttrListPtr removeAttr(unsigned Idx, Attributes Attrs) const;






  Attributes getParamAttributes(unsigned Idx) const {
    ((Idx && Idx != ~0U && "Invalid parameter index!") ? static_cast<void> (0) : __assert_fail ("Idx && Idx != ~0U && \"Invalid parameter index!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Attributes.h", 208, __PRETTY_FUNCTION__));
    return getAttributes(Idx);
  }



  Attributes getRetAttributes() const {
    return getAttributes(0);
  }


  Attributes getFnAttributes() const {
    return getAttributes(~0U);
  }



  bool paramHasAttr(unsigned Idx, Attributes Attr) const {
    return getAttributes(Idx) & Attr;
  }



  unsigned getParamAlignment(unsigned Idx) const {
    return Attribute::getAlignmentFromAttrs(getAttributes(Idx));
  }



  bool hasAttrSomewhere(Attributes Attr) const;


  bool operator==(const AttrListPtr &RHS) const
  { return AttrList == RHS.AttrList; }
  bool operator!=(const AttrListPtr &RHS) const
  { return AttrList != RHS.AttrList; }

  void dump() const;







  void *getRawPointer() const {
    return AttrList;
  }







  bool isEmpty() const {
    return AttrList == 0;
  }




  unsigned getNumSlots() const;



  const AttributeWithIndex &getSlot(unsigned Slot) const;

private:
  explicit AttrListPtr(AttributeListImpl *L);



  Attributes getAttributes(unsigned Idx) const;

};

}
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/Argument.h" 2



namespace llvm {

template<typename ValueSubClass, typename ItemParentClass>
  class SymbolTableListTraits;






class Argument : public Value, public ilist_node<Argument> {
  Function *Parent;

  friend class SymbolTableListTraits<Argument, Function>;
  void setParent(Function *parent);

public:



  explicit Argument(const Type *Ty, const Twine &Name = "", Function *F = 0);

  inline const Function *getParent() const { return Parent; }
  inline Function *getParent() { return Parent; }



  unsigned getArgNo() const;



  bool hasByValAttr() const;



  bool hasNestAttr() const;



  bool hasNoAliasAttr() const;



  bool hasNoCaptureAttr() const;



  bool hasStructRetAttr() const;


  void addAttr(Attributes);


  void removeAttr(Attributes);




  static inline bool classof(const Argument *) { return true; }
  static inline bool classof(const Value *V) {
    return V->getValueID() == ArgumentVal;
  }
};

}
# 25 "/local/monniaux/packages/llvm-2.7/include/llvm/Function.h" 2

# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Compiler.h" 1
# 27 "/local/monniaux/packages/llvm-2.7/include/llvm/Function.h" 2

namespace llvm {

class FunctionType;
class LLVMContext;


template<> struct ilist_traits<BasicBlock>
  : public SymbolTableListTraits<BasicBlock, Function> {



  BasicBlock *createSentinel() const {
    return static_cast<BasicBlock*>(&Sentinel);
  }
  static void destroySentinel(BasicBlock*) {}

  BasicBlock *provideInitialHead() const { return createSentinel(); }
  BasicBlock *ensureHead(BasicBlock*) const { return createSentinel(); }
  static void noteHead(BasicBlock*, BasicBlock*) {}

  static ValueSymbolTable *getSymTab(Function *ItemParent);
private:
  mutable ilist_half_node<BasicBlock> Sentinel;
};

template<> struct ilist_traits<Argument>
  : public SymbolTableListTraits<Argument, Function> {

  Argument *createSentinel() const {
    return static_cast<Argument*>(&Sentinel);
  }
  static void destroySentinel(Argument*) {}

  Argument *provideInitialHead() const { return createSentinel(); }
  Argument *ensureHead(Argument*) const { return createSentinel(); }
  static void noteHead(Argument*, Argument*) {}

  static ValueSymbolTable *getSymTab(Function *ItemParent);
private:
  mutable ilist_half_node<Argument> Sentinel;
};

class Function : public GlobalValue,
                 public ilist_node<Function> {
public:
  typedef iplist<Argument> ArgumentListType;
  typedef iplist<BasicBlock> BasicBlockListType;


  typedef BasicBlockListType::iterator iterator;
  typedef BasicBlockListType::const_iterator const_iterator;

  typedef ArgumentListType::iterator arg_iterator;
  typedef ArgumentListType::const_iterator const_arg_iterator;

private:

  BasicBlockListType BasicBlocks;
  mutable ArgumentListType ArgumentList;
  ValueSymbolTable *SymTab;
  AttrListPtr AttributeList;







  friend class SymbolTableListTraits<Function, Module>;

  void setParent(Module *parent);





  bool hasLazyArguments() const {
    return getSubclassDataFromValue() & 1;
  }
  void CheckLazyArguments() const {
    if (hasLazyArguments())
      BuildLazyArguments();
  }
  void BuildLazyArguments() const;

  Function(const Function&);
  void operator=(const Function&);





  Function(const FunctionType *Ty, LinkageTypes Linkage,
           const Twine &N = "", Module *M = 0);

public:
  static Function *Create(const FunctionType *Ty, LinkageTypes Linkage,
                          const Twine &N = "", Module *M = 0) {
    return new(0) Function(Ty, Linkage, N, M);
  }

  ~Function();

  const Type *getReturnType() const;
  const FunctionType *getFunctionType() const;



  LLVMContext &getContext() const;



  bool isVarArg() const;





  virtual bool isDeclaration() const { return BasicBlocks.empty(); }
# 155 "/local/monniaux/packages/llvm-2.7/include/llvm/Function.h"
  unsigned getIntrinsicID() const __attribute__((__pure__));
  bool isIntrinsic() const { return getIntrinsicID() != 0; }




  CallingConv::ID getCallingConv() const {
    return static_cast<CallingConv::ID>(getSubclassDataFromValue() >> 1);
  }
  void setCallingConv(CallingConv::ID CC) {
    setValueSubclassData((getSubclassDataFromValue() & 1) |
                         (static_cast<unsigned>(CC) << 1));
  }



  const AttrListPtr &getAttributes() const { return AttributeList; }



  void setAttributes(const AttrListPtr &attrs) { AttributeList = attrs; }


  bool hasFnAttr(Attributes N) const {

    return AttributeList.paramHasAttr(~0U, N);
  }



  void addFnAttr(Attributes N) {

    addAttribute(~0U, N);
  }



  void removeFnAttr(Attributes N) {

    removeAttribute(~0U, N);
  }



  bool hasGC() const;
  const char *getGC() const;
  void setGC(const char *Str);
  void clearGC();


  bool paramHasAttr(unsigned i, Attributes attr) const {
    return AttributeList.paramHasAttr(i, attr);
  }


  void addAttribute(unsigned i, Attributes attr);


  void removeAttribute(unsigned i, Attributes attr);


  unsigned getParamAlignment(unsigned i) const {
    return AttributeList.getParamAlignment(i);
  }


  bool doesNotAccessMemory() const {
    return hasFnAttr(Attribute::ReadNone);
  }
  void setDoesNotAccessMemory(bool DoesNotAccessMemory = true) {
    if (DoesNotAccessMemory) addFnAttr(Attribute::ReadNone);
    else removeFnAttr(Attribute::ReadNone);
  }


  bool onlyReadsMemory() const {
    return doesNotAccessMemory() || hasFnAttr(Attribute::ReadOnly);
  }
  void setOnlyReadsMemory(bool OnlyReadsMemory = true) {
    if (OnlyReadsMemory) addFnAttr(Attribute::ReadOnly);
    else removeFnAttr(Attribute::ReadOnly | Attribute::ReadNone);
  }


  bool doesNotReturn() const {
    return hasFnAttr(Attribute::NoReturn);
  }
  void setDoesNotReturn(bool DoesNotReturn = true) {
    if (DoesNotReturn) addFnAttr(Attribute::NoReturn);
    else removeFnAttr(Attribute::NoReturn);
  }


  bool doesNotThrow() const {
    return hasFnAttr(Attribute::NoUnwind);
  }
  void setDoesNotThrow(bool DoesNotThrow = true) {
    if (DoesNotThrow) addFnAttr(Attribute::NoUnwind);
    else removeFnAttr(Attribute::NoUnwind);
  }



  bool hasStructRetAttr() const {
    return paramHasAttr(1, Attribute::StructRet);
  }



  bool doesNotAlias(unsigned n) const {
    return paramHasAttr(n, Attribute::NoAlias);
  }
  void setDoesNotAlias(unsigned n, bool DoesNotAlias = true) {
    if (DoesNotAlias) addAttribute(n, Attribute::NoAlias);
    else removeAttribute(n, Attribute::NoAlias);
  }



  bool doesNotCapture(unsigned n) const {
    return paramHasAttr(n, Attribute::NoCapture);
  }
  void setDoesNotCapture(unsigned n, bool DoesNotCapture = true) {
    if (DoesNotCapture) addAttribute(n, Attribute::NoCapture);
    else removeAttribute(n, Attribute::NoCapture);
  }



  void copyAttributesFrom(const GlobalValue *Src);




  void deleteBody() {
    dropAllReferences();
    setLinkage(ExternalLinkage);
  }




  virtual void removeFromParent();




  virtual void eraseFromParent();





  const ArgumentListType &getArgumentList() const {
    CheckLazyArguments();
    return ArgumentList;
  }
  ArgumentListType &getArgumentList() {
    CheckLazyArguments();
    return ArgumentList;
  }
  static iplist<Argument> Function::*getSublistAccess(Argument*) {
    return &Function::ArgumentList;
  }

  const BasicBlockListType &getBasicBlockList() const { return BasicBlocks; }
        BasicBlockListType &getBasicBlockList() { return BasicBlocks; }
  static iplist<BasicBlock> Function::*getSublistAccess(BasicBlock*) {
    return &Function::BasicBlocks;
  }

  const BasicBlock &getEntryBlock() const { return front(); }
        BasicBlock &getEntryBlock() { return front(); }






  inline ValueSymbolTable &getValueSymbolTable() { return *SymTab; }
  inline const ValueSymbolTable &getValueSymbolTable() const { return *SymTab; }





  iterator begin() { return BasicBlocks.begin(); }
  const_iterator begin() const { return BasicBlocks.begin(); }
  iterator end () { return BasicBlocks.end(); }
  const_iterator end () const { return BasicBlocks.end(); }

  size_t size() const { return BasicBlocks.size(); }
  bool empty() const { return BasicBlocks.empty(); }
  const BasicBlock &front() const { return BasicBlocks.front(); }
        BasicBlock &front() { return BasicBlocks.front(); }
  const BasicBlock &back() const { return BasicBlocks.back(); }
        BasicBlock &back() { return BasicBlocks.back(); }




  arg_iterator arg_begin() {
    CheckLazyArguments();
    return ArgumentList.begin();
  }
  const_arg_iterator arg_begin() const {
    CheckLazyArguments();
    return ArgumentList.begin();
  }
  arg_iterator arg_end() {
    CheckLazyArguments();
    return ArgumentList.end();
  }
  const_arg_iterator arg_end() const {
    CheckLazyArguments();
    return ArgumentList.end();
  }

  size_t arg_size() const;
  bool arg_empty() const;







  void viewCFG() const;






  void viewCFGOnly() const;


  static inline bool classof(const Function *) { return true; }
  static inline bool classof(const Value *V) {
    return V->getValueID() == Value::FunctionVal;
  }
# 409 "/local/monniaux/packages/llvm-2.7/include/llvm/Function.h"
  void dropAllReferences();



  bool hasAddressTaken() const;
private:


  void setValueSubclassData(unsigned short D) {
    Value::setValueSubclassData(D);
  }
};

inline ValueSymbolTable *
ilist_traits<BasicBlock>::getSymTab(Function *F) {
  return F ? &F->getValueSymbolTable() : 0;
}

inline ValueSymbolTable *
ilist_traits<Argument>::getSymTab(Function *F) {
  return F ? &F->getValueSymbolTable() : 0;
}

}
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalVariable.h" 1
# 28 "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalVariable.h"
namespace llvm {

class Module;
class Constant;
template<typename ValueSubClass, typename ItemParentClass>
  class SymbolTableListTraits;

class GlobalVariable : public GlobalValue, public ilist_node<GlobalVariable> {
  friend class SymbolTableListTraits<GlobalVariable, Module>;
  void *operator new(size_t, unsigned);
  void operator=(const GlobalVariable &);
  GlobalVariable(const GlobalVariable &);

  void setParent(Module *parent);

  bool isConstantGlobal : 1;
  bool isThreadLocalSymbol : 1;

public:

  void *operator new(size_t s) {
    return User::operator new(s, 1);
  }


  GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes Linkage,
                 Constant *Initializer = 0, const Twine &Name = "",
                 bool ThreadLocal = false, unsigned AddressSpace = 0);


  GlobalVariable(Module &M, const Type *Ty, bool isConstant,
                 LinkageTypes Linkage, Constant *Initializer,
                 const Twine &Name,
                 GlobalVariable *InsertBefore = 0, bool ThreadLocal = false,
                 unsigned AddressSpace = 0);

  ~GlobalVariable() {
    NumOperands = 1;
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;




  virtual bool isDeclaration() const { return getNumOperands() == 0; }





  inline bool hasInitializer() const { return !isDeclaration(); }



  inline bool hasDefinitiveInitializer() const {
    return hasInitializer() &&


      !mayBeOverridden();
  }





  inline Constant *getInitializer() const {
    ((hasInitializer() && "GV doesn't have initializer!") ? static_cast<void> (0) : __assert_fail ("hasInitializer() && \"GV doesn't have initializer!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalVariable.h", 96, __PRETTY_FUNCTION__));
    return static_cast<Constant*>(Op<0>().get());
  }
  inline Constant *getInitializer() {
    ((hasInitializer() && "GV doesn't have initializer!") ? static_cast<void> (0) : __assert_fail ("hasInitializer() && \"GV doesn't have initializer!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalVariable.h", 100, __PRETTY_FUNCTION__));
    return static_cast<Constant*>(Op<0>().get());
  }



  void setInitializer(Constant *InitVal);





  bool isConstant() const { return isConstantGlobal; }
  void setConstant(bool Val) { isConstantGlobal = Val; }


  bool isThreadLocal() const { return isThreadLocalSymbol; }
  void setThreadLocal(bool Val) { isThreadLocalSymbol = Val; }



  void copyAttributesFrom(const GlobalValue *Src);




  virtual void removeFromParent();




  virtual void eraseFromParent();



  virtual void replaceUsesOfWithOnConstant(Value *From, Value *To, Use *U);


  static inline bool classof(const GlobalVariable *) { return true; }
  static inline bool classof(const Value *V) {
    return V->getValueID() == Value::GlobalVariableVal;
  }
};

template <>
struct OperandTraits<GlobalVariable> : public OptionalOperandTraits<> {
};

GlobalVariable::op_iterator GlobalVariable::op_begin() { return OperandTraits<GlobalVariable>::op_begin(this); } GlobalVariable::const_op_iterator GlobalVariable::op_begin() const { return OperandTraits<GlobalVariable>::op_begin(const_cast<GlobalVariable*>(this)); } GlobalVariable::op_iterator GlobalVariable::op_end() { return OperandTraits<GlobalVariable>::op_end(this); } GlobalVariable::const_op_iterator GlobalVariable::op_end() const { return OperandTraits<GlobalVariable>::op_end(const_cast<GlobalVariable*>(this)); } Value *GlobalVariable::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<GlobalVariable>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<GlobalVariable>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalVariable.h", 148, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<GlobalVariable>::op_begin(const_cast<GlobalVariable*>(this))[i_nocapture]); } void GlobalVariable::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<GlobalVariable>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<GlobalVariable>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalVariable.h", 148, __PRETTY_FUNCTION__)); OperandTraits<GlobalVariable>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned GlobalVariable::getNumOperands() const { return OperandTraits<GlobalVariable>::operands(this); } template <int Idx_nocapture> Use &GlobalVariable::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &GlobalVariable::Op() const { return this->OpFrom<Idx_nocapture>(this); }

}
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalAlias.h" 1
# 23 "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalAlias.h"
namespace llvm {

class Module;
class Constant;
template<typename ValueSubClass, typename ItemParentClass>
  class SymbolTableListTraits;

class GlobalAlias : public GlobalValue, public ilist_node<GlobalAlias> {
  friend class SymbolTableListTraits<GlobalAlias, Module>;
  void operator=(const GlobalAlias &);
  GlobalAlias(const GlobalAlias &);

  void setParent(Module *parent);

public:

  void *operator new(size_t s) {
    return User::operator new(s, 1);
  }


  GlobalAlias(const Type *Ty, LinkageTypes Linkage, const Twine &Name = "",
              Constant* Aliasee = 0, Module *Parent = 0);


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;




  virtual bool isDeclaration() const;




  virtual void removeFromParent();




  virtual void eraseFromParent();


  void setAliasee(Constant* GV);
  const Constant* getAliasee() const {
    return cast_or_null<Constant>(getOperand(0));
  }
  Constant* getAliasee() {
    return cast_or_null<Constant>(getOperand(0));
  }


  const GlobalValue* getAliasedGlobal() const;






  const GlobalValue* resolveAliasedGlobal(bool stopOnWeak = true) const;


  static inline bool classof(const GlobalAlias *) { return true; }
  static inline bool classof(const Value *V) {
    return V->getValueID() == Value::GlobalAliasVal;
  }
};

template <>
struct OperandTraits<GlobalAlias> : public FixedNumOperandTraits<1> {
};

GlobalAlias::op_iterator GlobalAlias::op_begin() { return OperandTraits<GlobalAlias>::op_begin(this); } GlobalAlias::const_op_iterator GlobalAlias::op_begin() const { return OperandTraits<GlobalAlias>::op_begin(const_cast<GlobalAlias*>(this)); } GlobalAlias::op_iterator GlobalAlias::op_end() { return OperandTraits<GlobalAlias>::op_end(this); } GlobalAlias::const_op_iterator GlobalAlias::op_end() const { return OperandTraits<GlobalAlias>::op_end(const_cast<GlobalAlias*>(this)); } Value *GlobalAlias::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<GlobalAlias>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<GlobalAlias>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalAlias.h", 95, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<GlobalAlias>::op_begin(const_cast<GlobalAlias*>(this))[i_nocapture]); } void GlobalAlias::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<GlobalAlias>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<GlobalAlias>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/GlobalAlias.h", 95, __PRETTY_FUNCTION__)); OperandTraits<GlobalAlias>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned GlobalAlias::getNumOperands() const { return OperandTraits<GlobalAlias>::operands(this); } template <int Idx_nocapture> Use &GlobalAlias::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &GlobalAlias::Op() const { return this->OpFrom<Idx_nocapture>(this); }

}
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Metadata.h" 1
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/Metadata.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/FoldingSet.h" 1
# 23 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/FoldingSet.h"
namespace llvm {
  class APFloat;
  class APInt;
# 101 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/FoldingSet.h"
class FoldingSetNodeID;
# 110 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/FoldingSet.h"
class FoldingSetImpl {
protected:


  void **Buckets;



  unsigned NumBuckets;



  unsigned NumNodes;

public:
  explicit FoldingSetImpl(unsigned Log2InitSize = 6);
  virtual ~FoldingSetImpl();





  class Node {
  private:

    void *NextInFoldingSetBucket;

  public:

    Node() : NextInFoldingSetBucket(0) {}


    void *getNextInBucket() const { return NextInFoldingSetBucket; }
    void SetNextInBucket(void *N) { NextInFoldingSetBucket = N; }
  };


  void clear();



  bool RemoveNode(Node *N);




  Node *GetOrInsertNode(Node *N);




  Node *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos);




  void InsertNode(Node *N, void *InsertPos);


  unsigned size() const { return NumNodes; }


  bool empty() const { return NumNodes == 0; }

private:



  void GrowHashTable();

protected:



  virtual void GetNodeProfile(FoldingSetNodeID &ID, Node *N) const = 0;
};
# 195 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/FoldingSet.h"
template<typename T> struct FoldingSetTrait {
  static inline void Profile(const T& X, FoldingSetNodeID& ID) { X.Profile(ID);}
  static inline void Profile(T& X, FoldingSetNodeID& ID) { X.Profile(ID); }
};






class FoldingSetNodeID {


  SmallVector<unsigned, 32> Bits;

public:
  FoldingSetNodeID() {}



  unsigned getRawData(unsigned i) const {
    return Bits[i];
  }



  void AddPointer(const void *Ptr);
  void AddInteger(signed I);
  void AddInteger(unsigned I);
  void AddInteger(long I);
  void AddInteger(unsigned long I);
  void AddInteger(long long I);
  void AddInteger(unsigned long long I);
  void AddBoolean(bool B) { AddInteger(B ? 1U : 0U); }
  void AddString(StringRef String);

  template <typename T>
  inline void Add(const T& x) { FoldingSetTrait<T>::Profile(x, *this); }



  inline void clear() { Bits.clear(); }



  unsigned ComputeHash() const;



  bool operator==(const FoldingSetNodeID &RHS) const;
};


typedef FoldingSetImpl::Node FoldingSetNode;
template<class T> class FoldingSetIterator;
template<class T> class FoldingSetBucketIterator;






template<class T> class FoldingSet : public FoldingSetImpl {
private:


  virtual void GetNodeProfile(FoldingSetNodeID &ID, Node *N) const {
    T *TN = static_cast<T *>(N);
    FoldingSetTrait<T>::Profile(*TN,ID);
  }

public:
  explicit FoldingSet(unsigned Log2InitSize = 6)
  : FoldingSetImpl(Log2InitSize)
  {}

  typedef FoldingSetIterator<T> iterator;
  iterator begin() { return iterator(Buckets); }
  iterator end() { return iterator(Buckets+NumBuckets); }

  typedef FoldingSetIterator<const T> const_iterator;
  const_iterator begin() const { return const_iterator(Buckets); }
  const_iterator end() const { return const_iterator(Buckets+NumBuckets); }

  typedef FoldingSetBucketIterator<T> bucket_iterator;

  bucket_iterator bucket_begin(unsigned hash) {
    return bucket_iterator(Buckets + (hash & (NumBuckets-1)));
  }

  bucket_iterator bucket_end(unsigned hash) {
    return bucket_iterator(Buckets + (hash & (NumBuckets-1)), true);
  }




  T *GetOrInsertNode(Node *N) {
    return static_cast<T *>(FoldingSetImpl::GetOrInsertNode(N));
  }




  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {
    return static_cast<T *>(FoldingSetImpl::FindNodeOrInsertPos(ID, InsertPos));
  }
};




class FoldingSetIteratorImpl {
protected:
  FoldingSetNode *NodePtr;
  FoldingSetIteratorImpl(void **Bucket);
  void advance();

public:
  bool operator==(const FoldingSetIteratorImpl &RHS) const {
    return NodePtr == RHS.NodePtr;
  }
  bool operator!=(const FoldingSetIteratorImpl &RHS) const {
    return NodePtr != RHS.NodePtr;
  }
};


template<class T>
class FoldingSetIterator : public FoldingSetIteratorImpl {
public:
  explicit FoldingSetIterator(void **Bucket) : FoldingSetIteratorImpl(Bucket) {}

  T &operator*() const {
    return *static_cast<T*>(NodePtr);
  }

  T *operator->() const {
    return static_cast<T*>(NodePtr);
  }

  inline FoldingSetIterator& operator++() {
    advance();
    return *this;
  }
  FoldingSetIterator operator++(int) {
    FoldingSetIterator tmp = *this; ++*this; return tmp;
  }
};






class FoldingSetBucketIteratorImpl {
protected:
  void *Ptr;

  explicit FoldingSetBucketIteratorImpl(void **Bucket);

  FoldingSetBucketIteratorImpl(void **Bucket, bool)
    : Ptr(Bucket) {}

  void advance() {
    void *Probe = static_cast<FoldingSetNode*>(Ptr)->getNextInBucket();
    uintptr_t x = reinterpret_cast<uintptr_t>(Probe) & ~0x1;
    Ptr = reinterpret_cast<void*>(x);
  }

public:
  bool operator==(const FoldingSetBucketIteratorImpl &RHS) const {
    return Ptr == RHS.Ptr;
  }
  bool operator!=(const FoldingSetBucketIteratorImpl &RHS) const {
    return Ptr != RHS.Ptr;
  }
};


template<class T>
class FoldingSetBucketIterator : public FoldingSetBucketIteratorImpl {
public:
  explicit FoldingSetBucketIterator(void **Bucket) :
    FoldingSetBucketIteratorImpl(Bucket) {}

  FoldingSetBucketIterator(void **Bucket, bool) :
    FoldingSetBucketIteratorImpl(Bucket, true) {}

  T& operator*() const { return *static_cast<T*>(Ptr); }
  T* operator->() const { return static_cast<T*>(Ptr); }

  inline FoldingSetBucketIterator& operator++() {
    advance();
    return *this;
  }
  FoldingSetBucketIterator operator++(int) {
    FoldingSetBucketIterator tmp = *this; ++*this; return tmp;
  }
};




template <typename T>
class FoldingSetNodeWrapper : public FoldingSetNode {
  T data;
public:
  explicit FoldingSetNodeWrapper(const T& x) : data(x) {}
  virtual ~FoldingSetNodeWrapper() {}

  template<typename A1>
  explicit FoldingSetNodeWrapper(const A1& a1)
    : data(a1) {}

  template <typename A1, typename A2>
  explicit FoldingSetNodeWrapper(const A1& a1, const A2& a2)
    : data(a1,a2) {}

  template <typename A1, typename A2, typename A3>
  explicit FoldingSetNodeWrapper(const A1& a1, const A2& a2, const A3& a3)
    : data(a1,a2,a3) {}

  template <typename A1, typename A2, typename A3, typename A4>
  explicit FoldingSetNodeWrapper(const A1& a1, const A2& a2, const A3& a3,
                                 const A4& a4)
    : data(a1,a2,a3,a4) {}

  template <typename A1, typename A2, typename A3, typename A4, typename A5>
  explicit FoldingSetNodeWrapper(const A1& a1, const A2& a2, const A3& a3,
                                 const A4& a4, const A5& a5)
  : data(a1,a2,a3,a4,a5) {}


  void Profile(FoldingSetNodeID& ID) { FoldingSetTrait<T>::Profile(data, ID); }

  T& getValue() { return data; }
  const T& getValue() const { return data; }

  operator T&() { return data; }
  operator const T&() const { return data; }
};







class FastFoldingSetNode : public FoldingSetNode {
  FoldingSetNodeID FastID;
protected:
  explicit FastFoldingSetNode(const FoldingSetNodeID &ID) : FastID(ID) {}
public:
  void Profile(FoldingSetNodeID& ID) { ID = FastID; }
};




template<typename T> struct FoldingSetTrait<T*> {
  static inline void Profile(const T* X, FoldingSetNodeID& ID) {
    ID.AddPointer(X);
  }
  static inline void Profile(T* X, FoldingSetNodeID& ID) {
    ID.AddPointer(X);
  }
};

template<typename T> struct FoldingSetTrait<const T*> {
  static inline void Profile(const T* X, FoldingSetNodeID& ID) {
    ID.AddPointer(X);
  }
};

}
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/Metadata.h" 2


namespace llvm {
class Constant;
class Instruction;
class LLVMContext;
class Module;
template <typename T> class SmallVectorImpl;
template<typename ValueSubClass, typename ItemParentClass>
  class SymbolTableListTraits;






class MDString : public Value {
  MDString(const MDString &);

  StringRef Str;
protected:
  explicit MDString(LLVMContext &C, StringRef S);

public:
  static MDString *get(LLVMContext &Context, StringRef Str);
  static MDString *get(LLVMContext &Context, const char *Str);

  StringRef getString() const { return Str; }

  unsigned getLength() const { return (unsigned)Str.size(); }

  typedef StringRef::iterator iterator;



  iterator begin() const { return Str.begin(); }



  iterator end() const { return Str.end(); }


  static inline bool classof(const MDString *) { return true; }
  static bool classof(const Value *V) {
    return V->getValueID() == MDStringVal;
  }
};


class MDNodeOperand;



class MDNode : public Value, public FoldingSetNode {
  MDNode(const MDNode &);
  void operator=(const MDNode &);
  friend class MDNodeOperand;
  friend class LLVMContextImpl;



  unsigned NumOperands;


  enum {



    FunctionLocalBit = 1 << 0,



    NotUniquedBit = 1 << 1,



    DestroyFlag = 1 << 2
  };


  enum FunctionLocalness {
    FL_Unknown = -1,
    FL_No = 0,
    FL_Yes = 1
  };



  void replaceOperand(MDNodeOperand *Op, Value *NewVal);
  ~MDNode();


  void replaceAllOperandsWithNull();

protected:
  explicit MDNode(LLVMContext &C, Value *const *Vals, unsigned NumVals,
                  bool isFunctionLocal);

  static MDNode *getMDNode(LLVMContext &C, Value *const *Vals, unsigned NumVals,
                           FunctionLocalness FL, bool Insert = true);
public:

  static MDNode *get(LLVMContext &Context, Value *const *Vals,
                     unsigned NumVals);


  static MDNode *getWhenValsUnresolved(LLVMContext &Context, Value *const *Vals,
                                       unsigned NumVals, bool isFunctionLocal);

  static MDNode *getIfExists(LLVMContext &Context, Value *const *Vals,
                             unsigned NumVals);


  Value *getOperand(unsigned i) const;


  unsigned getNumOperands() const { return NumOperands; }





  bool isFunctionLocal() const {
    return (getSubclassDataFromValue() & FunctionLocalBit) != 0;
  }





  const Function *getFunction() const;


  void destroy();



  void Profile(FoldingSetNodeID &ID) const;


  static inline bool classof(const MDNode *) { return true; }
  static bool classof(const Value *V) {
    return V->getValueID() == MDNodeVal;
  }
private:
  bool isNotUniqued() const {
    return (getSubclassDataFromValue() & NotUniquedBit) != 0;
  }
  void setIsNotUniqued() {
    setValueSubclassData(getSubclassDataFromValue() | NotUniquedBit);
  }



  void setValueSubclassData(unsigned short D) {
    Value::setValueSubclassData(D);
  }
};




class NamedMDNode : public Value, public ilist_node<NamedMDNode> {
  friend class SymbolTableListTraits<NamedMDNode, Module>;
  friend struct ilist_traits<NamedMDNode>;
  friend class LLVMContextImpl;
  NamedMDNode(const NamedMDNode &);

  std::string Name;
  Module *Parent;
  void *Operands;

  void setParent(Module *M) { Parent = M; }
protected:
  explicit NamedMDNode(LLVMContext &C, const Twine &N, MDNode*const *Vals,
                       unsigned NumVals, Module *M = 0);
public:
  static NamedMDNode *Create(LLVMContext &C, const Twine &N,
                             MDNode *const *MDs,
                             unsigned NumMDs, Module *M = 0) {
    return new NamedMDNode(C, N, MDs, NumMDs, M);
  }

  static NamedMDNode *Create(const NamedMDNode *NMD, Module *M = 0);



  void eraseFromParent();


  void dropAllReferences();


  ~NamedMDNode();


  inline Module *getParent() { return Parent; }
  inline const Module *getParent() const { return Parent; }


  MDNode *getOperand(unsigned i) const;


  unsigned getNumOperands() const;


  void addOperand(MDNode *M);


  void setName(const Twine &NewName);


  StringRef getName() const;


  static inline bool classof(const NamedMDNode *) { return true; }
  static bool classof(const Value *V) {
    return V->getValueID() == NamedMDNodeVal;
  }
};

}
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/OwningPtr.h" 1
# 17 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/OwningPtr.h"
# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/OwningPtr.h" 2
# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/OwningPtr.h" 2

namespace llvm {





template<class T>
class OwningPtr {
  OwningPtr(OwningPtr const &);
  OwningPtr &operator=(OwningPtr const &);
  T *Ptr;
public:
  explicit OwningPtr(T *P = 0) : Ptr(P) {}

  ~OwningPtr() {
    delete Ptr;
  }




  void reset(T *P = 0) {
    if (P == Ptr) return;
    T *Tmp = Ptr;
    Ptr = P;
    delete Tmp;
  }



  T *take() {
    T *Tmp = Ptr;
    Ptr = 0;
    return Tmp;
  }

  T &operator*() const {
    ((Ptr && "Cannot dereference null pointer") ? static_cast<void> (0) : __assert_fail ("Ptr && \"Cannot dereference null pointer\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/OwningPtr.h", 57, __PRETTY_FUNCTION__));
    return *Ptr;
  }

  T *operator->() const { return Ptr; }
  T *get() const { return Ptr; }
  operator bool() const { return Ptr != 0; }
  bool operator!() const { return Ptr == 0; }

  void swap(OwningPtr &RHS) {
    T *Tmp = RHS.Ptr;
    RHS.Ptr = Ptr;
    Ptr = Tmp;
  }
};

template<class T>
inline void swap(OwningPtr<T> &a, OwningPtr<T> &b) {
  a.swap(b);
}



template<class T>
class OwningArrayPtr {
  OwningArrayPtr(OwningArrayPtr const &);
  OwningArrayPtr &operator=(OwningArrayPtr const &);
  T *Ptr;
public:
  explicit OwningArrayPtr(T *P = 0) : Ptr(P) {}

  ~OwningArrayPtr() {
    delete [] Ptr;
  }




  void reset(T *P = 0) {
    if (P == Ptr) return;
    T *Tmp = Ptr;
    Ptr = P;
    delete [] Tmp;
  }



  T *take() {
    T *Tmp = Ptr;
    Ptr = 0;
    return Tmp;
  }

  T &operator[](std::ptrdiff_t i) const {
    ((Ptr && "Cannot dereference null pointer") ? static_cast<void> (0) : __assert_fail ("Ptr && \"Cannot dereference null pointer\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/OwningPtr.h", 111, __PRETTY_FUNCTION__));
    return Ptr[i];
  }

  T *get() const { return Ptr; }
  operator bool() const { return Ptr != 0; }
  bool operator!() const { return Ptr == 0; }

  void swap(OwningArrayPtr &RHS) {
    T *Tmp = RHS.Ptr;
    RHS.Ptr = Ptr;
    Ptr = Tmp;
  }
};

template<class T>
inline void swap(OwningArrayPtr<T> &a, OwningArrayPtr<T> &b) {
  a.swap(b);
}


}
# 23 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h" 2



namespace llvm {

class FunctionType;
class GVMaterializer;
class LLVMContext;
class MDSymbolTable;

template<> struct ilist_traits<Function>
  : public SymbolTableListTraits<Function, Module> {



  Function *createSentinel() const {
    return static_cast<Function*>(&Sentinel);
  }
  static void destroySentinel(Function*) {}

  Function *provideInitialHead() const { return createSentinel(); }
  Function *ensureHead(Function*) const { return createSentinel(); }
  static void noteHead(Function*, Function*) {}

private:
  mutable ilist_node<Function> Sentinel;
};
template<> struct ilist_traits<GlobalVariable>
  : public SymbolTableListTraits<GlobalVariable, Module> {

  static GlobalVariable *createSentinel();
  static void destroySentinel(GlobalVariable *GV) { delete GV; }
};
template<> struct ilist_traits<GlobalAlias>
  : public SymbolTableListTraits<GlobalAlias, Module> {

  static GlobalAlias *createSentinel();
  static void destroySentinel(GlobalAlias *GA) { delete GA; }
};

template<> struct ilist_traits<NamedMDNode>
  : public SymbolTableListTraits<NamedMDNode, Module> {


  NamedMDNode *createSentinel() const {
    return static_cast<NamedMDNode*>(&Sentinel);
  }
  static void destroySentinel(NamedMDNode*) {}

  NamedMDNode *provideInitialHead() const { return createSentinel(); }
  NamedMDNode *ensureHead(NamedMDNode*) const { return createSentinel(); }
  static void noteHead(NamedMDNode*, NamedMDNode*) {}
  void addNodeToList(NamedMDNode *N);
  void removeNodeFromList(NamedMDNode *N);
private:
  mutable ilist_node<NamedMDNode> Sentinel;
};
# 92 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h"
class Module {


public:

  typedef iplist<GlobalVariable> GlobalListType;

  typedef iplist<Function> FunctionListType;

  typedef iplist<GlobalAlias> AliasListType;

  typedef iplist<NamedMDNode> NamedMDListType;


  typedef std::vector<std::string> LibraryListType;


  typedef GlobalListType::iterator global_iterator;

  typedef GlobalListType::const_iterator const_global_iterator;


  typedef FunctionListType::iterator iterator;

  typedef FunctionListType::const_iterator const_iterator;


  typedef AliasListType::iterator alias_iterator;

  typedef AliasListType::const_iterator const_alias_iterator;


  typedef NamedMDListType::iterator named_metadata_iterator;

  typedef NamedMDListType::const_iterator const_named_metadata_iterator;

  typedef LibraryListType::const_iterator lib_iterator;


  enum Endianness { AnyEndianness, LittleEndian, BigEndian };


  enum PointerSize { AnyPointerSize, Pointer32, Pointer64 };




private:
  LLVMContext &Context;

  GlobalListType GlobalList;
  FunctionListType FunctionList;
  AliasListType AliasList;
  LibraryListType LibraryList;
  NamedMDListType NamedMDList;
  std::string GlobalScopeAsm;
  ValueSymbolTable *ValSymTab;
  TypeSymbolTable *TypeSymTab;
  OwningPtr<GVMaterializer> Materializer;
  std::string ModuleID;
  std::string TargetTriple;
  std::string DataLayout;
  MDSymbolTable *NamedMDSymTab;

  friend class Constant;




public:


  explicit Module(StringRef ModuleID, LLVMContext& C);

  ~Module();







  const std::string &getModuleIdentifier() const { return ModuleID; }




  const std::string &getDataLayout() const { return DataLayout; }



  const std::string &getTargetTriple() const { return TargetTriple; }



  Endianness getEndianness() const;



  PointerSize getPointerSize() const;



  LLVMContext &getContext() const { return Context; }



  const std::string &getModuleInlineAsm() const { return GlobalScopeAsm; }






  void setModuleIdentifier(StringRef ID) { ModuleID = ID; }


  void setDataLayout(StringRef DL) { DataLayout = DL; }


  void setTargetTriple(StringRef T) { TargetTriple = T; }


  void setModuleInlineAsm(StringRef Asm) { GlobalScopeAsm = Asm; }



  void appendModuleInlineAsm(StringRef Asm) {
    if (!GlobalScopeAsm.empty() &&
        GlobalScopeAsm[GlobalScopeAsm.size()-1] != '\n')
      GlobalScopeAsm += '\n';
    GlobalScopeAsm += Asm;
  }
# 233 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h"
  GlobalValue *getNamedValue(StringRef Name) const;



  unsigned getMDKindID(StringRef Name) const;




  void getMDKindNames(SmallVectorImpl<StringRef> &Result) const;
# 257 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h"
  Constant *getOrInsertFunction(StringRef Name, const FunctionType *T,
                                AttrListPtr AttributeList);

  Constant *getOrInsertFunction(StringRef Name, const FunctionType *T);
# 269 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h"
  Constant *getOrInsertFunction(StringRef Name,
                                AttrListPtr AttributeList,
                                const Type *RetTy, ...) __attribute__((sentinel));


  Constant *getOrInsertFunction(StringRef Name, const Type *RetTy, ...)
    __attribute__((sentinel));

  Constant *getOrInsertTargetIntrinsic(StringRef Name,
                                       const FunctionType *Ty,
                                       AttrListPtr AttributeList);



  Function *getFunction(StringRef Name) const;
# 293 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h"
  GlobalVariable *getGlobalVariable(StringRef Name,
                                    bool AllowInternal = false) const;




  GlobalVariable *getNamedGlobal(StringRef Name) const {
    return getGlobalVariable(Name, true);
  }
# 310 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h"
  Constant *getOrInsertGlobal(StringRef Name, const Type *Ty);
# 319 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h"
  GlobalAlias *getNamedAlias(StringRef Name) const;
# 328 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h"
  NamedMDNode *getNamedMetadata(StringRef Name) const;




  NamedMDNode *getOrInsertNamedMetadata(StringRef Name);
# 342 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h"
  bool addTypeName(StringRef Name, const Type *Ty);



  std::string getTypeName(const Type *Ty) const;



  const Type *getTypeByName(StringRef Name) const;
# 363 "/local/monniaux/packages/llvm-2.7/include/llvm/Module.h"
  void setMaterializer(GVMaterializer *GVM);

  GVMaterializer *getMaterializer() const { return Materializer.get(); }



  bool isMaterializable(const GlobalValue *GV) const;


  bool isDematerializable(const GlobalValue *GV) const;




  bool Materialize(GlobalValue *GV, std::string *ErrInfo = 0);



  void Dematerialize(GlobalValue *GV);





  bool MaterializeAll(std::string *ErrInfo = 0);






  bool MaterializeAllPermanently(std::string *ErrInfo = 0);






  const GlobalListType &getGlobalList() const { return GlobalList; }

  GlobalListType &getGlobalList() { return GlobalList; }
  static iplist<GlobalVariable> Module::*getSublistAccess(GlobalVariable*) {
    return &Module::GlobalList;
  }

  const FunctionListType &getFunctionList() const { return FunctionList; }

  FunctionListType &getFunctionList() { return FunctionList; }
  static iplist<Function> Module::*getSublistAccess(Function*) {
    return &Module::FunctionList;
  }

  const AliasListType &getAliasList() const { return AliasList; }

  AliasListType &getAliasList() { return AliasList; }
  static iplist<GlobalAlias> Module::*getSublistAccess(GlobalAlias*) {
    return &Module::AliasList;
  }

  const NamedMDListType &getNamedMDList() const { return NamedMDList; }

  NamedMDListType &getNamedMDList() { return NamedMDList; }
  static iplist<NamedMDNode> Module::*getSublistAccess(NamedMDNode *) {
    return &Module::NamedMDList;
  }

  const ValueSymbolTable &getValueSymbolTable() const { return *ValSymTab; }

  ValueSymbolTable &getValueSymbolTable() { return *ValSymTab; }

  const TypeSymbolTable &getTypeSymbolTable() const { return *TypeSymTab; }

  TypeSymbolTable &getTypeSymbolTable() { return *TypeSymTab; }

  const MDSymbolTable &getMDSymbolTable() const { return *NamedMDSymTab; }

  MDSymbolTable &getMDSymbolTable() { return *NamedMDSymTab; }






  global_iterator global_begin() { return GlobalList.begin(); }

  const_global_iterator global_begin() const { return GlobalList.begin(); }

  global_iterator global_end () { return GlobalList.end(); }

  const_global_iterator global_end () const { return GlobalList.end(); }

  bool global_empty() const { return GlobalList.empty(); }






  iterator begin() { return FunctionList.begin(); }

  const_iterator begin() const { return FunctionList.begin(); }

  iterator end () { return FunctionList.end(); }

  const_iterator end () const { return FunctionList.end(); }

  size_t size() const { return FunctionList.size(); }

  bool empty() const { return FunctionList.empty(); }






  inline lib_iterator lib_begin() const { return LibraryList.begin(); }

  inline lib_iterator lib_end() const { return LibraryList.end(); }

  inline size_t lib_size() const { return LibraryList.size(); }

  void addLibrary(StringRef Lib);

  void removeLibrary(StringRef Lib);

  inline const LibraryListType& getLibraries() const { return LibraryList; }






  alias_iterator alias_begin() { return AliasList.begin(); }

  const_alias_iterator alias_begin() const { return AliasList.begin(); }

  alias_iterator alias_end () { return AliasList.end(); }

  const_alias_iterator alias_end () const { return AliasList.end(); }

  size_t alias_size () const { return AliasList.size(); }

  bool alias_empty() const { return AliasList.empty(); }







  named_metadata_iterator named_metadata_begin() { return NamedMDList.begin(); }

  const_named_metadata_iterator named_metadata_begin() const {
    return NamedMDList.begin();
  }


  named_metadata_iterator named_metadata_end() { return NamedMDList.end(); }

  const_named_metadata_iterator named_metadata_end() const {
    return NamedMDList.end();
  }


  size_t named_metadata_size() const { return NamedMDList.size(); }

  bool named_metadata_empty() const { return NamedMDList.empty(); }







  void print(raw_ostream &OS, AssemblyAnnotationWriter *AAW) const;


  void dump() const;






  void dropAllReferences();

};


inline raw_ostream &operator<<(raw_ostream &O, const Module &M) {
  M.print(O, 0);
  return O;
}

}
# 8 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h" 1
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h" 1
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Operator.h" 1
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/Operator.h"
namespace llvm {

class GetElementPtrInst;
class BinaryOperator;
class ConstantExpr;




class Operator : public User {
private:


  void *operator new(size_t, unsigned);
  void *operator new(size_t s);
  Operator();
  ~Operator();

public:


  unsigned getOpcode() const {
    if (const Instruction *I = dyn_cast<Instruction>(this))
      return I->getOpcode();
    return cast<ConstantExpr>(this)->getOpcode();
  }




  static unsigned getOpcode(const Value *V) {
    if (const Instruction *I = dyn_cast<Instruction>(V))
      return I->getOpcode();
    if (const ConstantExpr *CE = dyn_cast<ConstantExpr>(V))
      return CE->getOpcode();
    return Instruction::UserOp1;
  }

  static inline bool classof(const Operator *) { return true; }
  static inline bool classof(const Instruction *) { return true; }
  static inline bool classof(const ConstantExpr *) { return true; }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) || isa<ConstantExpr>(V);
  }
};





class OverflowingBinaryOperator : public Operator {
public:
  enum {
    NoUnsignedWrap = (1 << 0),
    NoSignedWrap = (1 << 1)
  };

private:
  ~OverflowingBinaryOperator();

  friend class BinaryOperator;
  friend class ConstantExpr;
  void setHasNoUnsignedWrap(bool B) {
    SubclassOptionalData =
      (SubclassOptionalData & ~NoUnsignedWrap) | (B * NoUnsignedWrap);
  }
  void setHasNoSignedWrap(bool B) {
    SubclassOptionalData =
      (SubclassOptionalData & ~NoSignedWrap) | (B * NoSignedWrap);
  }

public:


  bool hasNoUnsignedWrap() const {
    return SubclassOptionalData & NoUnsignedWrap;
  }



  bool hasNoSignedWrap() const {
    return SubclassOptionalData & NoSignedWrap;
  }

  static inline bool classof(const OverflowingBinaryOperator *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Add ||
           I->getOpcode() == Instruction::Sub ||
           I->getOpcode() == Instruction::Mul;
  }
  static inline bool classof(const ConstantExpr *CE) {
    return CE->getOpcode() == Instruction::Add ||
           CE->getOpcode() == Instruction::Sub ||
           CE->getOpcode() == Instruction::Mul;
  }
  static inline bool classof(const Value *V) {
    return (isa<Instruction>(V) && classof(cast<Instruction>(V))) ||
           (isa<ConstantExpr>(V) && classof(cast<ConstantExpr>(V)));
  }
};



class AddOperator : public OverflowingBinaryOperator {
  ~AddOperator();
public:
  static inline bool classof(const AddOperator *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Add;
  }
  static inline bool classof(const ConstantExpr *CE) {
    return CE->getOpcode() == Instruction::Add;
  }
  static inline bool classof(const Value *V) {
    return (isa<Instruction>(V) && classof(cast<Instruction>(V))) ||
           (isa<ConstantExpr>(V) && classof(cast<ConstantExpr>(V)));
  }
};



class SubOperator : public OverflowingBinaryOperator {
  ~SubOperator();
public:
  static inline bool classof(const SubOperator *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Sub;
  }
  static inline bool classof(const ConstantExpr *CE) {
    return CE->getOpcode() == Instruction::Sub;
  }
  static inline bool classof(const Value *V) {
    return (isa<Instruction>(V) && classof(cast<Instruction>(V))) ||
           (isa<ConstantExpr>(V) && classof(cast<ConstantExpr>(V)));
  }
};



class MulOperator : public OverflowingBinaryOperator {
  ~MulOperator();
public:
  static inline bool classof(const MulOperator *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Mul;
  }
  static inline bool classof(const ConstantExpr *CE) {
    return CE->getOpcode() == Instruction::Mul;
  }
  static inline bool classof(const Value *V) {
    return (isa<Instruction>(V) && classof(cast<Instruction>(V))) ||
           (isa<ConstantExpr>(V) && classof(cast<ConstantExpr>(V)));
  }
};



class SDivOperator : public Operator {
public:
  enum {
    IsExact = (1 << 0)
  };

private:
  ~SDivOperator();

  friend class BinaryOperator;
  friend class ConstantExpr;
  void setIsExact(bool B) {
    SubclassOptionalData = (SubclassOptionalData & ~IsExact) | (B * IsExact);
  }

public:


  bool isExact() const {
    return SubclassOptionalData & IsExact;
  }


  static inline bool classof(const SDivOperator *) { return true; }
  static inline bool classof(const ConstantExpr *CE) {
    return CE->getOpcode() == Instruction::SDiv;
  }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::SDiv;
  }
  static inline bool classof(const Value *V) {
    return (isa<Instruction>(V) && classof(cast<Instruction>(V))) ||
           (isa<ConstantExpr>(V) && classof(cast<ConstantExpr>(V)));
  }
};

class GEPOperator : public Operator {
  enum {
    IsInBounds = (1 << 0)
  };

  ~GEPOperator();

  friend class GetElementPtrInst;
  friend class ConstantExpr;
  void setIsInBounds(bool B) {
    SubclassOptionalData =
      (SubclassOptionalData & ~IsInBounds) | (B * IsInBounds);
  }

public:


  bool isInBounds() const {
    return SubclassOptionalData & IsInBounds;
  }

  inline op_iterator idx_begin() { return op_begin()+1; }
  inline const_op_iterator idx_begin() const { return op_begin()+1; }
  inline op_iterator idx_end() { return op_end(); }
  inline const_op_iterator idx_end() const { return op_end(); }

  Value *getPointerOperand() {
    return getOperand(0);
  }
  const Value *getPointerOperand() const {
    return getOperand(0);
  }
  static unsigned getPointerOperandIndex() {
    return 0U;
  }



  const PointerType *getPointerOperandType() const {
    return reinterpret_cast<const PointerType*>(getPointerOperand()->getType());
  }

  unsigned getNumIndices() const {
    return getNumOperands() - 1;
  }

  bool hasIndices() const {
    return getNumOperands() > 1;
  }




  bool hasAllZeroIndices() const {
    for (const_op_iterator I = idx_begin(), E = idx_end(); I != E; ++I) {
      if (Constant *C = dyn_cast<Constant>(I))
        if (C->isNullValue())
          continue;
      return false;
    }
    return true;
  }




  bool hasAllConstantIndices() const {
    for (const_op_iterator I = idx_begin(), E = idx_end(); I != E; ++I) {
      if (!isa<ConstantInt>(I))
        return false;
    }
    return true;
  }



  static inline bool classof(const GEPOperator *) { return true; }
  static inline bool classof(const GetElementPtrInst *) { return true; }
  static inline bool classof(const ConstantExpr *CE) {
    return CE->getOpcode() == Instruction::GetElementPtr;
  }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::GetElementPtr;
  }
  static inline bool classof(const Value *V) {
    return (isa<Instruction>(V) && classof(cast<Instruction>(V))) ||
           (isa<ConstantExpr>(V) && classof(cast<ConstantExpr>(V)));
  }
};

}
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h" 2



namespace llvm {

class LLVMContext;
# 36 "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h"
class TerminatorInst : public Instruction {
protected:
  TerminatorInst(const Type *Ty, Instruction::TermOps iType,
                 Use *Ops, unsigned NumOps,
                 Instruction *InsertBefore = 0)
    : Instruction(Ty, iType, Ops, NumOps, InsertBefore) {}

  TerminatorInst(const Type *Ty, Instruction::TermOps iType,
                 Use *Ops, unsigned NumOps, BasicBlock *InsertAtEnd)
    : Instruction(Ty, iType, Ops, NumOps, InsertAtEnd) {}


  ~TerminatorInst();



  virtual BasicBlock *getSuccessorV(unsigned idx) const = 0;
  virtual unsigned getNumSuccessorsV() const = 0;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B) = 0;
  virtual TerminatorInst *clone_impl() const = 0;
public:



  unsigned getNumSuccessors() const {
    return getNumSuccessorsV();
  }



  BasicBlock *getSuccessor(unsigned idx) const {
    return getSuccessorV(idx);
  }



  void setSuccessor(unsigned idx, BasicBlock *B) {
    setSuccessorV(idx, B);
  }


  static inline bool classof(const TerminatorInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->isTerminator();
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class UnaryInstruction : public Instruction {
  void *operator new(size_t, unsigned);

protected:
  UnaryInstruction(const Type *Ty, unsigned iType, Value *V,
                   Instruction *IB = 0)
    : Instruction(Ty, iType, &Op<0>(), 1, IB) {
    Op<0>() = V;
  }
  UnaryInstruction(const Type *Ty, unsigned iType, Value *V, BasicBlock *IAE)
    : Instruction(Ty, iType, &Op<0>(), 1, IAE) {
    Op<0>() = V;
  }
public:

  void *operator new(size_t s) {
    return User::operator new(s, 1);
  }


  ~UnaryInstruction();


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  static inline bool classof(const UnaryInstruction *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Alloca ||
           I->getOpcode() == Instruction::Load ||
           I->getOpcode() == Instruction::VAArg ||
           I->getOpcode() == Instruction::ExtractValue ||
           (I->getOpcode() >= CastOpsBegin && I->getOpcode() < CastOpsEnd);
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<UnaryInstruction> : public FixedNumOperandTraits<1> {
};

UnaryInstruction::op_iterator UnaryInstruction::op_begin() { return OperandTraits<UnaryInstruction>::op_begin(this); } UnaryInstruction::const_op_iterator UnaryInstruction::op_begin() const { return OperandTraits<UnaryInstruction>::op_begin(const_cast<UnaryInstruction*>(this)); } UnaryInstruction::op_iterator UnaryInstruction::op_end() { return OperandTraits<UnaryInstruction>::op_end(this); } UnaryInstruction::const_op_iterator UnaryInstruction::op_end() const { return OperandTraits<UnaryInstruction>::op_end(const_cast<UnaryInstruction*>(this)); } Value *UnaryInstruction::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<UnaryInstruction>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<UnaryInstruction>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h", 134, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<UnaryInstruction>::op_begin(const_cast<UnaryInstruction*>(this))[i_nocapture]); } void UnaryInstruction::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<UnaryInstruction>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<UnaryInstruction>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h", 134, __PRETTY_FUNCTION__)); OperandTraits<UnaryInstruction>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned UnaryInstruction::getNumOperands() const { return OperandTraits<UnaryInstruction>::operands(this); } template <int Idx_nocapture> Use &UnaryInstruction::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &UnaryInstruction::Op() const { return this->OpFrom<Idx_nocapture>(this); }





class BinaryOperator : public Instruction {
  void *operator new(size_t, unsigned);
protected:
  void init(BinaryOps iType);
  BinaryOperator(BinaryOps iType, Value *S1, Value *S2, const Type *Ty,
                 const Twine &Name, Instruction *InsertBefore);
  BinaryOperator(BinaryOps iType, Value *S1, Value *S2, const Type *Ty,
                 const Twine &Name, BasicBlock *InsertAtEnd);
  virtual BinaryOperator *clone_impl() const;
public:

  void *operator new(size_t s) {
    return User::operator new(s, 2);
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;






  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,
                                const Twine &Name = Twine(),
                                Instruction *InsertBefore = 0);





  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,
                                const Twine &Name, BasicBlock *InsertAtEnd);
# 182 "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def" 1
# 96 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def"








 



static BinaryOperator *CreateAdd(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::Add, V1, V2, Name); }
static BinaryOperator *CreateFAdd(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::FAdd, V1, V2, Name); }
static BinaryOperator *CreateSub(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::Sub, V1, V2, Name); }
static BinaryOperator *CreateFSub(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::FSub, V1, V2, Name); }
static BinaryOperator *CreateMul(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::Mul, V1, V2, Name); }
static BinaryOperator *CreateFMul(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::FMul, V1, V2, Name); }
static BinaryOperator *CreateUDiv(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::UDiv, V1, V2, Name); }
static BinaryOperator *CreateSDiv(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::SDiv, V1, V2, Name); }
static BinaryOperator *CreateFDiv(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::FDiv, V1, V2, Name); }
static BinaryOperator *CreateURem(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::URem, V1, V2, Name); }
static BinaryOperator *CreateSRem(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::SRem, V1, V2, Name); }
static BinaryOperator *CreateFRem(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::FRem, V1, V2, Name); }


static BinaryOperator *CreateShl(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::Shl, V1, V2, Name); }
static BinaryOperator *CreateLShr(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::LShr, V1, V2, Name); }
static BinaryOperator *CreateAShr(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::AShr, V1, V2, Name); }
static BinaryOperator *CreateAnd(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::And, V1, V2, Name); }
static BinaryOperator *CreateOr(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::Or, V1, V2, Name); }
static BinaryOperator *CreateXor(Value *V1, Value *V2, const Twine &Name = "") { return Create(Instruction::Xor, V1, V2, Name); }
 







 

















 

















 
# 183 "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h" 2





# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def" 1
# 96 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def"








 



static BinaryOperator *CreateAdd(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::Add, V1, V2, Name, BB); }
static BinaryOperator *CreateFAdd(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::FAdd, V1, V2, Name, BB); }
static BinaryOperator *CreateSub(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::Sub, V1, V2, Name, BB); }
static BinaryOperator *CreateFSub(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::FSub, V1, V2, Name, BB); }
static BinaryOperator *CreateMul(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::Mul, V1, V2, Name, BB); }
static BinaryOperator *CreateFMul(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::FMul, V1, V2, Name, BB); }
static BinaryOperator *CreateUDiv(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::UDiv, V1, V2, Name, BB); }
static BinaryOperator *CreateSDiv(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::SDiv, V1, V2, Name, BB); }
static BinaryOperator *CreateFDiv(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::FDiv, V1, V2, Name, BB); }
static BinaryOperator *CreateURem(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::URem, V1, V2, Name, BB); }
static BinaryOperator *CreateSRem(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::SRem, V1, V2, Name, BB); }
static BinaryOperator *CreateFRem(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::FRem, V1, V2, Name, BB); }


static BinaryOperator *CreateShl(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::Shl, V1, V2, Name, BB); }
static BinaryOperator *CreateLShr(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::LShr, V1, V2, Name, BB); }
static BinaryOperator *CreateAShr(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::AShr, V1, V2, Name, BB); }
static BinaryOperator *CreateAnd(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::And, V1, V2, Name, BB); }
static BinaryOperator *CreateOr(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::Or, V1, V2, Name, BB); }
static BinaryOperator *CreateXor(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) { return Create(Instruction::Xor, V1, V2, Name, BB); }
 







 

















 

















 
# 189 "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h" 2





# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def" 1
# 96 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def"








 



static BinaryOperator *CreateAdd(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::Add, V1, V2, Name, I); }
static BinaryOperator *CreateFAdd(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::FAdd, V1, V2, Name, I); }
static BinaryOperator *CreateSub(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::Sub, V1, V2, Name, I); }
static BinaryOperator *CreateFSub(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::FSub, V1, V2, Name, I); }
static BinaryOperator *CreateMul(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::Mul, V1, V2, Name, I); }
static BinaryOperator *CreateFMul(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::FMul, V1, V2, Name, I); }
static BinaryOperator *CreateUDiv(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::UDiv, V1, V2, Name, I); }
static BinaryOperator *CreateSDiv(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::SDiv, V1, V2, Name, I); }
static BinaryOperator *CreateFDiv(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::FDiv, V1, V2, Name, I); }
static BinaryOperator *CreateURem(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::URem, V1, V2, Name, I); }
static BinaryOperator *CreateSRem(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::SRem, V1, V2, Name, I); }
static BinaryOperator *CreateFRem(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::FRem, V1, V2, Name, I); }


static BinaryOperator *CreateShl(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::Shl, V1, V2, Name, I); }
static BinaryOperator *CreateLShr(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::LShr, V1, V2, Name, I); }
static BinaryOperator *CreateAShr(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::AShr, V1, V2, Name, I); }
static BinaryOperator *CreateAnd(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::And, V1, V2, Name, I); }
static BinaryOperator *CreateOr(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::Or, V1, V2, Name, I); }
static BinaryOperator *CreateXor(Value *V1, Value *V2, const Twine &Name, Instruction *I) { return Create(Instruction::Xor, V1, V2, Name, I); }
 







 

















 

















 
# 195 "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h" 2




  static BinaryOperator *CreateNSWAdd(Value *V1, Value *V2,
                                      const Twine &Name = "") {
    BinaryOperator *BO = CreateAdd(V1, V2, Name);
    BO->setHasNoSignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNSWAdd(Value *V1, Value *V2,
                                      const Twine &Name, BasicBlock *BB) {
    BinaryOperator *BO = CreateAdd(V1, V2, Name, BB);
    BO->setHasNoSignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNSWAdd(Value *V1, Value *V2,
                                      const Twine &Name, Instruction *I) {
    BinaryOperator *BO = CreateAdd(V1, V2, Name, I);
    BO->setHasNoSignedWrap(true);
    return BO;
  }



  static BinaryOperator *CreateNUWAdd(Value *V1, Value *V2,
                                      const Twine &Name = "") {
    BinaryOperator *BO = CreateAdd(V1, V2, Name);
    BO->setHasNoUnsignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNUWAdd(Value *V1, Value *V2,
                                      const Twine &Name, BasicBlock *BB) {
    BinaryOperator *BO = CreateAdd(V1, V2, Name, BB);
    BO->setHasNoUnsignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNUWAdd(Value *V1, Value *V2,
                                      const Twine &Name, Instruction *I) {
    BinaryOperator *BO = CreateAdd(V1, V2, Name, I);
    BO->setHasNoUnsignedWrap(true);
    return BO;
  }



  static BinaryOperator *CreateNSWSub(Value *V1, Value *V2,
                                      const Twine &Name = "") {
    BinaryOperator *BO = CreateSub(V1, V2, Name);
    BO->setHasNoSignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNSWSub(Value *V1, Value *V2,
                                      const Twine &Name, BasicBlock *BB) {
    BinaryOperator *BO = CreateSub(V1, V2, Name, BB);
    BO->setHasNoSignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNSWSub(Value *V1, Value *V2,
                                      const Twine &Name, Instruction *I) {
    BinaryOperator *BO = CreateSub(V1, V2, Name, I);
    BO->setHasNoSignedWrap(true);
    return BO;
  }



  static BinaryOperator *CreateNUWSub(Value *V1, Value *V2,
                                      const Twine &Name = "") {
    BinaryOperator *BO = CreateSub(V1, V2, Name);
    BO->setHasNoUnsignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNUWSub(Value *V1, Value *V2,
                                      const Twine &Name, BasicBlock *BB) {
    BinaryOperator *BO = CreateSub(V1, V2, Name, BB);
    BO->setHasNoUnsignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNUWSub(Value *V1, Value *V2,
                                      const Twine &Name, Instruction *I) {
    BinaryOperator *BO = CreateSub(V1, V2, Name, I);
    BO->setHasNoUnsignedWrap(true);
    return BO;
  }



  static BinaryOperator *CreateNSWMul(Value *V1, Value *V2,
                                      const Twine &Name = "") {
    BinaryOperator *BO = CreateMul(V1, V2, Name);
    BO->setHasNoSignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNSWMul(Value *V1, Value *V2,
                                      const Twine &Name, BasicBlock *BB) {
    BinaryOperator *BO = CreateMul(V1, V2, Name, BB);
    BO->setHasNoSignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNSWMul(Value *V1, Value *V2,
                                      const Twine &Name, Instruction *I) {
    BinaryOperator *BO = CreateMul(V1, V2, Name, I);
    BO->setHasNoSignedWrap(true);
    return BO;
  }



  static BinaryOperator *CreateNUWMul(Value *V1, Value *V2,
                                      const Twine &Name = "") {
    BinaryOperator *BO = CreateMul(V1, V2, Name);
    BO->setHasNoUnsignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNUWMul(Value *V1, Value *V2,
                                      const Twine &Name, BasicBlock *BB) {
    BinaryOperator *BO = CreateMul(V1, V2, Name, BB);
    BO->setHasNoUnsignedWrap(true);
    return BO;
  }
  static BinaryOperator *CreateNUWMul(Value *V1, Value *V2,
                                      const Twine &Name, Instruction *I) {
    BinaryOperator *BO = CreateMul(V1, V2, Name, I);
    BO->setHasNoUnsignedWrap(true);
    return BO;
  }



  static BinaryOperator *CreateExactSDiv(Value *V1, Value *V2,
                                         const Twine &Name = "") {
    BinaryOperator *BO = CreateSDiv(V1, V2, Name);
    BO->setIsExact(true);
    return BO;
  }
  static BinaryOperator *CreateExactSDiv(Value *V1, Value *V2,
                                         const Twine &Name, BasicBlock *BB) {
    BinaryOperator *BO = CreateSDiv(V1, V2, Name, BB);
    BO->setIsExact(true);
    return BO;
  }
  static BinaryOperator *CreateExactSDiv(Value *V1, Value *V2,
                                         const Twine &Name, Instruction *I) {
    BinaryOperator *BO = CreateSDiv(V1, V2, Name, I);
    BO->setIsExact(true);
    return BO;
  }







  static BinaryOperator *CreateNeg(Value *Op, const Twine &Name = "",
                                   Instruction *InsertBefore = 0);
  static BinaryOperator *CreateNeg(Value *Op, const Twine &Name,
                                   BasicBlock *InsertAtEnd);
  static BinaryOperator *CreateNSWNeg(Value *Op, const Twine &Name = "",
                                      Instruction *InsertBefore = 0);
  static BinaryOperator *CreateNSWNeg(Value *Op, const Twine &Name,
                                      BasicBlock *InsertAtEnd);
  static BinaryOperator *CreateNUWNeg(Value *Op, const Twine &Name = "",
                                      Instruction *InsertBefore = 0);
  static BinaryOperator *CreateNUWNeg(Value *Op, const Twine &Name,
                                      BasicBlock *InsertAtEnd);
  static BinaryOperator *CreateFNeg(Value *Op, const Twine &Name = "",
                                    Instruction *InsertBefore = 0);
  static BinaryOperator *CreateFNeg(Value *Op, const Twine &Name,
                                    BasicBlock *InsertAtEnd);
  static BinaryOperator *CreateNot(Value *Op, const Twine &Name = "",
                                   Instruction *InsertBefore = 0);
  static BinaryOperator *CreateNot(Value *Op, const Twine &Name,
                                   BasicBlock *InsertAtEnd);




  static bool isNeg(const Value *V);
  static bool isFNeg(const Value *V);
  static bool isNot(const Value *V);





  static const Value *getNegArgument(const Value *BinOp);
  static Value *getNegArgument( Value *BinOp);
  static const Value *getFNegArgument(const Value *BinOp);
  static Value *getFNegArgument( Value *BinOp);
  static const Value *getNotArgument(const Value *BinOp);
  static Value *getNotArgument( Value *BinOp);

  BinaryOps getOpcode() const {
    return static_cast<BinaryOps>(Instruction::getOpcode());
  }






  bool swapOperands();




  void setHasNoUnsignedWrap(bool b = true);




  void setHasNoSignedWrap(bool b = true);




  void setIsExact(bool b = true);


  bool hasNoUnsignedWrap() const;


  bool hasNoSignedWrap() const;


  bool isExact() const;


  static inline bool classof(const BinaryOperator *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->isBinaryOp();
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<BinaryOperator> : public FixedNumOperandTraits<2> {
};

BinaryOperator::op_iterator BinaryOperator::op_begin() { return OperandTraits<BinaryOperator>::op_begin(this); } BinaryOperator::const_op_iterator BinaryOperator::op_begin() const { return OperandTraits<BinaryOperator>::op_begin(const_cast<BinaryOperator*>(this)); } BinaryOperator::op_iterator BinaryOperator::op_end() { return OperandTraits<BinaryOperator>::op_end(this); } BinaryOperator::const_op_iterator BinaryOperator::op_end() const { return OperandTraits<BinaryOperator>::op_end(const_cast<BinaryOperator*>(this)); } Value *BinaryOperator::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<BinaryOperator>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<BinaryOperator>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h", 438, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<BinaryOperator>::op_begin(const_cast<BinaryOperator*>(this))[i_nocapture]); } void BinaryOperator::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<BinaryOperator>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<BinaryOperator>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h", 438, __PRETTY_FUNCTION__)); OperandTraits<BinaryOperator>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned BinaryOperator::getNumOperands() const { return OperandTraits<BinaryOperator>::operands(this); } template <int Idx_nocapture> Use &BinaryOperator::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &BinaryOperator::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 450 "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h"
class CastInst : public UnaryInstruction {
protected:

  CastInst(const Type *Ty, unsigned iType, Value *S,
           const Twine &NameStr = "", Instruction *InsertBefore = 0)
    : UnaryInstruction(Ty, iType, S, InsertBefore) {
    setName(NameStr);
  }

  CastInst(const Type *Ty, unsigned iType, Value *S,
           const Twine &NameStr, BasicBlock *InsertAtEnd)
    : UnaryInstruction(Ty, iType, S, InsertAtEnd) {
    setName(NameStr);
  }
public:






  static CastInst *Create(
    Instruction::CastOps,
    Value *S,
    const Type *Ty,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );






  static CastInst *Create(
    Instruction::CastOps,
    Value *S,
    const Type *Ty,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static CastInst *CreateZExtOrBitCast(
    Value *S,
    const Type *Ty,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );


  static CastInst *CreateZExtOrBitCast(
    Value *S,
    const Type *Ty,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static CastInst *CreateSExtOrBitCast(
    Value *S,
    const Type *Ty,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );


  static CastInst *CreateSExtOrBitCast(
    Value *S,
    const Type *Ty,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static CastInst *CreatePointerCast(
    Value *S,
    const Type *Ty,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static CastInst *CreatePointerCast(
    Value *S,
    const Type *Ty,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );


  static CastInst *CreateIntegerCast(
    Value *S,
    const Type *Ty,
    bool isSigned,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );


  static CastInst *CreateIntegerCast(
    Value *S,
    const Type *Ty,
    bool isSigned,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static CastInst *CreateFPCast(
    Value *S,
    const Type *Ty,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );


  static CastInst *CreateFPCast(
    Value *S,
    const Type *Ty,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static CastInst *CreateTruncOrBitCast(
    Value *S,
    const Type *Ty,
    const Twine &Name = "",
    Instruction *InsertBefore = 0
  );


  static CastInst *CreateTruncOrBitCast(
    Value *S,
    const Type *Ty,
    const Twine &Name,
    BasicBlock *InsertAtEnd
  );


  static bool isCastable(
    const Type *SrcTy,
    const Type *DestTy
  );




  static Instruction::CastOps getCastOpcode(
    const Value *Val,
    bool SrcIsSigned,
    const Type *Ty,
    bool DstIsSigned
  );






  bool isIntegerCast() const;






  bool isLosslessCast() const;
# 629 "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h"
  bool isNoopCast(
    const Type *IntPtrTy
  ) const;







  static unsigned isEliminableCastPair(
    Instruction::CastOps firstOpcode,
    Instruction::CastOps secondOpcode,
    const Type *SrcTy,
    const Type *MidTy,
    const Type *DstTy,
    const Type *IntPtrTy
  );


  Instruction::CastOps getOpcode() const {
    return Instruction::CastOps(Instruction::getOpcode());
  }


  const Type* getSrcTy() const { return getOperand(0)->getType(); }

  const Type* getDestTy() const { return getType(); }





  static bool castIsValid(Instruction::CastOps op, Value *S, const Type *DstTy);


  static inline bool classof(const CastInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->isCast();
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};







class CmpInst : public Instruction {
  void *operator new(size_t, unsigned);
  CmpInst();
protected:
  CmpInst(const Type *ty, Instruction::OtherOps op, unsigned short pred,
          Value *LHS, Value *RHS, const Twine &Name = "",
          Instruction *InsertBefore = 0);

  CmpInst(const Type *ty, Instruction::OtherOps op, unsigned short pred,
          Value *LHS, Value *RHS, const Twine &Name,
          BasicBlock *InsertAtEnd);

  virtual void Anchor() const;
public:




  enum Predicate {

    FCMP_FALSE = 0,
    FCMP_OEQ = 1,
    FCMP_OGT = 2,
    FCMP_OGE = 3,
    FCMP_OLT = 4,
    FCMP_OLE = 5,
    FCMP_ONE = 6,
    FCMP_ORD = 7,
    FCMP_UNO = 8,
    FCMP_UEQ = 9,
    FCMP_UGT = 10,
    FCMP_UGE = 11,
    FCMP_ULT = 12,
    FCMP_ULE = 13,
    FCMP_UNE = 14,
    FCMP_TRUE = 15,
    FIRST_FCMP_PREDICATE = FCMP_FALSE,
    LAST_FCMP_PREDICATE = FCMP_TRUE,
    BAD_FCMP_PREDICATE = FCMP_TRUE + 1,
    ICMP_EQ = 32,
    ICMP_NE = 33,
    ICMP_UGT = 34,
    ICMP_UGE = 35,
    ICMP_ULT = 36,
    ICMP_ULE = 37,
    ICMP_SGT = 38,
    ICMP_SGE = 39,
    ICMP_SLT = 40,
    ICMP_SLE = 41,
    FIRST_ICMP_PREDICATE = ICMP_EQ,
    LAST_ICMP_PREDICATE = ICMP_SLE,
    BAD_ICMP_PREDICATE = ICMP_SLE + 1
  };


  void *operator new(size_t s) {
    return User::operator new(s, 2);
  }





  static CmpInst *Create(OtherOps Op,
                         unsigned short predicate, Value *S1,
                         Value *S2, const Twine &Name = "",
                         Instruction *InsertBefore = 0);





  static CmpInst *Create(OtherOps Op, unsigned short predicate, Value *S1,
                         Value *S2, const Twine &Name, BasicBlock *InsertAtEnd);


  OtherOps getOpcode() const {
    return static_cast<OtherOps>(Instruction::getOpcode());
  }


  Predicate getPredicate() const {
    return Predicate(getSubclassDataFromInstruction());
  }


  void setPredicate(Predicate P) { setInstructionSubclassData(P); }

  static bool isFPPredicate(Predicate P) {
    return P >= FIRST_FCMP_PREDICATE && P <= LAST_FCMP_PREDICATE;
  }

  static bool isIntPredicate(Predicate P) {
    return P >= FIRST_ICMP_PREDICATE && P <= LAST_ICMP_PREDICATE;
  }

  bool isFPPredicate() const { return isFPPredicate(getPredicate()); }
  bool isIntPredicate() const { return isIntPredicate(getPredicate()); }






  Predicate getInversePredicate() const {
    return getInversePredicate(getPredicate());
  }





  static Predicate getInversePredicate(Predicate pred);







  Predicate getSwappedPredicate() const {
    return getSwappedPredicate(getPredicate());
  }




  static Predicate getSwappedPredicate(Predicate pred);


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;




  void swapOperands();



  bool isCommutative();



  bool isEquality();



  bool isSigned() const {
    return isSigned(getPredicate());
  }



  bool isUnsigned() const {
    return isUnsigned(getPredicate());
  }



  bool isTrueWhenEqual() const {
    return isTrueWhenEqual(getPredicate());
  }



  bool isFalseWhenEqual() const {
    return isFalseWhenEqual(getPredicate());
  }



  static bool isUnsigned(unsigned short predicate);



  static bool isSigned(unsigned short predicate);


  static bool isOrdered(unsigned short predicate);


  static bool isUnordered(unsigned short predicate);


  static bool isTrueWhenEqual(unsigned short predicate);


  static bool isFalseWhenEqual(unsigned short predicate);


  static inline bool classof(const CmpInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::ICmp ||
           I->getOpcode() == Instruction::FCmp;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }


  static const Type* makeCmpResultType(const Type* opnd_type) {
    if (const VectorType* vt = dyn_cast<const VectorType>(opnd_type)) {
      return VectorType::get(Type::getInt1Ty(opnd_type->getContext()),
                             vt->getNumElements());
    }
    return Type::getInt1Ty(opnd_type->getContext());
  }
private:


  void setValueSubclassData(unsigned short D) {
    Value::setValueSubclassData(D);
  }
};



template <>
struct OperandTraits<CmpInst> : public FixedNumOperandTraits<2> {
};

CmpInst::op_iterator CmpInst::op_begin() { return OperandTraits<CmpInst>::op_begin(this); } CmpInst::const_op_iterator CmpInst::op_begin() const { return OperandTraits<CmpInst>::op_begin(const_cast<CmpInst*>(this)); } CmpInst::op_iterator CmpInst::op_end() { return OperandTraits<CmpInst>::op_end(this); } CmpInst::const_op_iterator CmpInst::op_end() const { return OperandTraits<CmpInst>::op_end(const_cast<CmpInst*>(this)); } Value *CmpInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<CmpInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<CmpInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h", 901, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<CmpInst>::op_begin(const_cast<CmpInst*>(this))[i_nocapture]); } void CmpInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<CmpInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<CmpInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/InstrTypes.h", 901, __PRETTY_FUNCTION__)); OperandTraits<CmpInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned CmpInst::getNumOperands() const { return OperandTraits<CmpInst>::operands(this); } template <int Idx_nocapture> Use &CmpInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &CmpInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }

}
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h" 2






namespace llvm {

class ConstantInt;
class ConstantRange;
class APInt;
class LLVMContext;
class DominatorTree;







class AllocaInst : public UnaryInstruction {
protected:
  virtual AllocaInst *clone_impl() const;
public:
  explicit AllocaInst(const Type *Ty, Value *ArraySize = 0,
                      const Twine &Name = "", Instruction *InsertBefore = 0);
  AllocaInst(const Type *Ty, Value *ArraySize,
             const Twine &Name, BasicBlock *InsertAtEnd);

  AllocaInst(const Type *Ty, const Twine &Name, Instruction *InsertBefore = 0);
  AllocaInst(const Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd);

  AllocaInst(const Type *Ty, Value *ArraySize, unsigned Align,
             const Twine &Name = "", Instruction *InsertBefore = 0);
  AllocaInst(const Type *Ty, Value *ArraySize, unsigned Align,
             const Twine &Name, BasicBlock *InsertAtEnd);


  virtual ~AllocaInst();




  bool isArrayAllocation() const;




  const Value *getArraySize() const { return getOperand(0); }
  Value *getArraySize() { return getOperand(0); }



  const PointerType *getType() const {
    return reinterpret_cast<const PointerType*>(Instruction::getType());
  }




  const Type *getAllocatedType() const;




  unsigned getAlignment() const {
    return (1u << getSubclassDataFromInstruction()) >> 1;
  }
  void setAlignment(unsigned Align);




  bool isStaticAlloca() const;


  static inline bool classof(const AllocaInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return (I->getOpcode() == Instruction::Alloca);
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:


  void setInstructionSubclassData(unsigned short D) {
    Instruction::setInstructionSubclassData(D);
  }
};
# 119 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class LoadInst : public UnaryInstruction {
  void AssertOK();
protected:
  virtual LoadInst *clone_impl() const;
public:
  LoadInst(Value *Ptr, const Twine &NameStr, Instruction *InsertBefore);
  LoadInst(Value *Ptr, const Twine &NameStr, BasicBlock *InsertAtEnd);
  LoadInst(Value *Ptr, const Twine &NameStr, bool isVolatile = false,
           Instruction *InsertBefore = 0);
  LoadInst(Value *Ptr, const Twine &NameStr, bool isVolatile,
           unsigned Align, Instruction *InsertBefore = 0);
  LoadInst(Value *Ptr, const Twine &NameStr, bool isVolatile,
           BasicBlock *InsertAtEnd);
  LoadInst(Value *Ptr, const Twine &NameStr, bool isVolatile,
           unsigned Align, BasicBlock *InsertAtEnd);

  LoadInst(Value *Ptr, const char *NameStr, Instruction *InsertBefore);
  LoadInst(Value *Ptr, const char *NameStr, BasicBlock *InsertAtEnd);
  explicit LoadInst(Value *Ptr, const char *NameStr = 0,
                    bool isVolatile = false, Instruction *InsertBefore = 0);
  LoadInst(Value *Ptr, const char *NameStr, bool isVolatile,
           BasicBlock *InsertAtEnd);




  bool isVolatile() const { return getSubclassDataFromInstruction() & 1; }



  void setVolatile(bool V) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~1) |
                               (V ? 1 : 0));
  }



  unsigned getAlignment() const {
    return (1 << (getSubclassDataFromInstruction() >> 1)) >> 1;
  }

  void setAlignment(unsigned Align);

  Value *getPointerOperand() { return getOperand(0); }
  const Value *getPointerOperand() const { return getOperand(0); }
  static unsigned getPointerOperandIndex() { return 0U; }

  unsigned getPointerAddressSpace() const {
    return cast<PointerType>(getPointerOperand()->getType())->getAddressSpace();
  }



  static inline bool classof(const LoadInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Load;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:


  void setInstructionSubclassData(unsigned short D) {
    Instruction::setInstructionSubclassData(D);
  }
};
# 194 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class StoreInst : public Instruction {
  void *operator new(size_t, unsigned);
  void AssertOK();
protected:
  virtual StoreInst *clone_impl() const;
public:

  void *operator new(size_t s) {
    return User::operator new(s, 2);
  }
  StoreInst(Value *Val, Value *Ptr, Instruction *InsertBefore);
  StoreInst(Value *Val, Value *Ptr, BasicBlock *InsertAtEnd);
  StoreInst(Value *Val, Value *Ptr, bool isVolatile = false,
            Instruction *InsertBefore = 0);
  StoreInst(Value *Val, Value *Ptr, bool isVolatile,
            unsigned Align, Instruction *InsertBefore = 0);
  StoreInst(Value *Val, Value *Ptr, bool isVolatile, BasicBlock *InsertAtEnd);
  StoreInst(Value *Val, Value *Ptr, bool isVolatile,
            unsigned Align, BasicBlock *InsertAtEnd);





  bool isVolatile() const { return getSubclassDataFromInstruction() & 1; }



  void setVolatile(bool V) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~1) |
                               (V ? 1 : 0));
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;



  unsigned getAlignment() const {
    return (1 << (getSubclassDataFromInstruction() >> 1)) >> 1;
  }

  void setAlignment(unsigned Align);

  Value *getPointerOperand() { return getOperand(1); }
  const Value *getPointerOperand() const { return getOperand(1); }
  static unsigned getPointerOperandIndex() { return 1U; }

  unsigned getPointerAddressSpace() const {
    return cast<PointerType>(getPointerOperand()->getType())->getAddressSpace();
  }


  static inline bool classof(const StoreInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Store;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:


  void setInstructionSubclassData(unsigned short D) {
    Instruction::setInstructionSubclassData(D);
  }
};

template <>
struct OperandTraits<StoreInst> : public FixedNumOperandTraits<2> {
};

StoreInst::op_iterator StoreInst::op_begin() { return OperandTraits<StoreInst>::op_begin(this); } StoreInst::const_op_iterator StoreInst::op_begin() const { return OperandTraits<StoreInst>::op_begin(const_cast<StoreInst*>(this)); } StoreInst::op_iterator StoreInst::op_end() { return OperandTraits<StoreInst>::op_end(this); } StoreInst::const_op_iterator StoreInst::op_end() const { return OperandTraits<StoreInst>::op_end(const_cast<StoreInst*>(this)); } Value *StoreInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<StoreInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<StoreInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 266, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<StoreInst>::op_begin(const_cast<StoreInst*>(this))[i_nocapture]); } void StoreInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<StoreInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<StoreInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 266, __PRETTY_FUNCTION__)); OperandTraits<StoreInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned StoreInst::getNumOperands() const { return OperandTraits<StoreInst>::operands(this); } template <int Idx_nocapture> Use &StoreInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &StoreInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 275 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
static inline const Type *checkType(const Type *Ty) {
  ((Ty && "Invalid GetElementPtrInst indices for type!") ? static_cast<void> (0) : __assert_fail ("Ty && \"Invalid GetElementPtrInst indices for type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 276, __PRETTY_FUNCTION__));
  return Ty;
}




class GetElementPtrInst : public Instruction {
  GetElementPtrInst(const GetElementPtrInst &GEPI);
  void init(Value *Ptr, Value* const *Idx, unsigned NumIdx,
            const Twine &NameStr);
  void init(Value *Ptr, Value *Idx, const Twine &NameStr);

  template<typename InputIterator>
  void init(Value *Ptr, InputIterator IdxBegin, InputIterator IdxEnd,
            const Twine &NameStr,


            std::random_access_iterator_tag) {
    unsigned NumIdx = static_cast<unsigned>(std::distance(IdxBegin, IdxEnd));

    if (NumIdx > 0) {

      init(Ptr, &*IdxBegin, NumIdx, NameStr);

    }
    else {
      init(Ptr, 0, NumIdx, NameStr);
    }
  }







  template<typename InputIterator>
  static const Type *getIndexedType(const Type *Ptr,
                                    InputIterator IdxBegin,
                                    InputIterator IdxEnd,



                                    std::random_access_iterator_tag) {
    unsigned NumIdx = static_cast<unsigned>(std::distance(IdxBegin, IdxEnd));

    if (NumIdx > 0)

      return getIndexedType(Ptr, &*IdxBegin, NumIdx);
    else
      return getIndexedType(Ptr, (Value *const*)0, NumIdx);
  }





  template<typename InputIterator>
  inline GetElementPtrInst(Value *Ptr, InputIterator IdxBegin,
                           InputIterator IdxEnd,
                           unsigned Values,
                           const Twine &NameStr,
                           Instruction *InsertBefore);
  template<typename InputIterator>
  inline GetElementPtrInst(Value *Ptr,
                           InputIterator IdxBegin, InputIterator IdxEnd,
                           unsigned Values,
                           const Twine &NameStr, BasicBlock *InsertAtEnd);



  GetElementPtrInst(Value *Ptr, Value *Idx, const Twine &NameStr = "",
                    Instruction *InsertBefore = 0);
  GetElementPtrInst(Value *Ptr, Value *Idx,
                    const Twine &NameStr, BasicBlock *InsertAtEnd);
protected:
  virtual GetElementPtrInst *clone_impl() const;
public:
  template<typename InputIterator>
  static GetElementPtrInst *Create(Value *Ptr, InputIterator IdxBegin,
                                   InputIterator IdxEnd,
                                   const Twine &NameStr = "",
                                   Instruction *InsertBefore = 0) {
    typename std::iterator_traits<InputIterator>::difference_type Values =
      1 + std::distance(IdxBegin, IdxEnd);
    return new(Values)
      GetElementPtrInst(Ptr, IdxBegin, IdxEnd, Values, NameStr, InsertBefore);
  }
  template<typename InputIterator>
  static GetElementPtrInst *Create(Value *Ptr,
                                   InputIterator IdxBegin, InputIterator IdxEnd,
                                   const Twine &NameStr,
                                   BasicBlock *InsertAtEnd) {
    typename std::iterator_traits<InputIterator>::difference_type Values =
      1 + std::distance(IdxBegin, IdxEnd);
    return new(Values)
      GetElementPtrInst(Ptr, IdxBegin, IdxEnd, Values, NameStr, InsertAtEnd);
  }



  static GetElementPtrInst *Create(Value *Ptr, Value *Idx,
                                   const Twine &NameStr = "",
                                   Instruction *InsertBefore = 0) {
    return new(2) GetElementPtrInst(Ptr, Idx, NameStr, InsertBefore);
  }
  static GetElementPtrInst *Create(Value *Ptr, Value *Idx,
                                   const Twine &NameStr,
                                   BasicBlock *InsertAtEnd) {
    return new(2) GetElementPtrInst(Ptr, Idx, NameStr, InsertAtEnd);
  }



  template<typename InputIterator>
  static GetElementPtrInst *CreateInBounds(Value *Ptr, InputIterator IdxBegin,
                                           InputIterator IdxEnd,
                                           const Twine &NameStr = "",
                                           Instruction *InsertBefore = 0) {
    GetElementPtrInst *GEP = Create(Ptr, IdxBegin, IdxEnd,
                                    NameStr, InsertBefore);
    GEP->setIsInBounds(true);
    return GEP;
  }
  template<typename InputIterator>
  static GetElementPtrInst *CreateInBounds(Value *Ptr,
                                           InputIterator IdxBegin,
                                           InputIterator IdxEnd,
                                           const Twine &NameStr,
                                           BasicBlock *InsertAtEnd) {
    GetElementPtrInst *GEP = Create(Ptr, IdxBegin, IdxEnd,
                                    NameStr, InsertAtEnd);
    GEP->setIsInBounds(true);
    return GEP;
  }
  static GetElementPtrInst *CreateInBounds(Value *Ptr, Value *Idx,
                                           const Twine &NameStr = "",
                                           Instruction *InsertBefore = 0) {
    GetElementPtrInst *GEP = Create(Ptr, Idx, NameStr, InsertBefore);
    GEP->setIsInBounds(true);
    return GEP;
  }
  static GetElementPtrInst *CreateInBounds(Value *Ptr, Value *Idx,
                                           const Twine &NameStr,
                                           BasicBlock *InsertAtEnd) {
    GetElementPtrInst *GEP = Create(Ptr, Idx, NameStr, InsertAtEnd);
    GEP->setIsInBounds(true);
    return GEP;
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  const PointerType *getType() const {
    return reinterpret_cast<const PointerType*>(Instruction::getType());
  }







  template<typename InputIterator>
  static const Type *getIndexedType(const Type *Ptr,
                                    InputIterator IdxBegin,
                                    InputIterator IdxEnd) {
    return getIndexedType(Ptr, IdxBegin, IdxEnd,
                          typename std::iterator_traits<InputIterator>::
                          iterator_category());
  }

  static const Type *getIndexedType(const Type *Ptr,
                                    Value* const *Idx, unsigned NumIdx);

  static const Type *getIndexedType(const Type *Ptr,
                                    uint64_t const *Idx, unsigned NumIdx);

  static const Type *getIndexedType(const Type *Ptr, Value *Idx);

  inline op_iterator idx_begin() { return op_begin()+1; }
  inline const_op_iterator idx_begin() const { return op_begin()+1; }
  inline op_iterator idx_end() { return op_end(); }
  inline const_op_iterator idx_end() const { return op_end(); }

  Value *getPointerOperand() {
    return getOperand(0);
  }
  const Value *getPointerOperand() const {
    return getOperand(0);
  }
  static unsigned getPointerOperandIndex() {
    return 0U;
  }

  unsigned getPointerAddressSpace() const {
    return cast<PointerType>(getType())->getAddressSpace();
  }



  const PointerType *getPointerOperandType() const {
    return reinterpret_cast<const PointerType*>(getPointerOperand()->getType());
  }


  unsigned getNumIndices() const {
    return getNumOperands() - 1;
  }

  bool hasIndices() const {
    return getNumOperands() > 1;
  }




  bool hasAllZeroIndices() const;




  bool hasAllConstantIndices() const;



  void setIsInBounds(bool b = true);


  bool isInBounds() const;


  static inline bool classof(const GetElementPtrInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return (I->getOpcode() == Instruction::GetElementPtr);
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<GetElementPtrInst> : public VariadicOperandTraits<1> {
};

template<typename InputIterator>
GetElementPtrInst::GetElementPtrInst(Value *Ptr,
                                     InputIterator IdxBegin,
                                     InputIterator IdxEnd,
                                     unsigned Values,
                                     const Twine &NameStr,
                                     Instruction *InsertBefore)
  : Instruction(PointerType::get(checkType(
                                   getIndexedType(Ptr->getType(),
                                                  IdxBegin, IdxEnd)),
                                 cast<PointerType>(Ptr->getType())
                                   ->getAddressSpace()),
                GetElementPtr,
                OperandTraits<GetElementPtrInst>::op_end(this) - Values,
                Values, InsertBefore) {
  init(Ptr, IdxBegin, IdxEnd, NameStr,
       typename std::iterator_traits<InputIterator>::iterator_category());
}
template<typename InputIterator>
GetElementPtrInst::GetElementPtrInst(Value *Ptr,
                                     InputIterator IdxBegin,
                                     InputIterator IdxEnd,
                                     unsigned Values,
                                     const Twine &NameStr,
                                     BasicBlock *InsertAtEnd)
  : Instruction(PointerType::get(checkType(
                                   getIndexedType(Ptr->getType(),
                                                  IdxBegin, IdxEnd)),
                                 cast<PointerType>(Ptr->getType())
                                   ->getAddressSpace()),
                GetElementPtr,
                OperandTraits<GetElementPtrInst>::op_end(this) - Values,
                Values, InsertAtEnd) {
  init(Ptr, IdxBegin, IdxEnd, NameStr,
       typename std::iterator_traits<InputIterator>::iterator_category());
}


GetElementPtrInst::op_iterator GetElementPtrInst::op_begin() { return OperandTraits<GetElementPtrInst>::op_begin(this); } GetElementPtrInst::const_op_iterator GetElementPtrInst::op_begin() const { return OperandTraits<GetElementPtrInst>::op_begin(const_cast<GetElementPtrInst*>(this)); } GetElementPtrInst::op_iterator GetElementPtrInst::op_end() { return OperandTraits<GetElementPtrInst>::op_end(this); } GetElementPtrInst::const_op_iterator GetElementPtrInst::op_end() const { return OperandTraits<GetElementPtrInst>::op_end(const_cast<GetElementPtrInst*>(this)); } Value *GetElementPtrInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<GetElementPtrInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<GetElementPtrInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 561, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<GetElementPtrInst>::op_begin(const_cast<GetElementPtrInst*>(this))[i_nocapture]); } void GetElementPtrInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<GetElementPtrInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<GetElementPtrInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 561, __PRETTY_FUNCTION__)); OperandTraits<GetElementPtrInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned GetElementPtrInst::getNumOperands() const { return OperandTraits<GetElementPtrInst>::operands(this); } template <int Idx_nocapture> Use &GetElementPtrInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &GetElementPtrInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 572 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class ICmpInst: public CmpInst {
protected:

  virtual ICmpInst *clone_impl() const;
public:

  ICmpInst(
    Instruction *InsertBefore,
    Predicate pred,
    Value *LHS,
    Value *RHS,
    const Twine &NameStr = ""
  ) : CmpInst(makeCmpResultType(LHS->getType()),
              Instruction::ICmp, pred, LHS, RHS, NameStr,
              InsertBefore) {
    ((pred >= CmpInst::FIRST_ICMP_PREDICATE && pred <= CmpInst::LAST_ICMP_PREDICATE && "Invalid ICmp predicate value") ? static_cast<void> (0) : __assert_fail ("pred >= CmpInst::FIRST_ICMP_PREDICATE && pred <= CmpInst::LAST_ICMP_PREDICATE && \"Invalid ICmp predicate value\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 589, __PRETTY_FUNCTION__));


    ((getOperand(0)->getType() == getOperand(1)->getType() && "Both operands to ICmp instruction are not of the same type!") ? static_cast<void> (0) : __assert_fail ("getOperand(0)->getType() == getOperand(1)->getType() && \"Both operands to ICmp instruction are not of the same type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 591, __PRETTY_FUNCTION__));


    (((getOperand(0)->getType()->isIntOrIntVectorTy() || getOperand(0)->getType()->isPointerTy()) && "Invalid operand types for ICmp instruction") ? static_cast<void> (0) : __assert_fail ("(getOperand(0)->getType()->isIntOrIntVectorTy() || getOperand(0)->getType()->isPointerTy()) && \"Invalid operand types for ICmp instruction\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 595, __PRETTY_FUNCTION__));


  }


  ICmpInst(
    BasicBlock &InsertAtEnd,
    Predicate pred,
    Value *LHS,
    Value *RHS,
    const Twine &NameStr = ""
  ) : CmpInst(makeCmpResultType(LHS->getType()),
              Instruction::ICmp, pred, LHS, RHS, NameStr,
              &InsertAtEnd) {
    ((pred >= CmpInst::FIRST_ICMP_PREDICATE && pred <= CmpInst::LAST_ICMP_PREDICATE && "Invalid ICmp predicate value") ? static_cast<void> (0) : __assert_fail ("pred >= CmpInst::FIRST_ICMP_PREDICATE && pred <= CmpInst::LAST_ICMP_PREDICATE && \"Invalid ICmp predicate value\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 610, __PRETTY_FUNCTION__));


    ((getOperand(0)->getType() == getOperand(1)->getType() && "Both operands to ICmp instruction are not of the same type!") ? static_cast<void> (0) : __assert_fail ("getOperand(0)->getType() == getOperand(1)->getType() && \"Both operands to ICmp instruction are not of the same type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 612, __PRETTY_FUNCTION__));


    (((getOperand(0)->getType()->isIntOrIntVectorTy() || getOperand(0)->getType()->isPointerTy()) && "Invalid operand types for ICmp instruction") ? static_cast<void> (0) : __assert_fail ("(getOperand(0)->getType()->isIntOrIntVectorTy() || getOperand(0)->getType()->isPointerTy()) && \"Invalid operand types for ICmp instruction\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 616, __PRETTY_FUNCTION__));


  }


  ICmpInst(
    Predicate pred,
    Value *LHS,
    Value *RHS,
    const Twine &NameStr = ""
  ) : CmpInst(makeCmpResultType(LHS->getType()),
              Instruction::ICmp, pred, LHS, RHS, NameStr) {
    ((pred >= CmpInst::FIRST_ICMP_PREDICATE && pred <= CmpInst::LAST_ICMP_PREDICATE && "Invalid ICmp predicate value") ? static_cast<void> (0) : __assert_fail ("pred >= CmpInst::FIRST_ICMP_PREDICATE && pred <= CmpInst::LAST_ICMP_PREDICATE && \"Invalid ICmp predicate value\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 629, __PRETTY_FUNCTION__));


    ((getOperand(0)->getType() == getOperand(1)->getType() && "Both operands to ICmp instruction are not of the same type!") ? static_cast<void> (0) : __assert_fail ("getOperand(0)->getType() == getOperand(1)->getType() && \"Both operands to ICmp instruction are not of the same type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 631, __PRETTY_FUNCTION__));


    (((getOperand(0)->getType()->isIntOrIntVectorTy() || getOperand(0)->getType()->isPointerTy()) && "Invalid operand types for ICmp instruction") ? static_cast<void> (0) : __assert_fail ("(getOperand(0)->getType()->isIntOrIntVectorTy() || getOperand(0)->getType()->isPointerTy()) && \"Invalid operand types for ICmp instruction\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 635, __PRETTY_FUNCTION__));


  }





  Predicate getSignedPredicate() const {
    return getSignedPredicate(getPredicate());
  }



  static Predicate getSignedPredicate(Predicate pred);





  Predicate getUnsignedPredicate() const {
    return getUnsignedPredicate(getPredicate());
  }



  static Predicate getUnsignedPredicate(Predicate pred);



  static bool isEquality(Predicate P) {
    return P == ICMP_EQ || P == ICMP_NE;
  }



  bool isEquality() const {
    return isEquality(getPredicate());
  }



  bool isCommutative() const { return isEquality(); }



  bool isRelational() const {
    return !isEquality();
  }



  static bool isRelational(Predicate P) {
    return !isEquality(P);
  }



  static ConstantRange makeConstantRange(Predicate pred, const APInt &C);






  void swapOperands() {
    setPredicate(getSwappedPredicate());
    Op<0>().swap(Op<1>());
  }


  static inline bool classof(const ICmpInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::ICmp;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }

};
# 723 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class FCmpInst: public CmpInst {
protected:

  virtual FCmpInst *clone_impl() const;
public:

  FCmpInst(
    Instruction *InsertBefore,
    Predicate pred,
    Value *LHS,
    Value *RHS,
    const Twine &NameStr = ""
  ) : CmpInst(makeCmpResultType(LHS->getType()),
              Instruction::FCmp, pred, LHS, RHS, NameStr,
              InsertBefore) {
    ((pred <= FCmpInst::LAST_FCMP_PREDICATE && "Invalid FCmp predicate value") ? static_cast<void> (0) : __assert_fail ("pred <= FCmpInst::LAST_FCMP_PREDICATE && \"Invalid FCmp predicate value\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 739, __PRETTY_FUNCTION__));

    ((getOperand(0)->getType() == getOperand(1)->getType() && "Both operands to FCmp instruction are not of the same type!") ? static_cast<void> (0) : __assert_fail ("getOperand(0)->getType() == getOperand(1)->getType() && \"Both operands to FCmp instruction are not of the same type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 741, __PRETTY_FUNCTION__));


    ((getOperand(0)->getType()->isFPOrFPVectorTy() && "Invalid operand types for FCmp instruction") ? static_cast<void> (0) : __assert_fail ("getOperand(0)->getType()->isFPOrFPVectorTy() && \"Invalid operand types for FCmp instruction\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 744, __PRETTY_FUNCTION__));

  }


  FCmpInst(
    BasicBlock &InsertAtEnd,
    Predicate pred,
    Value *LHS,
    Value *RHS,
    const Twine &NameStr = ""
  ) : CmpInst(makeCmpResultType(LHS->getType()),
              Instruction::FCmp, pred, LHS, RHS, NameStr,
              &InsertAtEnd) {
    ((pred <= FCmpInst::LAST_FCMP_PREDICATE && "Invalid FCmp predicate value") ? static_cast<void> (0) : __assert_fail ("pred <= FCmpInst::LAST_FCMP_PREDICATE && \"Invalid FCmp predicate value\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 758, __PRETTY_FUNCTION__));

    ((getOperand(0)->getType() == getOperand(1)->getType() && "Both operands to FCmp instruction are not of the same type!") ? static_cast<void> (0) : __assert_fail ("getOperand(0)->getType() == getOperand(1)->getType() && \"Both operands to FCmp instruction are not of the same type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 760, __PRETTY_FUNCTION__));


    ((getOperand(0)->getType()->isFPOrFPVectorTy() && "Invalid operand types for FCmp instruction") ? static_cast<void> (0) : __assert_fail ("getOperand(0)->getType()->isFPOrFPVectorTy() && \"Invalid operand types for FCmp instruction\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 763, __PRETTY_FUNCTION__));

  }


  FCmpInst(
    Predicate pred,
    Value *LHS,
    Value *RHS,
    const Twine &NameStr = ""
  ) : CmpInst(makeCmpResultType(LHS->getType()),
              Instruction::FCmp, pred, LHS, RHS, NameStr) {
    ((pred <= FCmpInst::LAST_FCMP_PREDICATE && "Invalid FCmp predicate value") ? static_cast<void> (0) : __assert_fail ("pred <= FCmpInst::LAST_FCMP_PREDICATE && \"Invalid FCmp predicate value\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 775, __PRETTY_FUNCTION__));

    ((getOperand(0)->getType() == getOperand(1)->getType() && "Both operands to FCmp instruction are not of the same type!") ? static_cast<void> (0) : __assert_fail ("getOperand(0)->getType() == getOperand(1)->getType() && \"Both operands to FCmp instruction are not of the same type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 777, __PRETTY_FUNCTION__));


    ((getOperand(0)->getType()->isFPOrFPVectorTy() && "Invalid operand types for FCmp instruction") ? static_cast<void> (0) : __assert_fail ("getOperand(0)->getType()->isFPOrFPVectorTy() && \"Invalid operand types for FCmp instruction\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 780, __PRETTY_FUNCTION__));

  }



  bool isEquality() const {
    return getPredicate() == FCMP_OEQ || getPredicate() == FCMP_ONE ||
           getPredicate() == FCMP_UEQ || getPredicate() == FCMP_UNE;
  }



  bool isCommutative() const {
    return isEquality() ||
           getPredicate() == FCMP_FALSE ||
           getPredicate() == FCMP_TRUE ||
           getPredicate() == FCMP_ORD ||
           getPredicate() == FCMP_UNO;
  }



  bool isRelational() const { return !isEquality(); }






  void swapOperands() {
    setPredicate(getSwappedPredicate());
    Op<0>().swap(Op<1>());
  }


  static inline bool classof(const FCmpInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::FCmp;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};







class CallInst : public Instruction {
  AttrListPtr AttributeList;
  CallInst(const CallInst &CI);
  void init(Value *Func, Value* const *Params, unsigned NumParams);
  void init(Value *Func, Value *Actual1, Value *Actual2);
  void init(Value *Func, Value *Actual);
  void init(Value *Func);

  template<typename InputIterator>
  void init(Value *Func, InputIterator ArgBegin, InputIterator ArgEnd,
            const Twine &NameStr,


            std::random_access_iterator_tag) {
    unsigned NumArgs = (unsigned)std::distance(ArgBegin, ArgEnd);


    init(Func, NumArgs ? &*ArgBegin : 0, NumArgs);
    setName(NameStr);
  }







  template<typename InputIterator>
  CallInst(Value *Func, InputIterator ArgBegin, InputIterator ArgEnd,
           const Twine &NameStr, Instruction *InsertBefore);







  template<typename InputIterator>
  inline CallInst(Value *Func, InputIterator ArgBegin, InputIterator ArgEnd,
                  const Twine &NameStr, BasicBlock *InsertAtEnd);

  CallInst(Value *F, Value *Actual, const Twine &NameStr,
           Instruction *InsertBefore);
  CallInst(Value *F, Value *Actual, const Twine &NameStr,
           BasicBlock *InsertAtEnd);
  explicit CallInst(Value *F, const Twine &NameStr,
                    Instruction *InsertBefore);
  CallInst(Value *F, const Twine &NameStr, BasicBlock *InsertAtEnd);
protected:
  virtual CallInst *clone_impl() const;
public:
  template<typename InputIterator>
  static CallInst *Create(Value *Func,
                          InputIterator ArgBegin, InputIterator ArgEnd,
                          const Twine &NameStr = "",
                          Instruction *InsertBefore = 0) {
    return new((unsigned)(ArgEnd - ArgBegin + 1))
      CallInst(Func, ArgBegin, ArgEnd, NameStr, InsertBefore);
  }
  template<typename InputIterator>
  static CallInst *Create(Value *Func,
                          InputIterator ArgBegin, InputIterator ArgEnd,
                          const Twine &NameStr, BasicBlock *InsertAtEnd) {
    return new((unsigned)(ArgEnd - ArgBegin + 1))
      CallInst(Func, ArgBegin, ArgEnd, NameStr, InsertAtEnd);
  }
  static CallInst *Create(Value *F, Value *Actual,
                          const Twine &NameStr = "",
                          Instruction *InsertBefore = 0) {
    return new(2) CallInst(F, Actual, NameStr, InsertBefore);
  }
  static CallInst *Create(Value *F, Value *Actual, const Twine &NameStr,
                          BasicBlock *InsertAtEnd) {
    return new(2) CallInst(F, Actual, NameStr, InsertAtEnd);
  }
  static CallInst *Create(Value *F, const Twine &NameStr = "",
                          Instruction *InsertBefore = 0) {
    return new(1) CallInst(F, NameStr, InsertBefore);
  }
  static CallInst *Create(Value *F, const Twine &NameStr,
                          BasicBlock *InsertAtEnd) {
    return new(1) CallInst(F, NameStr, InsertAtEnd);
  }






  static Instruction *CreateMalloc(Instruction *InsertBefore,
                                   const Type *IntPtrTy, const Type *AllocTy,
                                   Value *AllocSize, Value *ArraySize = 0,
                                   const Twine &Name = "");
  static Instruction *CreateMalloc(BasicBlock *InsertAtEnd,
                                   const Type *IntPtrTy, const Type *AllocTy,
                                   Value *AllocSize, Value *ArraySize = 0,
                                   Function* MallocF = 0,
                                   const Twine &Name = "");

  static void CreateFree(Value* Source, Instruction *InsertBefore);
  static Instruction* CreateFree(Value* Source, BasicBlock *InsertAtEnd);

  ~CallInst();

  bool isTailCall() const { return getSubclassDataFromInstruction() & 1; }
  void setTailCall(bool isTC = true) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & ~1) |
                               unsigned(isTC));
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;



  CallingConv::ID getCallingConv() const {
    return static_cast<CallingConv::ID>(getSubclassDataFromInstruction() >> 1);
  }
  void setCallingConv(CallingConv::ID CC) {
    setInstructionSubclassData((getSubclassDataFromInstruction() & 1) |
                               (static_cast<unsigned>(CC) << 1));
  }



  const AttrListPtr &getAttributes() const { return AttributeList; }



  void setAttributes(const AttrListPtr &Attrs) { AttributeList = Attrs; }


  void addAttribute(unsigned i, Attributes attr);


  void removeAttribute(unsigned i, Attributes attr);


  bool paramHasAttr(unsigned i, Attributes attr) const;


  unsigned getParamAlignment(unsigned i) const {
    return AttributeList.getParamAlignment(i);
  }


  bool doesNotAccessMemory() const {
    return paramHasAttr(~0, Attribute::ReadNone);
  }
  void setDoesNotAccessMemory(bool NotAccessMemory = true) {
    if (NotAccessMemory) addAttribute(~0, Attribute::ReadNone);
    else removeAttribute(~0, Attribute::ReadNone);
  }


  bool onlyReadsMemory() const {
    return doesNotAccessMemory() || paramHasAttr(~0, Attribute::ReadOnly);
  }
  void setOnlyReadsMemory(bool OnlyReadsMemory = true) {
    if (OnlyReadsMemory) addAttribute(~0, Attribute::ReadOnly);
    else removeAttribute(~0, Attribute::ReadOnly | Attribute::ReadNone);
  }


  bool doesNotReturn() const {
    return paramHasAttr(~0, Attribute::NoReturn);
  }
  void setDoesNotReturn(bool DoesNotReturn = true) {
    if (DoesNotReturn) addAttribute(~0, Attribute::NoReturn);
    else removeAttribute(~0, Attribute::NoReturn);
  }


  bool doesNotThrow() const {
    return paramHasAttr(~0, Attribute::NoUnwind);
  }
  void setDoesNotThrow(bool DoesNotThrow = true) {
    if (DoesNotThrow) addAttribute(~0, Attribute::NoUnwind);
    else removeAttribute(~0, Attribute::NoUnwind);
  }



  bool hasStructRetAttr() const {

    return paramHasAttr(1, Attribute::StructRet);
  }


  bool hasByValArgument() const {
    return AttributeList.hasAttrSomewhere(Attribute::ByVal);
  }




  Function *getCalledFunction() const {
    return dyn_cast<Function>(Op<0>());
  }



  const Value *getCalledValue() const { return Op<0>(); }
        Value *getCalledValue() { return Op<0>(); }


  void setCalledFunction(Value* Fn) {
    Op<0>() = Fn;
  }


  static inline bool classof(const CallInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Call;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:


  void setInstructionSubclassData(unsigned short D) {
    Instruction::setInstructionSubclassData(D);
  }
};

template <>
struct OperandTraits<CallInst> : public VariadicOperandTraits<1> {
};

template<typename InputIterator>
CallInst::CallInst(Value *Func, InputIterator ArgBegin, InputIterator ArgEnd,
                   const Twine &NameStr, BasicBlock *InsertAtEnd)
  : Instruction(cast<FunctionType>(cast<PointerType>(Func->getType())
                                   ->getElementType())->getReturnType(),
                Instruction::Call,
                OperandTraits<CallInst>::op_end(this) - (ArgEnd - ArgBegin + 1),
                (unsigned)(ArgEnd - ArgBegin + 1), InsertAtEnd) {
  init(Func, ArgBegin, ArgEnd, NameStr,
       typename std::iterator_traits<InputIterator>::iterator_category());
}

template<typename InputIterator>
CallInst::CallInst(Value *Func, InputIterator ArgBegin, InputIterator ArgEnd,
                   const Twine &NameStr, Instruction *InsertBefore)
  : Instruction(cast<FunctionType>(cast<PointerType>(Func->getType())
                                   ->getElementType())->getReturnType(),
                Instruction::Call,
                OperandTraits<CallInst>::op_end(this) - (ArgEnd - ArgBegin + 1),
                (unsigned)(ArgEnd - ArgBegin + 1), InsertBefore) {
  init(Func, ArgBegin, ArgEnd, NameStr,
       typename std::iterator_traits<InputIterator>::iterator_category());
}

CallInst::op_iterator CallInst::op_begin() { return OperandTraits<CallInst>::op_begin(this); } CallInst::const_op_iterator CallInst::op_begin() const { return OperandTraits<CallInst>::op_begin(const_cast<CallInst*>(this)); } CallInst::op_iterator CallInst::op_end() { return OperandTraits<CallInst>::op_end(this); } CallInst::const_op_iterator CallInst::op_end() const { return OperandTraits<CallInst>::op_end(const_cast<CallInst*>(this)); } Value *CallInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<CallInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<CallInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1084, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<CallInst>::op_begin(const_cast<CallInst*>(this))[i_nocapture]); } void CallInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<CallInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<CallInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1084, __PRETTY_FUNCTION__)); OperandTraits<CallInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned CallInst::getNumOperands() const { return OperandTraits<CallInst>::operands(this); } template <int Idx_nocapture> Use &CallInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &CallInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }







class SelectInst : public Instruction {
  void init(Value *C, Value *S1, Value *S2) {
    ((!areInvalidOperands(C, S1, S2) && "Invalid operands for select") ? static_cast<void> (0) : __assert_fail ("!areInvalidOperands(C, S1, S2) && \"Invalid operands for select\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1094, __PRETTY_FUNCTION__));
    Op<0>() = C;
    Op<1>() = S1;
    Op<2>() = S2;
  }

  SelectInst(Value *C, Value *S1, Value *S2, const Twine &NameStr,
             Instruction *InsertBefore)
    : Instruction(S1->getType(), Instruction::Select,
                  &Op<0>(), 3, InsertBefore) {
    init(C, S1, S2);
    setName(NameStr);
  }
  SelectInst(Value *C, Value *S1, Value *S2, const Twine &NameStr,
             BasicBlock *InsertAtEnd)
    : Instruction(S1->getType(), Instruction::Select,
                  &Op<0>(), 3, InsertAtEnd) {
    init(C, S1, S2);
    setName(NameStr);
  }
protected:
  virtual SelectInst *clone_impl() const;
public:
  static SelectInst *Create(Value *C, Value *S1, Value *S2,
                            const Twine &NameStr = "",
                            Instruction *InsertBefore = 0) {
    return new(3) SelectInst(C, S1, S2, NameStr, InsertBefore);
  }
  static SelectInst *Create(Value *C, Value *S1, Value *S2,
                            const Twine &NameStr,
                            BasicBlock *InsertAtEnd) {
    return new(3) SelectInst(C, S1, S2, NameStr, InsertAtEnd);
  }

  const Value *getCondition() const { return Op<0>(); }
  const Value *getTrueValue() const { return Op<1>(); }
  const Value *getFalseValue() const { return Op<2>(); }
  Value *getCondition() { return Op<0>(); }
  Value *getTrueValue() { return Op<1>(); }
  Value *getFalseValue() { return Op<2>(); }



  static const char *areInvalidOperands(Value *Cond, Value *True, Value *False);


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;

  OtherOps getOpcode() const {
    return static_cast<OtherOps>(Instruction::getOpcode());
  }


  static inline bool classof(const SelectInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Select;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<SelectInst> : public FixedNumOperandTraits<3> {
};

SelectInst::op_iterator SelectInst::op_begin() { return OperandTraits<SelectInst>::op_begin(this); } SelectInst::const_op_iterator SelectInst::op_begin() const { return OperandTraits<SelectInst>::op_begin(const_cast<SelectInst*>(this)); } SelectInst::op_iterator SelectInst::op_end() { return OperandTraits<SelectInst>::op_end(this); } SelectInst::const_op_iterator SelectInst::op_end() const { return OperandTraits<SelectInst>::op_end(const_cast<SelectInst*>(this)); } Value *SelectInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<SelectInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<SelectInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1160, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<SelectInst>::op_begin(const_cast<SelectInst*>(this))[i_nocapture]); } void SelectInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<SelectInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<SelectInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1160, __PRETTY_FUNCTION__)); OperandTraits<SelectInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned SelectInst::getNumOperands() const { return OperandTraits<SelectInst>::operands(this); } template <int Idx_nocapture> Use &SelectInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &SelectInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 1169 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class VAArgInst : public UnaryInstruction {
protected:
  virtual VAArgInst *clone_impl() const;

public:
  VAArgInst(Value *List, const Type *Ty, const Twine &NameStr = "",
             Instruction *InsertBefore = 0)
    : UnaryInstruction(Ty, VAArg, List, InsertBefore) {
    setName(NameStr);
  }
  VAArgInst(Value *List, const Type *Ty, const Twine &NameStr,
            BasicBlock *InsertAtEnd)
    : UnaryInstruction(Ty, VAArg, List, InsertAtEnd) {
    setName(NameStr);
  }


  static inline bool classof(const VAArgInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == VAArg;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};
# 1202 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class ExtractElementInst : public Instruction {
  ExtractElementInst(Value *Vec, Value *Idx, const Twine &NameStr = "",
                     Instruction *InsertBefore = 0);
  ExtractElementInst(Value *Vec, Value *Idx, const Twine &NameStr,
                     BasicBlock *InsertAtEnd);
protected:
  virtual ExtractElementInst *clone_impl() const;

public:
  static ExtractElementInst *Create(Value *Vec, Value *Idx,
                                   const Twine &NameStr = "",
                                   Instruction *InsertBefore = 0) {
    return new(2) ExtractElementInst(Vec, Idx, NameStr, InsertBefore);
  }
  static ExtractElementInst *Create(Value *Vec, Value *Idx,
                                   const Twine &NameStr,
                                   BasicBlock *InsertAtEnd) {
    return new(2) ExtractElementInst(Vec, Idx, NameStr, InsertAtEnd);
  }



  static bool isValidOperands(const Value *Vec, const Value *Idx);

  Value *getVectorOperand() { return Op<0>(); }
  Value *getIndexOperand() { return Op<1>(); }
  const Value *getVectorOperand() const { return Op<0>(); }
  const Value *getIndexOperand() const { return Op<1>(); }

  const VectorType *getVectorOperandType() const {
    return reinterpret_cast<const VectorType*>(getVectorOperand()->getType());
  }



  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  static inline bool classof(const ExtractElementInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::ExtractElement;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<ExtractElementInst> : public FixedNumOperandTraits<2> {
};

ExtractElementInst::op_iterator ExtractElementInst::op_begin() { return OperandTraits<ExtractElementInst>::op_begin(this); } ExtractElementInst::const_op_iterator ExtractElementInst::op_begin() const { return OperandTraits<ExtractElementInst>::op_begin(const_cast<ExtractElementInst*>(this)); } ExtractElementInst::op_iterator ExtractElementInst::op_end() { return OperandTraits<ExtractElementInst>::op_end(this); } ExtractElementInst::const_op_iterator ExtractElementInst::op_end() const { return OperandTraits<ExtractElementInst>::op_end(const_cast<ExtractElementInst*>(this)); } Value *ExtractElementInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<ExtractElementInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ExtractElementInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1253, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<ExtractElementInst>::op_begin(const_cast<ExtractElementInst*>(this))[i_nocapture]); } void ExtractElementInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<ExtractElementInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ExtractElementInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1253, __PRETTY_FUNCTION__)); OperandTraits<ExtractElementInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ExtractElementInst::getNumOperands() const { return OperandTraits<ExtractElementInst>::operands(this); } template <int Idx_nocapture> Use &ExtractElementInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ExtractElementInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 1262 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class InsertElementInst : public Instruction {
  InsertElementInst(Value *Vec, Value *NewElt, Value *Idx,
                    const Twine &NameStr = "",
                    Instruction *InsertBefore = 0);
  InsertElementInst(Value *Vec, Value *NewElt, Value *Idx,
                    const Twine &NameStr, BasicBlock *InsertAtEnd);
protected:
  virtual InsertElementInst *clone_impl() const;

public:
  static InsertElementInst *Create(Value *Vec, Value *NewElt, Value *Idx,
                                   const Twine &NameStr = "",
                                   Instruction *InsertBefore = 0) {
    return new(3) InsertElementInst(Vec, NewElt, Idx, NameStr, InsertBefore);
  }
  static InsertElementInst *Create(Value *Vec, Value *NewElt, Value *Idx,
                                   const Twine &NameStr,
                                   BasicBlock *InsertAtEnd) {
    return new(3) InsertElementInst(Vec, NewElt, Idx, NameStr, InsertAtEnd);
  }



  static bool isValidOperands(const Value *Vec, const Value *NewElt,
                              const Value *Idx);



  const VectorType *getType() const {
    return reinterpret_cast<const VectorType*>(Instruction::getType());
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  static inline bool classof(const InsertElementInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::InsertElement;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<InsertElementInst> : public FixedNumOperandTraits<3> {
};

InsertElementInst::op_iterator InsertElementInst::op_begin() { return OperandTraits<InsertElementInst>::op_begin(this); } InsertElementInst::const_op_iterator InsertElementInst::op_begin() const { return OperandTraits<InsertElementInst>::op_begin(const_cast<InsertElementInst*>(this)); } InsertElementInst::op_iterator InsertElementInst::op_end() { return OperandTraits<InsertElementInst>::op_end(this); } InsertElementInst::const_op_iterator InsertElementInst::op_end() const { return OperandTraits<InsertElementInst>::op_end(const_cast<InsertElementInst*>(this)); } Value *InsertElementInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<InsertElementInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<InsertElementInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1311, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<InsertElementInst>::op_begin(const_cast<InsertElementInst*>(this))[i_nocapture]); } void InsertElementInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<InsertElementInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<InsertElementInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1311, __PRETTY_FUNCTION__)); OperandTraits<InsertElementInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned InsertElementInst::getNumOperands() const { return OperandTraits<InsertElementInst>::operands(this); } template <int Idx_nocapture> Use &InsertElementInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &InsertElementInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 1320 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class ShuffleVectorInst : public Instruction {
protected:
  virtual ShuffleVectorInst *clone_impl() const;

public:

  void *operator new(size_t s) {
    return User::operator new(s, 3);
  }
  ShuffleVectorInst(Value *V1, Value *V2, Value *Mask,
                    const Twine &NameStr = "",
                    Instruction *InsertBefor = 0);
  ShuffleVectorInst(Value *V1, Value *V2, Value *Mask,
                    const Twine &NameStr, BasicBlock *InsertAtEnd);



  static bool isValidOperands(const Value *V1, const Value *V2,
                              const Value *Mask);



  const VectorType *getType() const {
    return reinterpret_cast<const VectorType*>(Instruction::getType());
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;




  int getMaskValue(unsigned i) const;


  static inline bool classof(const ShuffleVectorInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::ShuffleVector;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<ShuffleVectorInst> : public FixedNumOperandTraits<3> {
};

ShuffleVectorInst::op_iterator ShuffleVectorInst::op_begin() { return OperandTraits<ShuffleVectorInst>::op_begin(this); } ShuffleVectorInst::const_op_iterator ShuffleVectorInst::op_begin() const { return OperandTraits<ShuffleVectorInst>::op_begin(const_cast<ShuffleVectorInst*>(this)); } ShuffleVectorInst::op_iterator ShuffleVectorInst::op_end() { return OperandTraits<ShuffleVectorInst>::op_end(this); } ShuffleVectorInst::const_op_iterator ShuffleVectorInst::op_end() const { return OperandTraits<ShuffleVectorInst>::op_end(const_cast<ShuffleVectorInst*>(this)); } Value *ShuffleVectorInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<ShuffleVectorInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ShuffleVectorInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1368, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<ShuffleVectorInst>::op_begin(const_cast<ShuffleVectorInst*>(this))[i_nocapture]); } void ShuffleVectorInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<ShuffleVectorInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ShuffleVectorInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1368, __PRETTY_FUNCTION__)); OperandTraits<ShuffleVectorInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ShuffleVectorInst::getNumOperands() const { return OperandTraits<ShuffleVectorInst>::operands(this); } template <int Idx_nocapture> Use &ShuffleVectorInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ShuffleVectorInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 1377 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class ExtractValueInst : public UnaryInstruction {
  SmallVector<unsigned, 4> Indices;

  ExtractValueInst(const ExtractValueInst &EVI);
  void init(const unsigned *Idx, unsigned NumIdx,
            const Twine &NameStr);
  void init(unsigned Idx, const Twine &NameStr);

  template<typename InputIterator>
  void init(InputIterator IdxBegin, InputIterator IdxEnd,
            const Twine &NameStr,


            std::random_access_iterator_tag) {
    unsigned NumIdx = static_cast<unsigned>(std::distance(IdxBegin, IdxEnd));





    ((NumIdx > 0 && "ExtractValueInst must have at least one index") ? static_cast<void> (0) : __assert_fail ("NumIdx > 0 && \"ExtractValueInst must have at least one index\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1397, __PRETTY_FUNCTION__));


    init(&*IdxBegin, NumIdx, NameStr);

  }







  static const Type *getIndexedType(const Type *Agg,
                                    const unsigned *Idx, unsigned NumIdx);

  template<typename InputIterator>
  static const Type *getIndexedType(const Type *Ptr,
                                    InputIterator IdxBegin,
                                    InputIterator IdxEnd,



                                    std::random_access_iterator_tag) {
    unsigned NumIdx = static_cast<unsigned>(std::distance(IdxBegin, IdxEnd));

    if (NumIdx > 0)

      return getIndexedType(Ptr, &*IdxBegin, NumIdx);
    else
      return getIndexedType(Ptr, (const unsigned *)0, NumIdx);
  }





  template<typename InputIterator>
  inline ExtractValueInst(Value *Agg, InputIterator IdxBegin,
                          InputIterator IdxEnd,
                          const Twine &NameStr,
                          Instruction *InsertBefore);
  template<typename InputIterator>
  inline ExtractValueInst(Value *Agg,
                          InputIterator IdxBegin, InputIterator IdxEnd,
                          const Twine &NameStr, BasicBlock *InsertAtEnd);


  void *operator new(size_t s) {
    return User::operator new(s, 1);
  }
protected:
  virtual ExtractValueInst *clone_impl() const;

public:
  template<typename InputIterator>
  static ExtractValueInst *Create(Value *Agg, InputIterator IdxBegin,
                                  InputIterator IdxEnd,
                                  const Twine &NameStr = "",
                                  Instruction *InsertBefore = 0) {
    return new
      ExtractValueInst(Agg, IdxBegin, IdxEnd, NameStr, InsertBefore);
  }
  template<typename InputIterator>
  static ExtractValueInst *Create(Value *Agg,
                                  InputIterator IdxBegin, InputIterator IdxEnd,
                                  const Twine &NameStr,
                                  BasicBlock *InsertAtEnd) {
    return new ExtractValueInst(Agg, IdxBegin, IdxEnd, NameStr, InsertAtEnd);
  }




  static ExtractValueInst *Create(Value *Agg, unsigned Idx,
                                  const Twine &NameStr = "",
                                  Instruction *InsertBefore = 0) {
    unsigned Idxs[1] = { Idx };
    return new ExtractValueInst(Agg, Idxs, Idxs + 1, NameStr, InsertBefore);
  }
  static ExtractValueInst *Create(Value *Agg, unsigned Idx,
                                  const Twine &NameStr,
                                  BasicBlock *InsertAtEnd) {
    unsigned Idxs[1] = { Idx };
    return new ExtractValueInst(Agg, Idxs, Idxs + 1, NameStr, InsertAtEnd);
  }







  template<typename InputIterator>
  static const Type *getIndexedType(const Type *Ptr,
                                    InputIterator IdxBegin,
                                    InputIterator IdxEnd) {
    return getIndexedType(Ptr, IdxBegin, IdxEnd,
                          typename std::iterator_traits<InputIterator>::
                          iterator_category());
  }
  static const Type *getIndexedType(const Type *Ptr, unsigned Idx);

  typedef const unsigned* idx_iterator;
  inline idx_iterator idx_begin() const { return Indices.begin(); }
  inline idx_iterator idx_end() const { return Indices.end(); }

  Value *getAggregateOperand() {
    return getOperand(0);
  }
  const Value *getAggregateOperand() const {
    return getOperand(0);
  }
  static unsigned getAggregateOperandIndex() {
    return 0U;
  }

  unsigned getNumIndices() const {
    return (unsigned)Indices.size();
  }

  bool hasIndices() const {
    return true;
  }


  static inline bool classof(const ExtractValueInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::ExtractValue;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template<typename InputIterator>
ExtractValueInst::ExtractValueInst(Value *Agg,
                                   InputIterator IdxBegin,
                                   InputIterator IdxEnd,
                                   const Twine &NameStr,
                                   Instruction *InsertBefore)
  : UnaryInstruction(checkType(getIndexedType(Agg->getType(),
                                              IdxBegin, IdxEnd)),
                     ExtractValue, Agg, InsertBefore) {
  init(IdxBegin, IdxEnd, NameStr,
       typename std::iterator_traits<InputIterator>::iterator_category());
}
template<typename InputIterator>
ExtractValueInst::ExtractValueInst(Value *Agg,
                                   InputIterator IdxBegin,
                                   InputIterator IdxEnd,
                                   const Twine &NameStr,
                                   BasicBlock *InsertAtEnd)
  : UnaryInstruction(checkType(getIndexedType(Agg->getType(),
                                              IdxBegin, IdxEnd)),
                     ExtractValue, Agg, InsertAtEnd) {
  init(IdxBegin, IdxEnd, NameStr,
       typename std::iterator_traits<InputIterator>::iterator_category());
}
# 1565 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class InsertValueInst : public Instruction {
  SmallVector<unsigned, 4> Indices;

  void *operator new(size_t, unsigned);
  InsertValueInst(const InsertValueInst &IVI);
  void init(Value *Agg, Value *Val, const unsigned *Idx, unsigned NumIdx,
            const Twine &NameStr);
  void init(Value *Agg, Value *Val, unsigned Idx, const Twine &NameStr);

  template<typename InputIterator>
  void init(Value *Agg, Value *Val,
            InputIterator IdxBegin, InputIterator IdxEnd,
            const Twine &NameStr,


            std::random_access_iterator_tag) {
    unsigned NumIdx = static_cast<unsigned>(std::distance(IdxBegin, IdxEnd));





    ((NumIdx > 0 && "InsertValueInst must have at least one index") ? static_cast<void> (0) : __assert_fail ("NumIdx > 0 && \"InsertValueInst must have at least one index\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1587, __PRETTY_FUNCTION__));


    init(Agg, Val, &*IdxBegin, NumIdx, NameStr);

  }





  template<typename InputIterator>
  inline InsertValueInst(Value *Agg, Value *Val, InputIterator IdxBegin,
                         InputIterator IdxEnd,
                         const Twine &NameStr,
                         Instruction *InsertBefore);
  template<typename InputIterator>
  inline InsertValueInst(Value *Agg, Value *Val,
                         InputIterator IdxBegin, InputIterator IdxEnd,
                         const Twine &NameStr, BasicBlock *InsertAtEnd);



  InsertValueInst(Value *Agg, Value *Val,
                  unsigned Idx, const Twine &NameStr = "",
                  Instruction *InsertBefore = 0);
  InsertValueInst(Value *Agg, Value *Val, unsigned Idx,
                  const Twine &NameStr, BasicBlock *InsertAtEnd);
protected:
  virtual InsertValueInst *clone_impl() const;
public:

  void *operator new(size_t s) {
    return User::operator new(s, 2);
  }

  template<typename InputIterator>
  static InsertValueInst *Create(Value *Agg, Value *Val, InputIterator IdxBegin,
                                 InputIterator IdxEnd,
                                 const Twine &NameStr = "",
                                 Instruction *InsertBefore = 0) {
    return new InsertValueInst(Agg, Val, IdxBegin, IdxEnd,
                               NameStr, InsertBefore);
  }
  template<typename InputIterator>
  static InsertValueInst *Create(Value *Agg, Value *Val,
                                 InputIterator IdxBegin, InputIterator IdxEnd,
                                 const Twine &NameStr,
                                 BasicBlock *InsertAtEnd) {
    return new InsertValueInst(Agg, Val, IdxBegin, IdxEnd,
                               NameStr, InsertAtEnd);
  }




  static InsertValueInst *Create(Value *Agg, Value *Val, unsigned Idx,
                                 const Twine &NameStr = "",
                                 Instruction *InsertBefore = 0) {
    return new InsertValueInst(Agg, Val, Idx, NameStr, InsertBefore);
  }
  static InsertValueInst *Create(Value *Agg, Value *Val, unsigned Idx,
                                 const Twine &NameStr,
                                 BasicBlock *InsertAtEnd) {
    return new InsertValueInst(Agg, Val, Idx, NameStr, InsertAtEnd);
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;

  typedef const unsigned* idx_iterator;
  inline idx_iterator idx_begin() const { return Indices.begin(); }
  inline idx_iterator idx_end() const { return Indices.end(); }

  Value *getAggregateOperand() {
    return getOperand(0);
  }
  const Value *getAggregateOperand() const {
    return getOperand(0);
  }
  static unsigned getAggregateOperandIndex() {
    return 0U;
  }

  Value *getInsertedValueOperand() {
    return getOperand(1);
  }
  const Value *getInsertedValueOperand() const {
    return getOperand(1);
  }
  static unsigned getInsertedValueOperandIndex() {
    return 1U;
  }

  unsigned getNumIndices() const {
    return (unsigned)Indices.size();
  }

  bool hasIndices() const {
    return true;
  }


  static inline bool classof(const InsertValueInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::InsertValue;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

template <>
struct OperandTraits<InsertValueInst> : public FixedNumOperandTraits<2> {
};

template<typename InputIterator>
InsertValueInst::InsertValueInst(Value *Agg,
                                 Value *Val,
                                 InputIterator IdxBegin,
                                 InputIterator IdxEnd,
                                 const Twine &NameStr,
                                 Instruction *InsertBefore)
  : Instruction(Agg->getType(), InsertValue,
                OperandTraits<InsertValueInst>::op_begin(this),
                2, InsertBefore) {
  init(Agg, Val, IdxBegin, IdxEnd, NameStr,
       typename std::iterator_traits<InputIterator>::iterator_category());
}
template<typename InputIterator>
InsertValueInst::InsertValueInst(Value *Agg,
                                 Value *Val,
                                 InputIterator IdxBegin,
                                 InputIterator IdxEnd,
                                 const Twine &NameStr,
                                 BasicBlock *InsertAtEnd)
  : Instruction(Agg->getType(), InsertValue,
                OperandTraits<InsertValueInst>::op_begin(this),
                2, InsertAtEnd) {
  init(Agg, Val, IdxBegin, IdxEnd, NameStr,
       typename std::iterator_traits<InputIterator>::iterator_category());
}

InsertValueInst::op_iterator InsertValueInst::op_begin() { return OperandTraits<InsertValueInst>::op_begin(this); } InsertValueInst::const_op_iterator InsertValueInst::op_begin() const { return OperandTraits<InsertValueInst>::op_begin(const_cast<InsertValueInst*>(this)); } InsertValueInst::op_iterator InsertValueInst::op_end() { return OperandTraits<InsertValueInst>::op_end(this); } InsertValueInst::const_op_iterator InsertValueInst::op_end() const { return OperandTraits<InsertValueInst>::op_end(const_cast<InsertValueInst*>(this)); } Value *InsertValueInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<InsertValueInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<InsertValueInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1730, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<InsertValueInst>::op_begin(const_cast<InsertValueInst*>(this))[i_nocapture]); } void InsertValueInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<InsertValueInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<InsertValueInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1730, __PRETTY_FUNCTION__)); OperandTraits<InsertValueInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned InsertValueInst::getNumOperands() const { return OperandTraits<InsertValueInst>::operands(this); } template <int Idx_nocapture> Use &InsertValueInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &InsertValueInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 1740 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class PHINode : public Instruction {
  void *operator new(size_t, unsigned);


  unsigned ReservedSpace;
  PHINode(const PHINode &PN);

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
  explicit PHINode(const Type *Ty, const Twine &NameStr = "",
                   Instruction *InsertBefore = 0)
    : Instruction(Ty, Instruction::PHI, 0, 0, InsertBefore),
      ReservedSpace(0) {
    setName(NameStr);
  }

  PHINode(const Type *Ty, const Twine &NameStr, BasicBlock *InsertAtEnd)
    : Instruction(Ty, Instruction::PHI, 0, 0, InsertAtEnd),
      ReservedSpace(0) {
    setName(NameStr);
  }
protected:
  virtual PHINode *clone_impl() const;
public:
  static PHINode *Create(const Type *Ty, const Twine &NameStr = "",
                         Instruction *InsertBefore = 0) {
    return new PHINode(Ty, NameStr, InsertBefore);
  }
  static PHINode *Create(const Type *Ty, const Twine &NameStr,
                         BasicBlock *InsertAtEnd) {
    return new PHINode(Ty, NameStr, InsertAtEnd);
  }
  ~PHINode();





  void reserveOperandSpace(unsigned NumValues) {
    resizeOperands(NumValues*2);
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;



  unsigned getNumIncomingValues() const { return getNumOperands()/2; }



  Value *getIncomingValue(unsigned i) const {
    ((i*2 < getNumOperands() && "Invalid value number!") ? static_cast<void> (0) : __assert_fail ("i*2 < getNumOperands() && \"Invalid value number!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1793, __PRETTY_FUNCTION__));
    return getOperand(i*2);
  }
  void setIncomingValue(unsigned i, Value *V) {
    ((i*2 < getNumOperands() && "Invalid value number!") ? static_cast<void> (0) : __assert_fail ("i*2 < getNumOperands() && \"Invalid value number!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1797, __PRETTY_FUNCTION__));
    setOperand(i*2, V);
  }
  static unsigned getOperandNumForIncomingValue(unsigned i) {
    return i*2;
  }
  static unsigned getIncomingValueNumForOperand(unsigned i) {
    ((i % 2 == 0 && "Invalid incoming-value operand index!") ? static_cast<void> (0) : __assert_fail ("i % 2 == 0 && \"Invalid incoming-value operand index!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1804, __PRETTY_FUNCTION__));
    return i/2;
  }



  BasicBlock *getIncomingBlock(unsigned i) const {
    return cast<BasicBlock>(getOperand(i*2+1));
  }




  BasicBlock *getIncomingBlock(const Use &U) const {
    ((this == U.getUser() && "Iterator doesn't point to PHI's Uses?") ? static_cast<void> (0) : __assert_fail ("this == U.getUser() && \"Iterator doesn't point to PHI's Uses?\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1818, __PRETTY_FUNCTION__));
    return cast<BasicBlock>((&U + 1)->get());
  }




  template <typename U>
  BasicBlock *getIncomingBlock(value_use_iterator<U> I) const {
    return getIncomingBlock(I.getUse());
  }


  void setIncomingBlock(unsigned i, BasicBlock *BB) {
    setOperand(i*2+1, (Value*)BB);
  }
  static unsigned getOperandNumForIncomingBlock(unsigned i) {
    return i*2+1;
  }
  static unsigned getIncomingBlockNumForOperand(unsigned i) {
    ((i % 2 == 1 && "Invalid incoming-block operand index!") ? static_cast<void> (0) : __assert_fail ("i % 2 == 1 && \"Invalid incoming-block operand index!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1838, __PRETTY_FUNCTION__));
    return i/2;
  }



  void addIncoming(Value *V, BasicBlock *BB) {
    ((V && "PHI node got a null value!") ? static_cast<void> (0) : __assert_fail ("V && \"PHI node got a null value!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1845, __PRETTY_FUNCTION__));
    ((BB && "PHI node got a null basic block!") ? static_cast<void> (0) : __assert_fail ("BB && \"PHI node got a null basic block!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1846, __PRETTY_FUNCTION__));
    ((getType() == V->getType() && "All operands to PHI node must be the same type as the PHI node!") ? static_cast<void> (0) : __assert_fail ("getType() == V->getType() && \"All operands to PHI node must be the same type as the PHI node!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1848, __PRETTY_FUNCTION__));

    unsigned OpNo = NumOperands;
    if (OpNo+2 > ReservedSpace)
      resizeOperands(0);

    NumOperands = OpNo+2;
    OperandList[OpNo] = V;
    OperandList[OpNo+1] = (Value*)BB;
  }
# 1866 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
  Value *removeIncomingValue(unsigned Idx, bool DeletePHIIfEmpty = true);

  Value *removeIncomingValue(const BasicBlock *BB, bool DeletePHIIfEmpty=true) {
    int Idx = getBasicBlockIndex(BB);
    ((Idx >= 0 && "Invalid basic block argument to remove!") ? static_cast<void> (0) : __assert_fail ("Idx >= 0 && \"Invalid basic block argument to remove!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1870, __PRETTY_FUNCTION__));
    return removeIncomingValue(Idx, DeletePHIIfEmpty);
  }




  int getBasicBlockIndex(const BasicBlock *BB) const {
    Use *OL = OperandList;
    for (unsigned i = 0, e = getNumOperands(); i != e; i += 2)
      if (OL[i+1].get() == (const Value*)BB) return i/2;
    return -1;
  }

  Value *getIncomingValueForBlock(const BasicBlock *BB) const {
    return getIncomingValue(getBasicBlockIndex(BB));
  }
# 1896 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
  Value *hasConstantValue(DominatorTree *DT = 0) const;


  static inline bool classof(const PHINode *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::PHI;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
 private:
  void resizeOperands(unsigned NumOperands);
};

template <>
struct OperandTraits<PHINode> : public HungoffOperandTraits<2> {
};

PHINode::op_iterator PHINode::op_begin() { return OperandTraits<PHINode>::op_begin(this); } PHINode::const_op_iterator PHINode::op_begin() const { return OperandTraits<PHINode>::op_begin(const_cast<PHINode*>(this)); } PHINode::op_iterator PHINode::op_end() { return OperandTraits<PHINode>::op_end(this); } PHINode::const_op_iterator PHINode::op_end() const { return OperandTraits<PHINode>::op_end(const_cast<PHINode*>(this)); } Value *PHINode::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<PHINode>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<PHINode>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1914, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<PHINode>::op_begin(const_cast<PHINode*>(this))[i_nocapture]); } void PHINode::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<PHINode>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<PHINode>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1914, __PRETTY_FUNCTION__)); OperandTraits<PHINode>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned PHINode::getNumOperands() const { return OperandTraits<PHINode>::operands(this); } template <int Idx_nocapture> Use &PHINode::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &PHINode::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 1925 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class ReturnInst : public TerminatorInst {
  ReturnInst(const ReturnInst &RI);

private:
# 1940 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
  explicit ReturnInst(LLVMContext &C, Value *retVal = 0,
                      Instruction *InsertBefore = 0);
  ReturnInst(LLVMContext &C, Value *retVal, BasicBlock *InsertAtEnd);
  explicit ReturnInst(LLVMContext &C, BasicBlock *InsertAtEnd);
protected:
  virtual ReturnInst *clone_impl() const;
public:
  static ReturnInst* Create(LLVMContext &C, Value *retVal = 0,
                            Instruction *InsertBefore = 0) {
    return new(!!retVal) ReturnInst(C, retVal, InsertBefore);
  }
  static ReturnInst* Create(LLVMContext &C, Value *retVal,
                            BasicBlock *InsertAtEnd) {
    return new(!!retVal) ReturnInst(C, retVal, InsertAtEnd);
  }
  static ReturnInst* Create(LLVMContext &C, BasicBlock *InsertAtEnd) {
    return new(0) ReturnInst(C, InsertAtEnd);
  }
  virtual ~ReturnInst();


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  Value *getReturnValue(unsigned n = 0) const {
    return n < getNumOperands()
      ? getOperand(n)
      : 0;
  }

  unsigned getNumSuccessors() const { return 0; }


  static inline bool classof(const ReturnInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return (I->getOpcode() == Instruction::Ret);
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
 private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);
};

template <>
struct OperandTraits<ReturnInst> : public OptionalOperandTraits<> {
};

ReturnInst::op_iterator ReturnInst::op_begin() { return OperandTraits<ReturnInst>::op_begin(this); } ReturnInst::const_op_iterator ReturnInst::op_begin() const { return OperandTraits<ReturnInst>::op_begin(const_cast<ReturnInst*>(this)); } ReturnInst::op_iterator ReturnInst::op_end() { return OperandTraits<ReturnInst>::op_end(this); } ReturnInst::const_op_iterator ReturnInst::op_end() const { return OperandTraits<ReturnInst>::op_end(const_cast<ReturnInst*>(this)); } Value *ReturnInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<ReturnInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ReturnInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1990, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<ReturnInst>::op_begin(const_cast<ReturnInst*>(this))[i_nocapture]); } void ReturnInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<ReturnInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<ReturnInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 1990, __PRETTY_FUNCTION__)); OperandTraits<ReturnInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned ReturnInst::getNumOperands() const { return OperandTraits<ReturnInst>::operands(this); } template <int Idx_nocapture> Use &ReturnInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &ReturnInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 1999 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class BranchInst : public TerminatorInst {




  BranchInst(const BranchInst &BI);
  void AssertOK();







  explicit BranchInst(BasicBlock *IfTrue, Instruction *InsertBefore = 0);
  BranchInst(BasicBlock *IfTrue, BasicBlock *IfFalse, Value *Cond,
             Instruction *InsertBefore = 0);
  BranchInst(BasicBlock *IfTrue, BasicBlock *InsertAtEnd);
  BranchInst(BasicBlock *IfTrue, BasicBlock *IfFalse, Value *Cond,
             BasicBlock *InsertAtEnd);
protected:
  virtual BranchInst *clone_impl() const;
public:
  static BranchInst *Create(BasicBlock *IfTrue, Instruction *InsertBefore = 0) {
    return new(1, true) BranchInst(IfTrue, InsertBefore);
  }
  static BranchInst *Create(BasicBlock *IfTrue, BasicBlock *IfFalse,
                            Value *Cond, Instruction *InsertBefore = 0) {
    return new(3) BranchInst(IfTrue, IfFalse, Cond, InsertBefore);
  }
  static BranchInst *Create(BasicBlock *IfTrue, BasicBlock *InsertAtEnd) {
    return new(1, true) BranchInst(IfTrue, InsertAtEnd);
  }
  static BranchInst *Create(BasicBlock *IfTrue, BasicBlock *IfFalse,
                            Value *Cond, BasicBlock *InsertAtEnd) {
    return new(3) BranchInst(IfTrue, IfFalse, Cond, InsertAtEnd);
  }

  ~BranchInst();


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;

  bool isUnconditional() const { return getNumOperands() == 1; }
  bool isConditional() const { return getNumOperands() == 3; }

  Value *getCondition() const {
    ((isConditional() && "Cannot get condition of an uncond branch!") ? static_cast<void> (0) : __assert_fail ("isConditional() && \"Cannot get condition of an uncond branch!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2046, __PRETTY_FUNCTION__));
    return Op<-3>();
  }

  void setCondition(Value *V) {
    ((isConditional() && "Cannot set condition of unconditional branch!") ? static_cast<void> (0) : __assert_fail ("isConditional() && \"Cannot set condition of unconditional branch!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2051, __PRETTY_FUNCTION__));
    Op<-3>() = V;
  }




  void setUnconditionalDest(BasicBlock *Dest) {
    Op<-1>() = (Value*)Dest;
    if (isConditional()) {
      Op<-2>() = 0;
      Op<-3>() = 0;
      NumOperands = 1;
      OperandList = op_begin();
    }
  }

  unsigned getNumSuccessors() const { return 1+isConditional(); }

  BasicBlock *getSuccessor(unsigned i) const {
    ((i < getNumSuccessors() && "Successor # out of range for Branch!") ? static_cast<void> (0) : __assert_fail ("i < getNumSuccessors() && \"Successor # out of range for Branch!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2071, __PRETTY_FUNCTION__));
    return cast_or_null<BasicBlock>((&Op<-1>() - i)->get());
  }

  void setSuccessor(unsigned idx, BasicBlock *NewSucc) {
    ((idx < getNumSuccessors() && "Successor # out of range for Branch!") ? static_cast<void> (0) : __assert_fail ("idx < getNumSuccessors() && \"Successor # out of range for Branch!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2076, __PRETTY_FUNCTION__));
    *(&Op<-1>() - idx) = (Value*)NewSucc;
  }


  static inline bool classof(const BranchInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return (I->getOpcode() == Instruction::Br);
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);
};

template <>
struct OperandTraits<BranchInst> : public VariadicOperandTraits<1> {};

BranchInst::op_iterator BranchInst::op_begin() { return OperandTraits<BranchInst>::op_begin(this); } BranchInst::const_op_iterator BranchInst::op_begin() const { return OperandTraits<BranchInst>::op_begin(const_cast<BranchInst*>(this)); } BranchInst::op_iterator BranchInst::op_end() { return OperandTraits<BranchInst>::op_end(this); } BranchInst::const_op_iterator BranchInst::op_end() const { return OperandTraits<BranchInst>::op_end(const_cast<BranchInst*>(this)); } Value *BranchInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<BranchInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<BranchInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2097, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<BranchInst>::op_begin(const_cast<BranchInst*>(this))[i_nocapture]); } void BranchInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<BranchInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<BranchInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2097, __PRETTY_FUNCTION__)); OperandTraits<BranchInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned BranchInst::getNumOperands() const { return OperandTraits<BranchInst>::operands(this); } template <int Idx_nocapture> Use &BranchInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &BranchInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 2106 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class SwitchInst : public TerminatorInst {
  void *operator new(size_t, unsigned);
  unsigned ReservedSpace;




  SwitchInst(const SwitchInst &SI);
  void init(Value *Value, BasicBlock *Default, unsigned NumCases);
  void resizeOperands(unsigned No);

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }




  SwitchInst(Value *Value, BasicBlock *Default, unsigned NumCases,
             Instruction *InsertBefore);





  SwitchInst(Value *Value, BasicBlock *Default, unsigned NumCases,
             BasicBlock *InsertAtEnd);
protected:
  virtual SwitchInst *clone_impl() const;
public:
  static SwitchInst *Create(Value *Value, BasicBlock *Default,
                            unsigned NumCases, Instruction *InsertBefore = 0) {
    return new SwitchInst(Value, Default, NumCases, InsertBefore);
  }
  static SwitchInst *Create(Value *Value, BasicBlock *Default,
                            unsigned NumCases, BasicBlock *InsertAtEnd) {
    return new SwitchInst(Value, Default, NumCases, InsertAtEnd);
  }
  ~SwitchInst();


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  Value *getCondition() const { return getOperand(0); }
  void setCondition(Value *V) { setOperand(0, V); }

  BasicBlock *getDefaultDest() const {
    return cast<BasicBlock>(getOperand(1));
  }



  unsigned getNumCases() const {
    return getNumOperands()/2;
  }



  ConstantInt *getCaseValue(unsigned i) {
    ((i && i < getNumCases() && "Illegal case value to get!") ? static_cast<void> (0) : __assert_fail ("i && i < getNumCases() && \"Illegal case value to get!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2166, __PRETTY_FUNCTION__));
    return getSuccessorValue(i);
  }



  const ConstantInt *getCaseValue(unsigned i) const {
    ((i && i < getNumCases() && "Illegal case value to get!") ? static_cast<void> (0) : __assert_fail ("i && i < getNumCases() && \"Illegal case value to get!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2173, __PRETTY_FUNCTION__));
    return getSuccessorValue(i);
  }




  unsigned findCaseValue(const ConstantInt *C) const {
    for (unsigned i = 1, e = getNumCases(); i != e; ++i)
      if (getCaseValue(i) == C)
        return i;
    return 0;
  }



  ConstantInt *findCaseDest(BasicBlock *BB) {
    if (BB == getDefaultDest()) return __null;

    ConstantInt *CI = __null;
    for (unsigned i = 1, e = getNumCases(); i != e; ++i) {
      if (getSuccessor(i) == BB) {
        if (CI) return __null;
        else CI = getCaseValue(i);
      }
    }
    return CI;
  }



  void addCase(ConstantInt *OnVal, BasicBlock *Dest);





  void removeCase(unsigned idx);

  unsigned getNumSuccessors() const { return getNumOperands()/2; }
  BasicBlock *getSuccessor(unsigned idx) const {
    ((idx < getNumSuccessors() &&"Successor idx out of range for switch!") ? static_cast<void> (0) : __assert_fail ("idx < getNumSuccessors() &&\"Successor idx out of range for switch!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2214, __PRETTY_FUNCTION__));
    return cast<BasicBlock>(getOperand(idx*2+1));
  }
  void setSuccessor(unsigned idx, BasicBlock *NewSucc) {
    ((idx < getNumSuccessors() && "Successor # out of range for switch!") ? static_cast<void> (0) : __assert_fail ("idx < getNumSuccessors() && \"Successor # out of range for switch!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2218, __PRETTY_FUNCTION__));
    setOperand(idx*2+1, (Value*)NewSucc);
  }



  ConstantInt *getSuccessorValue(unsigned idx) const {
    ((idx < getNumSuccessors() && "Successor # out of range!") ? static_cast<void> (0) : __assert_fail ("idx < getNumSuccessors() && \"Successor # out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2225, __PRETTY_FUNCTION__));
    return reinterpret_cast<ConstantInt*>(getOperand(idx*2));
  }


  static inline bool classof(const SwitchInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Switch;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);
};

template <>
struct OperandTraits<SwitchInst> : public HungoffOperandTraits<2> {
};

SwitchInst::op_iterator SwitchInst::op_begin() { return OperandTraits<SwitchInst>::op_begin(this); } SwitchInst::const_op_iterator SwitchInst::op_begin() const { return OperandTraits<SwitchInst>::op_begin(const_cast<SwitchInst*>(this)); } SwitchInst::op_iterator SwitchInst::op_end() { return OperandTraits<SwitchInst>::op_end(this); } SwitchInst::const_op_iterator SwitchInst::op_end() const { return OperandTraits<SwitchInst>::op_end(const_cast<SwitchInst*>(this)); } Value *SwitchInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<SwitchInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<SwitchInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2247, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<SwitchInst>::op_begin(const_cast<SwitchInst*>(this))[i_nocapture]); } void SwitchInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<SwitchInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<SwitchInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2247, __PRETTY_FUNCTION__)); OperandTraits<SwitchInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned SwitchInst::getNumOperands() const { return OperandTraits<SwitchInst>::operands(this); } template <int Idx_nocapture> Use &SwitchInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &SwitchInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 2257 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class IndirectBrInst : public TerminatorInst {
  void *operator new(size_t, unsigned);
  unsigned ReservedSpace;




  IndirectBrInst(const IndirectBrInst &IBI);
  void init(Value *Address, unsigned NumDests);
  void resizeOperands(unsigned No);

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }




  IndirectBrInst(Value *Address, unsigned NumDests, Instruction *InsertBefore);





  IndirectBrInst(Value *Address, unsigned NumDests, BasicBlock *InsertAtEnd);
protected:
  virtual IndirectBrInst *clone_impl() const;
public:
  static IndirectBrInst *Create(Value *Address, unsigned NumDests,
                                Instruction *InsertBefore = 0) {
    return new IndirectBrInst(Address, NumDests, InsertBefore);
  }
  static IndirectBrInst *Create(Value *Address, unsigned NumDests,
                                BasicBlock *InsertAtEnd) {
    return new IndirectBrInst(Address, NumDests, InsertAtEnd);
  }
  ~IndirectBrInst();


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;


  Value *getAddress() { return getOperand(0); }
  const Value *getAddress() const { return getOperand(0); }
  void setAddress(Value *V) { setOperand(0, V); }




  unsigned getNumDestinations() const { return getNumOperands()-1; }


  BasicBlock *getDestination(unsigned i) { return getSuccessor(i); }
  const BasicBlock *getDestination(unsigned i) const { return getSuccessor(i); }



  void addDestination(BasicBlock *Dest);



  void removeDestination(unsigned i);

  unsigned getNumSuccessors() const { return getNumOperands()-1; }
  BasicBlock *getSuccessor(unsigned i) const {
    return cast<BasicBlock>(getOperand(i+1));
  }
  void setSuccessor(unsigned i, BasicBlock *NewSucc) {
    setOperand(i+1, (Value*)NewSucc);
  }


  static inline bool classof(const IndirectBrInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::IndirectBr;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);
};

template <>
struct OperandTraits<IndirectBrInst> : public HungoffOperandTraits<1> {
};

IndirectBrInst::op_iterator IndirectBrInst::op_begin() { return OperandTraits<IndirectBrInst>::op_begin(this); } IndirectBrInst::const_op_iterator IndirectBrInst::op_begin() const { return OperandTraits<IndirectBrInst>::op_begin(const_cast<IndirectBrInst*>(this)); } IndirectBrInst::op_iterator IndirectBrInst::op_end() { return OperandTraits<IndirectBrInst>::op_end(this); } IndirectBrInst::const_op_iterator IndirectBrInst::op_end() const { return OperandTraits<IndirectBrInst>::op_end(const_cast<IndirectBrInst*>(this)); } Value *IndirectBrInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<IndirectBrInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<IndirectBrInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2346, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<IndirectBrInst>::op_begin(const_cast<IndirectBrInst*>(this))[i_nocapture]); } void IndirectBrInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<IndirectBrInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<IndirectBrInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2346, __PRETTY_FUNCTION__)); OperandTraits<IndirectBrInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned IndirectBrInst::getNumOperands() const { return OperandTraits<IndirectBrInst>::operands(this); } template <int Idx_nocapture> Use &IndirectBrInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &IndirectBrInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 2356 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class InvokeInst : public TerminatorInst {
  AttrListPtr AttributeList;
  InvokeInst(const InvokeInst &BI);
  void init(Value *Fn, BasicBlock *IfNormal, BasicBlock *IfException,
            Value* const *Args, unsigned NumArgs);

  template<typename InputIterator>
  void init(Value *Func, BasicBlock *IfNormal, BasicBlock *IfException,
            InputIterator ArgBegin, InputIterator ArgEnd,
            const Twine &NameStr,


            std::random_access_iterator_tag) {
    unsigned NumArgs = (unsigned)std::distance(ArgBegin, ArgEnd);


    init(Func, IfNormal, IfException, NumArgs ? &*ArgBegin : 0, NumArgs);
    setName(NameStr);
  }
# 2383 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
  template<typename InputIterator>
  inline InvokeInst(Value *Func, BasicBlock *IfNormal, BasicBlock *IfException,
                    InputIterator ArgBegin, InputIterator ArgEnd,
                    unsigned Values,
                    const Twine &NameStr, Instruction *InsertBefore);
# 2396 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
  template<typename InputIterator>
  inline InvokeInst(Value *Func, BasicBlock *IfNormal, BasicBlock *IfException,
                    InputIterator ArgBegin, InputIterator ArgEnd,
                    unsigned Values,
                    const Twine &NameStr, BasicBlock *InsertAtEnd);
protected:
  virtual InvokeInst *clone_impl() const;
public:
  template<typename InputIterator>
  static InvokeInst *Create(Value *Func,
                            BasicBlock *IfNormal, BasicBlock *IfException,
                            InputIterator ArgBegin, InputIterator ArgEnd,
                            const Twine &NameStr = "",
                            Instruction *InsertBefore = 0) {
    unsigned Values(ArgEnd - ArgBegin + 3);
    return new(Values) InvokeInst(Func, IfNormal, IfException, ArgBegin, ArgEnd,
                                  Values, NameStr, InsertBefore);
  }
  template<typename InputIterator>
  static InvokeInst *Create(Value *Func,
                            BasicBlock *IfNormal, BasicBlock *IfException,
                            InputIterator ArgBegin, InputIterator ArgEnd,
                            const Twine &NameStr,
                            BasicBlock *InsertAtEnd) {
    unsigned Values(ArgEnd - ArgBegin + 3);
    return new(Values) InvokeInst(Func, IfNormal, IfException, ArgBegin, ArgEnd,
                                  Values, NameStr, InsertAtEnd);
  }


  public: inline Value *getOperand(unsigned) const; inline void setOperand(unsigned, Value*); inline op_iterator op_begin(); inline const_op_iterator op_begin() const; inline op_iterator op_end(); inline const_op_iterator op_end() const; protected: template <int> inline Use &Op(); template <int> inline const Use &Op() const; public: inline unsigned getNumOperands() const;



  CallingConv::ID getCallingConv() const {
    return static_cast<CallingConv::ID>(getSubclassDataFromInstruction());
  }
  void setCallingConv(CallingConv::ID CC) {
    setInstructionSubclassData(static_cast<unsigned>(CC));
  }



  const AttrListPtr &getAttributes() const { return AttributeList; }



  void setAttributes(const AttrListPtr &Attrs) { AttributeList = Attrs; }


  void addAttribute(unsigned i, Attributes attr);


  void removeAttribute(unsigned i, Attributes attr);


  bool paramHasAttr(unsigned i, Attributes attr) const;


  unsigned getParamAlignment(unsigned i) const {
    return AttributeList.getParamAlignment(i);
  }


  bool doesNotAccessMemory() const {
    return paramHasAttr(~0, Attribute::ReadNone);
  }
  void setDoesNotAccessMemory(bool NotAccessMemory = true) {
    if (NotAccessMemory) addAttribute(~0, Attribute::ReadNone);
    else removeAttribute(~0, Attribute::ReadNone);
  }


  bool onlyReadsMemory() const {
    return doesNotAccessMemory() || paramHasAttr(~0, Attribute::ReadOnly);
  }
  void setOnlyReadsMemory(bool OnlyReadsMemory = true) {
    if (OnlyReadsMemory) addAttribute(~0, Attribute::ReadOnly);
    else removeAttribute(~0, Attribute::ReadOnly | Attribute::ReadNone);
  }


  bool doesNotReturn() const {
    return paramHasAttr(~0, Attribute::NoReturn);
  }
  void setDoesNotReturn(bool DoesNotReturn = true) {
    if (DoesNotReturn) addAttribute(~0, Attribute::NoReturn);
    else removeAttribute(~0, Attribute::NoReturn);
  }


  bool doesNotThrow() const {
    return paramHasAttr(~0, Attribute::NoUnwind);
  }
  void setDoesNotThrow(bool DoesNotThrow = true) {
    if (DoesNotThrow) addAttribute(~0, Attribute::NoUnwind);
    else removeAttribute(~0, Attribute::NoUnwind);
  }



  bool hasStructRetAttr() const {

    return paramHasAttr(1, Attribute::StructRet);
  }


  bool hasByValArgument() const {
    return AttributeList.hasAttrSomewhere(Attribute::ByVal);
  }




  Function *getCalledFunction() const {
    return dyn_cast<Function>(getOperand(0));
  }



  const Value *getCalledValue() const { return getOperand(0); }
        Value *getCalledValue() { return getOperand(0); }


  BasicBlock *getNormalDest() const {
    return cast<BasicBlock>(getOperand(1));
  }
  BasicBlock *getUnwindDest() const {
    return cast<BasicBlock>(getOperand(2));
  }
  void setNormalDest(BasicBlock *B) {
    setOperand(1, (Value*)B);
  }

  void setUnwindDest(BasicBlock *B) {
    setOperand(2, (Value*)B);
  }

  BasicBlock *getSuccessor(unsigned i) const {
    ((i < 2 && "Successor # out of range for invoke!") ? static_cast<void> (0) : __assert_fail ("i < 2 && \"Successor # out of range for invoke!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2535, __PRETTY_FUNCTION__));
    return i == 0 ? getNormalDest() : getUnwindDest();
  }

  void setSuccessor(unsigned idx, BasicBlock *NewSucc) {
    ((idx < 2 && "Successor # out of range for invoke!") ? static_cast<void> (0) : __assert_fail ("idx < 2 && \"Successor # out of range for invoke!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2540, __PRETTY_FUNCTION__));
    setOperand(idx+1, (Value*)NewSucc);
  }

  unsigned getNumSuccessors() const { return 2; }


  static inline bool classof(const InvokeInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return (I->getOpcode() == Instruction::Invoke);
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);



  void setInstructionSubclassData(unsigned short D) {
    Instruction::setInstructionSubclassData(D);
  }
};

template <>
struct OperandTraits<InvokeInst> : public VariadicOperandTraits<3> {
};

template<typename InputIterator>
InvokeInst::InvokeInst(Value *Func,
                       BasicBlock *IfNormal, BasicBlock *IfException,
                       InputIterator ArgBegin, InputIterator ArgEnd,
                       unsigned Values,
                       const Twine &NameStr, Instruction *InsertBefore)
  : TerminatorInst(cast<FunctionType>(cast<PointerType>(Func->getType())
                                      ->getElementType())->getReturnType(),
                   Instruction::Invoke,
                   OperandTraits<InvokeInst>::op_end(this) - Values,
                   Values, InsertBefore) {
  init(Func, IfNormal, IfException, ArgBegin, ArgEnd, NameStr,
       typename std::iterator_traits<InputIterator>::iterator_category());
}
template<typename InputIterator>
InvokeInst::InvokeInst(Value *Func,
                       BasicBlock *IfNormal, BasicBlock *IfException,
                       InputIterator ArgBegin, InputIterator ArgEnd,
                       unsigned Values,
                       const Twine &NameStr, BasicBlock *InsertAtEnd)
  : TerminatorInst(cast<FunctionType>(cast<PointerType>(Func->getType())
                                      ->getElementType())->getReturnType(),
                   Instruction::Invoke,
                   OperandTraits<InvokeInst>::op_end(this) - Values,
                   Values, InsertAtEnd) {
  init(Func, IfNormal, IfException, ArgBegin, ArgEnd, NameStr,
       typename std::iterator_traits<InputIterator>::iterator_category());
}

InvokeInst::op_iterator InvokeInst::op_begin() { return OperandTraits<InvokeInst>::op_begin(this); } InvokeInst::const_op_iterator InvokeInst::op_begin() const { return OperandTraits<InvokeInst>::op_begin(const_cast<InvokeInst*>(this)); } InvokeInst::op_iterator InvokeInst::op_end() { return OperandTraits<InvokeInst>::op_end(this); } InvokeInst::const_op_iterator InvokeInst::op_end() const { return OperandTraits<InvokeInst>::op_end(const_cast<InvokeInst*>(this)); } Value *InvokeInst::getOperand(unsigned i_nocapture) const { ((i_nocapture < OperandTraits<InvokeInst>::operands(this) && "getOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<InvokeInst>::operands(this) && \"getOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2599, __PRETTY_FUNCTION__)); return static_cast<Value*>( OperandTraits<InvokeInst>::op_begin(const_cast<InvokeInst*>(this))[i_nocapture]); } void InvokeInst::setOperand(unsigned i_nocapture, Value *Val_nocapture) { ((i_nocapture < OperandTraits<InvokeInst>::operands(this) && "setOperand() out of range!") ? static_cast<void> (0) : __assert_fail ("i_nocapture < OperandTraits<InvokeInst>::operands(this) && \"setOperand() out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h", 2599, __PRETTY_FUNCTION__)); OperandTraits<InvokeInst>::op_begin(this)[i_nocapture] = Val_nocapture; } unsigned InvokeInst::getNumOperands() const { return OperandTraits<InvokeInst>::operands(this); } template <int Idx_nocapture> Use &InvokeInst::Op() { return this->OpFrom<Idx_nocapture>(this); } template <int Idx_nocapture> const Use &InvokeInst::Op() const { return this->OpFrom<Idx_nocapture>(this); }
# 2609 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class UnwindInst : public TerminatorInst {
  void *operator new(size_t, unsigned);
protected:
  virtual UnwindInst *clone_impl() const;
public:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
  explicit UnwindInst(LLVMContext &C, Instruction *InsertBefore = 0);
  explicit UnwindInst(LLVMContext &C, BasicBlock *InsertAtEnd);

  unsigned getNumSuccessors() const { return 0; }


  static inline bool classof(const UnwindInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Unwind;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);
};
# 2646 "/local/monniaux/packages/llvm-2.7/include/llvm/Instructions.h"
class UnreachableInst : public TerminatorInst {
  void *operator new(size_t, unsigned);
protected:
  virtual UnreachableInst *clone_impl() const;

public:

  void *operator new(size_t s) {
    return User::operator new(s, 0);
  }
  explicit UnreachableInst(LLVMContext &C, Instruction *InsertBefore = 0);
  explicit UnreachableInst(LLVMContext &C, BasicBlock *InsertAtEnd);

  unsigned getNumSuccessors() const { return 0; }


  static inline bool classof(const UnreachableInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Instruction::Unreachable;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
private:
  virtual BasicBlock *getSuccessorV(unsigned idx) const;
  virtual unsigned getNumSuccessorsV() const;
  virtual void setSuccessorV(unsigned idx, BasicBlock *B);
};






class TruncInst : public CastInst {
protected:

  virtual TruncInst *clone_impl() const;

public:

  TruncInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  TruncInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const TruncInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == Trunc;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class ZExtInst : public CastInst {
protected:

  virtual ZExtInst *clone_impl() const;

public:

  ZExtInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  ZExtInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const ZExtInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == ZExt;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class SExtInst : public CastInst {
protected:

  virtual SExtInst *clone_impl() const;

public:

  SExtInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  SExtInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const SExtInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == SExt;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class FPTruncInst : public CastInst {
protected:

  virtual FPTruncInst *clone_impl() const;

public:

  FPTruncInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  FPTruncInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const FPTruncInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == FPTrunc;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class FPExtInst : public CastInst {
protected:

  virtual FPExtInst *clone_impl() const;

public:

  FPExtInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  FPExtInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const FPExtInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == FPExt;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class UIToFPInst : public CastInst {
protected:

  virtual UIToFPInst *clone_impl() const;

public:

  UIToFPInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  UIToFPInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const UIToFPInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == UIToFP;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class SIToFPInst : public CastInst {
protected:

  virtual SIToFPInst *clone_impl() const;

public:

  SIToFPInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  SIToFPInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const SIToFPInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == SIToFP;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class FPToUIInst : public CastInst {
protected:

  virtual FPToUIInst *clone_impl() const;

public:

  FPToUIInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  FPToUIInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const FPToUIInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == FPToUI;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class FPToSIInst : public CastInst {
protected:

  virtual FPToSIInst *clone_impl() const;

public:

  FPToSIInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  FPToSIInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const FPToSIInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == FPToSI;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class IntToPtrInst : public CastInst {
public:

  IntToPtrInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  IntToPtrInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  virtual IntToPtrInst *clone_impl() const;


  static inline bool classof(const IntToPtrInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == IntToPtr;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class PtrToIntInst : public CastInst {
protected:

  virtual PtrToIntInst *clone_impl() const;

public:

  PtrToIntInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  PtrToIntInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const PtrToIntInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == PtrToInt;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};






class BitCastInst : public CastInst {
protected:

  virtual BitCastInst *clone_impl() const;

public:

  BitCastInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr = "",
    Instruction *InsertBefore = 0
  );


  BitCastInst(
    Value *S,
    const Type *Ty,
    const Twine &NameStr,
    BasicBlock *InsertAtEnd
  );


  static inline bool classof(const BitCastInst *) { return true; }
  static inline bool classof(const Instruction *I) {
    return I->getOpcode() == BitCast;
  }
  static inline bool classof(const Value *V) {
    return isa<Instruction>(V) && classof(cast<Instruction>(V));
  }
};

}
# 9 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h" 1
# 33 "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h"
# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 34 "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h" 2



namespace llvm {

class BasicBlock;
class Function;
class Module;
class AnalysisUsage;
class PassInfo;
class ImmutablePass;
class PMStack;
class AnalysisResolver;
class PMDataManager;
class raw_ostream;
class StringRef;


typedef const PassInfo* AnalysisID;




enum PassManagerType {
  PMT_Unknown = 0,
  PMT_ModulePassManager = 1,
  PMT_CallGraphPassManager,
  PMT_FunctionPassManager,
  PMT_LoopPassManager,
  PMT_BasicBlockPassManager,
  PMT_Last
};


enum PassKind {
  PT_BasicBlock,
  PT_Loop,
  PT_Function,
  PT_CallGraphSCC,
  PT_Module,
  PT_PassManager
};






class Pass {
  AnalysisResolver *Resolver;
  intptr_t PassID;
  PassKind Kind;
  void operator=(const Pass&);
  Pass(const Pass &);

public:
  explicit Pass(PassKind K, intptr_t pid) : Resolver(0), PassID(pid), Kind(K) {
    ((pid && "pid cannot be 0") ? static_cast<void> (0) : __assert_fail ("pid && \"pid cannot be 0\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h", 91, __PRETTY_FUNCTION__));
  }
  explicit Pass(PassKind K, const void *pid)
    : Resolver(0), PassID((intptr_t)pid), Kind(K) {
    ((pid && "pid cannot be 0") ? static_cast<void> (0) : __assert_fail ("pid && \"pid cannot be 0\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h", 95, __PRETTY_FUNCTION__));
  }
  virtual ~Pass();


  PassKind getPassKind() const { return Kind; }





  virtual const char *getPassName() const;




  const PassInfo *getPassInfo() const;
# 120 "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h"
  virtual void print(raw_ostream &O, const Module *M) const;
  void dump() const;



  virtual void assignPassManager(PMStack &,
                                 PassManagerType = PMT_Unknown) {}

  virtual void preparePassManager(PMStack &);


  virtual PassManagerType getPotentialPassManagerType() const;


  inline void setResolver(AnalysisResolver *AR) {
    ((!Resolver && "Resolver is already set") ? static_cast<void> (0) : __assert_fail ("!Resolver && \"Resolver is already set\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h", 135, __PRETTY_FUNCTION__));
    Resolver = AR;
  }
  inline AnalysisResolver *getResolver() {
    return Resolver;
  }






  virtual void getAnalysisUsage(AnalysisUsage &) const;
# 160 "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h"
  virtual void releaseMemory();





  virtual void *getAdjustedAnalysisPointer(const PassInfo *) {
    return this;
  }
  virtual ImmutablePass *getAsImmutablePass() { return 0; }
  virtual PMDataManager *getAsPMDataManager() { return 0; }



  virtual void verifyAnalysis() const;


  virtual void dumpPassStructure(unsigned Offset = 0);

  template<typename AnalysisClass>
  static const PassInfo *getClassPassInfo() {
    return lookupPassInfo(intptr_t(&AnalysisClass::ID));
  }



  static const PassInfo *lookupPassInfo(intptr_t TI);



  static const PassInfo *lookupPassInfo(StringRef Arg);
# 200 "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h"
  template<typename AnalysisType> AnalysisType *
    getAnalysisIfAvailable() const;







  bool mustPreserveAnalysisID(const PassInfo *AnalysisID) const;





  template<typename AnalysisType>
  AnalysisType &getAnalysis() const;

  template<typename AnalysisType>
  AnalysisType &getAnalysis(Function &F);

  template<typename AnalysisType>
  AnalysisType &getAnalysisID(const PassInfo *PI) const;

  template<typename AnalysisType>
  AnalysisType &getAnalysisID(const PassInfo *PI, Function &F);
};







class ModulePass : public Pass {
public:


  virtual bool runOnModule(Module &M) = 0;

  virtual void assignPassManager(PMStack &PMS,
                                 PassManagerType T = PMT_ModulePassManager);


  virtual PassManagerType getPotentialPassManagerType() const;

  explicit ModulePass(intptr_t pid) : Pass(PT_Module, pid) {}
  explicit ModulePass(const void *pid) : Pass(PT_Module, pid) {}

  virtual ~ModulePass();
};







class ImmutablePass : public ModulePass {
public:






  virtual void initializePass();

  virtual ImmutablePass *getAsImmutablePass() { return this; }



  bool runOnModule(Module &) { return false; }

  explicit ImmutablePass(intptr_t pid) : ModulePass(pid) {}
  explicit ImmutablePass(const void *pid)
  : ModulePass(pid) {}


  virtual ~ImmutablePass();
};
# 291 "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h"
class FunctionPass : public Pass {
public:
  explicit FunctionPass(intptr_t pid) : Pass(PT_Function, pid) {}
  explicit FunctionPass(const void *pid) : Pass(PT_Function, pid) {}




  virtual bool doInitialization(Module &);




  virtual bool runOnFunction(Function &F) = 0;




  virtual bool doFinalization(Module &);





  virtual bool runOnModule(Module &M);




  bool run(Function &F);

  virtual void assignPassManager(PMStack &PMS,
                                 PassManagerType T = PMT_FunctionPassManager);


  virtual PassManagerType getPotentialPassManagerType() const;
};
# 341 "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h"
class BasicBlockPass : public Pass {
public:
  explicit BasicBlockPass(intptr_t pid) : Pass(PT_BasicBlock, pid) {}
  explicit BasicBlockPass(const void *pid) : Pass(PT_BasicBlock, pid) {}




  virtual bool doInitialization(Module &);




  virtual bool doInitialization(Function &);




  virtual bool runOnBasicBlock(BasicBlock &BB) = 0;




  virtual bool doFinalization(Function &);




  virtual bool doFinalization(Module &);





  bool runOnFunction(Function &F);

  virtual void assignPassManager(PMStack &PMS,
                                 PassManagerType T = PMT_BasicBlockPassManager);


  virtual PassManagerType getPotentialPassManagerType() const;
};




extern bool TimePassesIsEnabled;

}




# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/PassSupport.h" 1
# 24 "/local/monniaux/packages/llvm-2.7/include/llvm/PassSupport.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h" 1
# 25 "/local/monniaux/packages/llvm-2.7/include/llvm/PassSupport.h" 2

namespace llvm {

class TargetMachine;







class PassInfo {
public:
  typedef Pass* (*NormalCtor_t)();

private:
  const char *const PassName;
  const char *const PassArgument;
  const intptr_t PassID;
  const bool IsCFGOnlyPass;
  const bool IsAnalysis;
  const bool IsAnalysisGroup;
  std::vector<const PassInfo*> ItfImpl;

  NormalCtor_t NormalCtor;

public:


  PassInfo(const char *name, const char *arg, intptr_t pi,
           NormalCtor_t normal = 0,
           bool isCFGOnly = false, bool is_analysis = false)
    : PassName(name), PassArgument(arg), PassID(pi),
      IsCFGOnlyPass(isCFGOnly),
      IsAnalysis(is_analysis), IsAnalysisGroup(false), NormalCtor(normal) {
    registerPass();
  }



  PassInfo(const char *name, intptr_t pi)
    : PassName(name), PassArgument(""), PassID(pi),
      IsCFGOnlyPass(false),
      IsAnalysis(false), IsAnalysisGroup(true), NormalCtor(0) {
  }



  const char *getPassName() const { return PassName; }





  const char *getPassArgument() const { return PassArgument; }



  intptr_t getTypeInfo() const { return PassID; }


  bool isPassID(void *IDPtr) const {
    return PassID == (intptr_t)IDPtr;
  }




  bool isAnalysisGroup() const { return IsAnalysisGroup; }
  bool isAnalysis() const { return IsAnalysis; }



  bool isCFGOnlyPass() const { return IsCFGOnlyPass; }





  NormalCtor_t getNormalCtor() const {
    return NormalCtor;
  }
  void setNormalCtor(NormalCtor_t Ctor) {
    NormalCtor = Ctor;
  }


  Pass *createPass() const {
    (((!isAnalysisGroup() || NormalCtor) && "No default implementation found for analysis group!") ? static_cast<void> (0) : __assert_fail ("(!isAnalysisGroup() || NormalCtor) && \"No default implementation found for analysis group!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassSupport.h", 114, __PRETTY_FUNCTION__));

    ((NormalCtor && "Cannot call createPass on PassInfo without default ctor!") ? static_cast<void> (0) : __assert_fail ("NormalCtor && \"Cannot call createPass on PassInfo without default ctor!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassSupport.h", 116, __PRETTY_FUNCTION__));

    return NormalCtor();
  }





  void addInterfaceImplemented(const PassInfo *ItfPI) {
    ItfImpl.push_back(ItfPI);
  }




  const std::vector<const PassInfo*> &getInterfacesImplemented() const {
    return ItfImpl;
  }

protected:
  void registerPass();
  void unregisterPass();

private:
  void operator=(const PassInfo &);
  PassInfo(const PassInfo &);
};


template<typename PassName>
Pass *callDefaultCtor() { return new PassName(); }
# 165 "/local/monniaux/packages/llvm-2.7/include/llvm/PassSupport.h"
template<typename passName>
struct RegisterPass : public PassInfo {


  RegisterPass(const char *PassArg, const char *Name, bool CFGOnly = false,
               bool is_analysis = false)
    : PassInfo(Name, PassArg, intptr_t(&passName::ID),
               PassInfo::NormalCtor_t(callDefaultCtor<passName>),
               CFGOnly, is_analysis) {
  }
};
# 197 "/local/monniaux/packages/llvm-2.7/include/llvm/PassSupport.h"
class RegisterAGBase : public PassInfo {
protected:
  RegisterAGBase(const char *Name,
                 intptr_t InterfaceID,
                 intptr_t PassID = 0,
                 bool isDefault = false);
};

template<typename Interface, bool Default = false>
struct RegisterAnalysisGroup : public RegisterAGBase {
  explicit RegisterAnalysisGroup(PassInfo &RPB)
    : RegisterAGBase(RPB.getPassName(),
                     intptr_t(&Interface::ID), RPB.getTypeInfo(),
                     Default) {
  }

  explicit RegisterAnalysisGroup(const char *Name)
    : RegisterAGBase(Name, intptr_t(&Interface::ID)) {
  }
};
# 229 "/local/monniaux/packages/llvm-2.7/include/llvm/PassSupport.h"
struct PassRegistrationListener {



  PassRegistrationListener();



  virtual ~PassRegistrationListener();




  virtual void passRegistered(const PassInfo *) {}




  void enumeratePasses();




  virtual void passEnumerate(const PassInfo *) {}
};


}
# 395 "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h" 1
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h" 1
# 23 "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h" 2




namespace llvm {
# 37 "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h"
class AnalysisUsage {
public:
  typedef SmallVector<AnalysisID, 32> VectorType;

private:

  VectorType Required, RequiredTransitive, Preserved;
  bool PreservesAll;

public:
  AnalysisUsage() : PreservesAll(false) {}




  AnalysisUsage &addRequiredID(AnalysisID ID) {
    ((ID && "Pass class not registered!") ? static_cast<void> (0) : __assert_fail ("ID && \"Pass class not registered!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h", 53, __PRETTY_FUNCTION__));
    Required.push_back(ID);
    return *this;
  }
  template<class PassClass>
  AnalysisUsage &addRequired() {
    return addRequiredID(Pass::getClassPassInfo<PassClass>());
  }

  AnalysisUsage &addRequiredTransitiveID(AnalysisID ID) {
    ((ID && "Pass class not registered!") ? static_cast<void> (0) : __assert_fail ("ID && \"Pass class not registered!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h", 63, __PRETTY_FUNCTION__));
    Required.push_back(ID);
    RequiredTransitive.push_back(ID);
    return *this;
  }
  template<class PassClass>
  AnalysisUsage &addRequiredTransitive() {
    AnalysisID ID = Pass::getClassPassInfo<PassClass>();
    return addRequiredTransitiveID(ID);
  }




  AnalysisUsage &addPreservedID(AnalysisID ID) {
    Preserved.push_back(ID);
    return *this;
  }




  template<class PassClass>
  AnalysisUsage &addPreserved() {
    ((Pass::getClassPassInfo<PassClass>() && "Pass class not registered!") ? static_cast<void> (0) : __assert_fail ("Pass::getClassPassInfo<PassClass>() && \"Pass class not registered!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h", 87, __PRETTY_FUNCTION__));
    Preserved.push_back(Pass::getClassPassInfo<PassClass>());
    return *this;
  }






  AnalysisUsage &addPreserved(StringRef Arg) {
    const PassInfo *PI = Pass::lookupPassInfo(Arg);

    if (PI) Preserved.push_back(PI);
    return *this;
  }


  void setPreservesAll() { PreservesAll = true; }
  bool getPreservesAll() const { return PreservesAll; }
# 117 "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h"
  void setPreservesCFG();

  const VectorType &getRequiredSet() const { return Required; }
  const VectorType &getRequiredTransitiveSet() const {
    return RequiredTransitive;
  }
  const VectorType &getPreservedSet() const { return Preserved; }
};






class PMDataManager;
class AnalysisResolver {
private:
  AnalysisResolver();

public:
  explicit AnalysisResolver(PMDataManager &P) : PM(P) { }

  inline PMDataManager &getPMDataManager() { return PM; }


  Pass *findImplPass(const PassInfo *PI) {
    Pass *ResultPass = 0;
    for (unsigned i = 0; i < AnalysisImpls.size() ; ++i) {
      if (AnalysisImpls[i].first == PI) {
        ResultPass = AnalysisImpls[i].second;
        break;
      }
    }
    return ResultPass;
  }


  Pass *findImplPass(Pass *P, const PassInfo *PI, Function &F);

  void addAnalysisImplsPair(const PassInfo *PI, Pass *P) {
    std::pair<const PassInfo*, Pass*> pir = std::make_pair(PI,P);
    AnalysisImpls.push_back(pir);
  }



  void clearAnalysisImpls() {
    AnalysisImpls.clear();
  }


  Pass *getAnalysisIfAvailable(AnalysisID ID, bool Direction) const;



  std::vector<std::pair<const PassInfo*, Pass*> > AnalysisImpls;

private:

  PMDataManager &PM;
};
# 187 "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h"
template<typename AnalysisType>
AnalysisType *Pass::getAnalysisIfAvailable() const {
  ((Resolver && "Pass not resident in a PassManager object!") ? static_cast<void> (0) : __assert_fail ("Resolver && \"Pass not resident in a PassManager object!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h", 189, __PRETTY_FUNCTION__));

  const PassInfo *PI = getClassPassInfo<AnalysisType>();
  if (PI == 0) return 0;

  Pass *ResultPass = Resolver->getAnalysisIfAvailable(PI, true);
  if (ResultPass == 0) return 0;





  return (AnalysisType*)ResultPass->getAdjustedAnalysisPointer(PI);
}





template<typename AnalysisType>
AnalysisType &Pass::getAnalysis() const {
  ((Resolver && "Pass has not been inserted into a PassManager object!") ? static_cast<void> (0) : __assert_fail ("Resolver && \"Pass has not been inserted into a PassManager object!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h", 210, __PRETTY_FUNCTION__));
  return getAnalysisID<AnalysisType>(getClassPassInfo<AnalysisType>());
}

template<typename AnalysisType>
AnalysisType &Pass::getAnalysisID(const PassInfo *PI) const {
  ((PI && "getAnalysis for unregistered pass!") ? static_cast<void> (0) : __assert_fail ("PI && \"getAnalysis for unregistered pass!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h", 216, __PRETTY_FUNCTION__));
  ((Resolver&&"Pass has not been inserted into a PassManager object!") ? static_cast<void> (0) : __assert_fail ("Resolver&&\"Pass has not been inserted into a PassManager object!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h", 217, __PRETTY_FUNCTION__));



  Pass *ResultPass = Resolver->findImplPass(PI);
  ((ResultPass && "getAnalysis*() called on an analysis that was not " "'required' by pass!") ? static_cast<void> (0) : __assert_fail ("ResultPass && \"getAnalysis*() called on an analysis that was not \" \"'required' by pass!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h", 224, __PRETTY_FUNCTION__));







  return *(AnalysisType*)ResultPass->getAdjustedAnalysisPointer(PI);
}





template<typename AnalysisType>
AnalysisType &Pass::getAnalysis(Function &F) {
  ((Resolver &&"Pass has not been inserted into a PassManager object!") ? static_cast<void> (0) : __assert_fail ("Resolver &&\"Pass has not been inserted into a PassManager object!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h", 239, __PRETTY_FUNCTION__));

  return getAnalysisID<AnalysisType>(getClassPassInfo<AnalysisType>(), F);
}

template<typename AnalysisType>
AnalysisType &Pass::getAnalysisID(const PassInfo *PI, Function &F) {
  ((PI && "getAnalysis for unregistered pass!") ? static_cast<void> (0) : __assert_fail ("PI && \"getAnalysis for unregistered pass!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h", 246, __PRETTY_FUNCTION__));
  ((Resolver && "Pass has not been inserted into a PassManager object!") ? static_cast<void> (0) : __assert_fail ("Resolver && \"Pass has not been inserted into a PassManager object!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h", 247, __PRETTY_FUNCTION__));



  Pass *ResultPass = Resolver->findImplPass(this, PI, F);
  ((ResultPass && "Unable to find requested analysis info") ? static_cast<void> (0) : __assert_fail ("ResultPass && \"Unable to find requested analysis info\"", "/local/monniaux/packages/llvm-2.7/include/llvm/PassAnalysisSupport.h", 252, __PRETTY_FUNCTION__));





  return *(AnalysisType*)ResultPass->getAdjustedAnalysisPointer(PI);
}

}
# 396 "/local/monniaux/packages/llvm-2.7/include/llvm/Pass.h" 2
# 10 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/PassManager.h" 1
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/PassManager.h"
namespace llvm {

class Pass;
class ModulePass;
class Module;

class PassManagerImpl;
class FunctionPassManagerImpl;




class PassManagerBase {
public:
  virtual ~PassManagerBase();





  virtual void add(Pass *P) = 0;
};


class PassManager : public PassManagerBase {
public:

  PassManager();
  ~PassManager();





  void add(Pass *P);



  bool run(Module &M);

private:



  PassManagerImpl *PM;
};


class FunctionPassManager : public PassManagerBase {
public:


  explicit FunctionPassManager(Module *M);
  ~FunctionPassManager();






  void add(Pass *P);





  bool run(Function &F);



  bool doInitialization();



  bool doFinalization();

private:
  FunctionPassManagerImpl *FPM;
  Module *M;
};

}
# 11 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/TypeSymbolTable.h" 1
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/TypeSymbolTable.h"
# 1 "/usr/include/c++/4.3/map" 1 3
# 63 "/usr/include/c++/4.3/map" 3
       
# 64 "/usr/include/c++/4.3/map" 3

# 1 "/usr/include/c++/4.3/bits/stl_tree.h" 1 3
# 72 "/usr/include/c++/4.3/bits/stl_tree.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 90 "/usr/include/c++/4.3/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;
    };

  _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x);

  _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x);

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header);

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header);


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator()
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Link_type __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }

      _Link_type
      _M_create_node(const value_type& __x)
      {
 _Link_type __tmp = _M_get_node();
 if (true)
   { get_allocator().construct(&__tmp->_M_value_field, __x); }
 if (false)
   {
     _M_put_node(__tmp);
     ;
   }
 return __tmp;
      }

      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

      void
      _M_destroy_node(_Link_type __p)
      {
 get_allocator().destroy(&__p->_M_value_field);
 _M_put_node(__p);
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl()
   : _Node_allocator(), _M_key_compare(), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

 private:
   void
   _M_initialize()
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      iterator
      _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,
   const value_type& __v);



      iterator
      _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);

      iterator
      _M_insert_equal_lower(const value_type& __x);

      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

    public:

      _Rb_tree() { }

      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, __a) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }





      ~_Rb_tree()
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin()
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }

      const_iterator
      begin() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }

      iterator
      end()
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }

      const_iterator
      end() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }

      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }

      bool
      empty() const
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const
      { return _M_impl._M_node_count; }

      size_type
      max_size() const
      { return get_allocator().max_size(); }

      void



      swap(_Rb_tree& __t);



      pair<iterator, bool>
      _M_insert_unique(const value_type& __x);

      iterator
      _M_insert_equal(const value_type& __x);

      iterator
      _M_insert_unique_(const_iterator __position, const value_type& __x);

      iterator
      _M_insert_equal_(const_iterator __position, const value_type& __x);

      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

      void
      erase(iterator __position);

      void
      erase(const_iterator __position);

      size_type
      erase(const key_type& __x);

      void
      erase(iterator __first, iterator __last);

      void
      erase(const_iterator __first, const_iterator __last);

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 820 "/usr/include/c++/4.3/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z,
        const_cast<_Base_ptr>(__p),
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      if (true)
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      if (false)
 {
   _M_erase(__top);
   ;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)

    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();

       __t._M_root() = 0;
       __t._M_leftmost() = __t._M_end();
       __t._M_rightmost() = __t._M_end();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();

   _M_root() = 0;
   _M_leftmost() = _M_end();
   _M_rightmost() = _M_end();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
 }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);



      std::__alloc_swap<_Node_allocator>::
 _S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
 return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
      return pair<iterator, bool>(__j, false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique_(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert_(0, _M_rightmost(), __v);
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node, __v);
       else
  return _M_insert_(__position._M_node,
      __position._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(), __v);
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node, __v);
       else
  return _M_insert_(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else

 return iterator(static_cast<_Link_type>
   (const_cast<_Base_ptr>(__position._M_node)));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert_(0, _M_rightmost(), __v);
   else
     return _M_insert_equal(__v);
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node, __v);
       else
  return _M_insert_(__position._M_node,
      __position._M_node, __v);
     }
   else
     return _M_insert_equal(__v);
 }
      else
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(), __v);
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node, __v);
       else
  return _M_insert_(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_equal_lower(__v);
 }
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (__position._M_node,
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root);

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }

}
# 66 "/usr/include/c++/4.3/map" 2 3
# 1 "/usr/include/c++/4.3/bits/stl_map.h" 1 3
# 68 "/usr/include/c++/4.3/bits/stl_map.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 89 "/usr/include/c++/4.3/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()
      : _M_t() { }






      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 175 "/usr/include/c++/4.3/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
# 199 "/usr/include/c++/4.3/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 215 "/usr/include/c++/4.3/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 238 "/usr/include/c++/4.3/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 264 "/usr/include/c++/4.3/bits/stl_map.h" 3
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 383 "/usr/include/c++/4.3/bits/stl_map.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 410 "/usr/include/c++/4.3/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
          __i = insert(__i, value_type(__k, mapped_type()));
 return (*__i).second;
      }
# 432 "/usr/include/c++/4.3/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 467 "/usr/include/c++/4.3/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }
# 494 "/usr/include/c++/4.3/bits/stl_map.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
# 506 "/usr/include/c++/4.3/bits/stl_map.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 521 "/usr/include/c++/4.3/bits/stl_map.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 536 "/usr/include/c++/4.3/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 551 "/usr/include/c++/4.3/bits/stl_map.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 566 "/usr/include/c++/4.3/bits/stl_map.h" 3
      void



      swap(map& __x)

      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 613 "/usr/include/c++/4.3/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 628 "/usr/include/c++/4.3/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 640 "/usr/include/c++/4.3/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 655 "/usr/include/c++/4.3/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 670 "/usr/include/c++/4.3/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 709 "/usr/include/c++/4.3/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 728 "/usr/include/c++/4.3/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
# 753 "/usr/include/c++/4.3/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 770 "/usr/include/c++/4.3/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 825 "/usr/include/c++/4.3/bits/stl_map.h" 3
}
# 67 "/usr/include/c++/4.3/map" 2 3
# 1 "/usr/include/c++/4.3/bits/stl_multimap.h" 1 3
# 67 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 88 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;






      multimap()
      : _M_t() { }






      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 173 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 197 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 213 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
        : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 236 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 262 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 379 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 406 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 430 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
# 442 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 457 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 472 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 487 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 502 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      void



      swap(multimap& __x)

      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 549 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 564 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }






      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 588 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 603 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 640 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 657 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
# 682 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 699 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 754 "/usr/include/c++/4.3/bits/stl_multimap.h" 3
}
# 68 "/usr/include/c++/4.3/map" 2 3
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/TypeSymbolTable.h" 2

namespace llvm {

class StringRef;





class TypeSymbolTable : public AbstractTypeUser {



public:


  typedef std::map<const std::string, const Type*> TypeMap;


  typedef TypeMap::iterator iterator;


  typedef TypeMap::const_iterator const_iterator;




public:

  TypeSymbolTable():LastUnique(0) {}
  ~TypeSymbolTable();




public:





  std::string getUniqueName(StringRef BaseName) const;






  Type *lookup(StringRef name) const;




  iterator find(StringRef Name) {
    return tmap.find(Name);
  }




  const_iterator find(StringRef Name) const {
    return tmap.find(Name);
  }



  inline bool empty() const { return tmap.empty(); }



  inline unsigned size() const { return unsigned(tmap.size()); }




  void dump() const;




public:

  inline iterator begin() { return tmap.begin(); }


  inline const_iterator begin() const { return tmap.begin(); }


  inline iterator end() { return tmap.end(); }


  inline const_iterator end() const { return tmap.end(); }




public:





  void insert(StringRef Name, const Type *Typ);




  Type* remove(iterator TI);




private:


  virtual void refineAbstractType(const DerivedType *OldTy, const Type *NewTy);


  virtual void typeBecameConcrete(const DerivedType *AbsTy);




private:
  TypeMap tmap;
  mutable uint32_t LastUnique;



};

}
# 12 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Intrinsics.h" 1
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/Intrinsics.h"
namespace llvm {

class Type;
class FunctionType;
class Function;
class LLVMContext;
class Module;
class AttrListPtr;





namespace Intrinsic {
  enum ID {
    not_intrinsic = 0,



# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Intrinsics.gen" 1
# 11 "/local/monniaux/packages/llvm-2.7/include/llvm/Intrinsics.gen"
    alpha_umulh,
    annotation,
    arm_neon_vabals,
    arm_neon_vabalu,
    arm_neon_vabas,
    arm_neon_vabau,
    arm_neon_vabdls,
    arm_neon_vabdlu,
    arm_neon_vabds,
    arm_neon_vabdu,
    arm_neon_vabs,
    arm_neon_vacged,
    arm_neon_vacgeq,
    arm_neon_vacgtd,
    arm_neon_vacgtq,
    arm_neon_vaddhn,
    arm_neon_vaddls,
    arm_neon_vaddlu,
    arm_neon_vaddws,
    arm_neon_vaddwu,
    arm_neon_vcls,
    arm_neon_vclz,
    arm_neon_vcnt,
    arm_neon_vcvtfp2fxs,
    arm_neon_vcvtfp2fxu,
    arm_neon_vcvtfxs2fp,
    arm_neon_vcvtfxu2fp,
    arm_neon_vhadds,
    arm_neon_vhaddu,
    arm_neon_vhsubs,
    arm_neon_vhsubu,
    arm_neon_vld1,
    arm_neon_vld2,
    arm_neon_vld2lane,
    arm_neon_vld3,
    arm_neon_vld3lane,
    arm_neon_vld4,
    arm_neon_vld4lane,
    arm_neon_vmaxs,
    arm_neon_vmaxu,
    arm_neon_vmins,
    arm_neon_vminu,
    arm_neon_vmlals,
    arm_neon_vmlalu,
    arm_neon_vmlsls,
    arm_neon_vmlslu,
    arm_neon_vmovls,
    arm_neon_vmovlu,
    arm_neon_vmovn,
    arm_neon_vmullp,
    arm_neon_vmulls,
    arm_neon_vmullu,
    arm_neon_vmulp,
    arm_neon_vpadals,
    arm_neon_vpadalu,
    arm_neon_vpadd,
    arm_neon_vpaddls,
    arm_neon_vpaddlu,
    arm_neon_vpmaxs,
    arm_neon_vpmaxu,
    arm_neon_vpmins,
    arm_neon_vpminu,
    arm_neon_vqabs,
    arm_neon_vqadds,
    arm_neon_vqaddu,
    arm_neon_vqdmlal,
    arm_neon_vqdmlsl,
    arm_neon_vqdmulh,
    arm_neon_vqdmull,
    arm_neon_vqmovns,
    arm_neon_vqmovnsu,
    arm_neon_vqmovnu,
    arm_neon_vqneg,
    arm_neon_vqrdmulh,
    arm_neon_vqrshiftns,
    arm_neon_vqrshiftnsu,
    arm_neon_vqrshiftnu,
    arm_neon_vqrshifts,
    arm_neon_vqrshiftu,
    arm_neon_vqshiftns,
    arm_neon_vqshiftnsu,
    arm_neon_vqshiftnu,
    arm_neon_vqshifts,
    arm_neon_vqshiftsu,
    arm_neon_vqshiftu,
    arm_neon_vqsubs,
    arm_neon_vqsubu,
    arm_neon_vraddhn,
    arm_neon_vrecpe,
    arm_neon_vrecps,
    arm_neon_vrhadds,
    arm_neon_vrhaddu,
    arm_neon_vrshiftn,
    arm_neon_vrshifts,
    arm_neon_vrshiftu,
    arm_neon_vrsqrte,
    arm_neon_vrsqrts,
    arm_neon_vrsubhn,
    arm_neon_vshiftins,
    arm_neon_vshiftls,
    arm_neon_vshiftlu,
    arm_neon_vshiftn,
    arm_neon_vshifts,
    arm_neon_vshiftu,
    arm_neon_vst1,
    arm_neon_vst2,
    arm_neon_vst2lane,
    arm_neon_vst3,
    arm_neon_vst3lane,
    arm_neon_vst4,
    arm_neon_vst4lane,
    arm_neon_vsubhn,
    arm_neon_vsubls,
    arm_neon_vsublu,
    arm_neon_vsubws,
    arm_neon_vsubwu,
    arm_neon_vtbl1,
    arm_neon_vtbl2,
    arm_neon_vtbl3,
    arm_neon_vtbl4,
    arm_neon_vtbx1,
    arm_neon_vtbx2,
    arm_neon_vtbx3,
    arm_neon_vtbx4,
    arm_thread_pointer,
    atomic_cmp_swap,
    atomic_load_add,
    atomic_load_and,
    atomic_load_max,
    atomic_load_min,
    atomic_load_nand,
    atomic_load_or,
    atomic_load_sub,
    atomic_load_umax,
    atomic_load_umin,
    atomic_load_xor,
    atomic_swap,
    bswap,
    convertff,
    convertfsi,
    convertfui,
    convertsif,
    convertss,
    convertsu,
    convertuif,
    convertus,
    convertuu,
    cos,
    ctlz,
    ctpop,
    cttz,
    dbg_declare,
    dbg_value,
    eh_dwarf_cfa,
    eh_exception,
    eh_return_i32,
    eh_return_i64,
    eh_selector,
    eh_sjlj_callsite,
    eh_sjlj_longjmp,
    eh_sjlj_lsda,
    eh_sjlj_setjmp,
    eh_typeid_for,
    eh_unwind_init,
    exp,
    exp2,
    flt_rounds,
    frameaddress,
    gcread,
    gcroot,
    gcwrite,
    init_trampoline,
    invariant_end,
    invariant_start,
    lifetime_end,
    lifetime_start,
    log,
    log10,
    log2,
    longjmp,
    memcpy,
    memmove,
    memory_barrier,
    memset,
    objectsize,
    pcmarker,
    pow,
    powi,
    ppc_altivec_dss,
    ppc_altivec_dssall,
    ppc_altivec_dst,
    ppc_altivec_dstst,
    ppc_altivec_dststt,
    ppc_altivec_dstt,
    ppc_altivec_lvebx,
    ppc_altivec_lvehx,
    ppc_altivec_lvewx,
    ppc_altivec_lvsl,
    ppc_altivec_lvsr,
    ppc_altivec_lvx,
    ppc_altivec_lvxl,
    ppc_altivec_mfvscr,
    ppc_altivec_mtvscr,
    ppc_altivec_stvebx,
    ppc_altivec_stvehx,
    ppc_altivec_stvewx,
    ppc_altivec_stvx,
    ppc_altivec_stvxl,
    ppc_altivec_vaddcuw,
    ppc_altivec_vaddsbs,
    ppc_altivec_vaddshs,
    ppc_altivec_vaddsws,
    ppc_altivec_vaddubs,
    ppc_altivec_vadduhs,
    ppc_altivec_vadduws,
    ppc_altivec_vavgsb,
    ppc_altivec_vavgsh,
    ppc_altivec_vavgsw,
    ppc_altivec_vavgub,
    ppc_altivec_vavguh,
    ppc_altivec_vavguw,
    ppc_altivec_vcfsx,
    ppc_altivec_vcfux,
    ppc_altivec_vcmpbfp,
    ppc_altivec_vcmpbfp_p,
    ppc_altivec_vcmpeqfp,
    ppc_altivec_vcmpeqfp_p,
    ppc_altivec_vcmpequb,
    ppc_altivec_vcmpequb_p,
    ppc_altivec_vcmpequh,
    ppc_altivec_vcmpequh_p,
    ppc_altivec_vcmpequw,
    ppc_altivec_vcmpequw_p,
    ppc_altivec_vcmpgefp,
    ppc_altivec_vcmpgefp_p,
    ppc_altivec_vcmpgtfp,
    ppc_altivec_vcmpgtfp_p,
    ppc_altivec_vcmpgtsb,
    ppc_altivec_vcmpgtsb_p,
    ppc_altivec_vcmpgtsh,
    ppc_altivec_vcmpgtsh_p,
    ppc_altivec_vcmpgtsw,
    ppc_altivec_vcmpgtsw_p,
    ppc_altivec_vcmpgtub,
    ppc_altivec_vcmpgtub_p,
    ppc_altivec_vcmpgtuh,
    ppc_altivec_vcmpgtuh_p,
    ppc_altivec_vcmpgtuw,
    ppc_altivec_vcmpgtuw_p,
    ppc_altivec_vctsxs,
    ppc_altivec_vctuxs,
    ppc_altivec_vexptefp,
    ppc_altivec_vlogefp,
    ppc_altivec_vmaddfp,
    ppc_altivec_vmaxfp,
    ppc_altivec_vmaxsb,
    ppc_altivec_vmaxsh,
    ppc_altivec_vmaxsw,
    ppc_altivec_vmaxub,
    ppc_altivec_vmaxuh,
    ppc_altivec_vmaxuw,
    ppc_altivec_vmhaddshs,
    ppc_altivec_vmhraddshs,
    ppc_altivec_vminfp,
    ppc_altivec_vminsb,
    ppc_altivec_vminsh,
    ppc_altivec_vminsw,
    ppc_altivec_vminub,
    ppc_altivec_vminuh,
    ppc_altivec_vminuw,
    ppc_altivec_vmladduhm,
    ppc_altivec_vmsummbm,
    ppc_altivec_vmsumshm,
    ppc_altivec_vmsumshs,
    ppc_altivec_vmsumubm,
    ppc_altivec_vmsumuhm,
    ppc_altivec_vmsumuhs,
    ppc_altivec_vmulesb,
    ppc_altivec_vmulesh,
    ppc_altivec_vmuleub,
    ppc_altivec_vmuleuh,
    ppc_altivec_vmulosb,
    ppc_altivec_vmulosh,
    ppc_altivec_vmuloub,
    ppc_altivec_vmulouh,
    ppc_altivec_vnmsubfp,
    ppc_altivec_vperm,
    ppc_altivec_vpkpx,
    ppc_altivec_vpkshss,
    ppc_altivec_vpkshus,
    ppc_altivec_vpkswss,
    ppc_altivec_vpkswus,
    ppc_altivec_vpkuhus,
    ppc_altivec_vpkuwus,
    ppc_altivec_vrefp,
    ppc_altivec_vrfim,
    ppc_altivec_vrfin,
    ppc_altivec_vrfip,
    ppc_altivec_vrfiz,
    ppc_altivec_vrlb,
    ppc_altivec_vrlh,
    ppc_altivec_vrlw,
    ppc_altivec_vrsqrtefp,
    ppc_altivec_vsel,
    ppc_altivec_vsl,
    ppc_altivec_vslb,
    ppc_altivec_vslh,
    ppc_altivec_vslo,
    ppc_altivec_vslw,
    ppc_altivec_vsr,
    ppc_altivec_vsrab,
    ppc_altivec_vsrah,
    ppc_altivec_vsraw,
    ppc_altivec_vsrb,
    ppc_altivec_vsrh,
    ppc_altivec_vsro,
    ppc_altivec_vsrw,
    ppc_altivec_vsubcuw,
    ppc_altivec_vsubsbs,
    ppc_altivec_vsubshs,
    ppc_altivec_vsubsws,
    ppc_altivec_vsububs,
    ppc_altivec_vsubuhs,
    ppc_altivec_vsubuws,
    ppc_altivec_vsum2sws,
    ppc_altivec_vsum4sbs,
    ppc_altivec_vsum4shs,
    ppc_altivec_vsum4ubs,
    ppc_altivec_vsumsws,
    ppc_altivec_vupkhpx,
    ppc_altivec_vupkhsb,
    ppc_altivec_vupkhsh,
    ppc_altivec_vupklpx,
    ppc_altivec_vupklsb,
    ppc_altivec_vupklsh,
    ppc_dcba,
    ppc_dcbf,
    ppc_dcbi,
    ppc_dcbst,
    ppc_dcbt,
    ppc_dcbtst,
    ppc_dcbz,
    ppc_dcbzl,
    ppc_sync,
    prefetch,
    ptr_annotation,
    readcyclecounter,
    returnaddress,
    sadd_with_overflow,
    setjmp,
    siglongjmp,
    sigsetjmp,
    sin,
    smul_with_overflow,
    spu_si_a,
    spu_si_addx,
    spu_si_ah,
    spu_si_ahi,
    spu_si_ai,
    spu_si_and,
    spu_si_andbi,
    spu_si_andc,
    spu_si_andhi,
    spu_si_andi,
    spu_si_bg,
    spu_si_bgx,
    spu_si_ceq,
    spu_si_ceqb,
    spu_si_ceqbi,
    spu_si_ceqh,
    spu_si_ceqhi,
    spu_si_ceqi,
    spu_si_cg,
    spu_si_cgt,
    spu_si_cgtb,
    spu_si_cgtbi,
    spu_si_cgth,
    spu_si_cgthi,
    spu_si_cgti,
    spu_si_cgx,
    spu_si_clgt,
    spu_si_clgtb,
    spu_si_clgtbi,
    spu_si_clgth,
    spu_si_clgthi,
    spu_si_clgti,
    spu_si_dfa,
    spu_si_dfm,
    spu_si_dfma,
    spu_si_dfms,
    spu_si_dfnma,
    spu_si_dfnms,
    spu_si_dfs,
    spu_si_fa,
    spu_si_fceq,
    spu_si_fcgt,
    spu_si_fcmeq,
    spu_si_fcmgt,
    spu_si_fm,
    spu_si_fma,
    spu_si_fms,
    spu_si_fnms,
    spu_si_fs,
    spu_si_fsmbi,
    spu_si_mpy,
    spu_si_mpya,
    spu_si_mpyh,
    spu_si_mpyhh,
    spu_si_mpyhha,
    spu_si_mpyhhau,
    spu_si_mpyhhu,
    spu_si_mpyi,
    spu_si_mpys,
    spu_si_mpyu,
    spu_si_mpyui,
    spu_si_nand,
    spu_si_nor,
    spu_si_or,
    spu_si_orbi,
    spu_si_orc,
    spu_si_orhi,
    spu_si_ori,
    spu_si_sf,
    spu_si_sfh,
    spu_si_sfhi,
    spu_si_sfi,
    spu_si_sfx,
    spu_si_shli,
    spu_si_shlqbi,
    spu_si_shlqbii,
    spu_si_shlqby,
    spu_si_shlqbyi,
    spu_si_xor,
    spu_si_xorbi,
    spu_si_xorhi,
    spu_si_xori,
    sqrt,
    ssub_with_overflow,
    stackprotector,
    stackrestore,
    stacksave,
    trap,
    uadd_with_overflow,
    umul_with_overflow,
    usub_with_overflow,
    vacopy,
    vaend,
    var_annotation,
    vastart,
    x86_mmx_emms,
    x86_mmx_femms,
    x86_mmx_maskmovq,
    x86_mmx_movnt_dq,
    x86_mmx_packssdw,
    x86_mmx_packsswb,
    x86_mmx_packuswb,
    x86_mmx_padds_b,
    x86_mmx_padds_w,
    x86_mmx_paddus_b,
    x86_mmx_paddus_w,
    x86_mmx_pavg_b,
    x86_mmx_pavg_w,
    x86_mmx_pcmpeq_b,
    x86_mmx_pcmpeq_d,
    x86_mmx_pcmpeq_w,
    x86_mmx_pcmpgt_b,
    x86_mmx_pcmpgt_d,
    x86_mmx_pcmpgt_w,
    x86_mmx_pmadd_wd,
    x86_mmx_pmaxs_w,
    x86_mmx_pmaxu_b,
    x86_mmx_pmins_w,
    x86_mmx_pminu_b,
    x86_mmx_pmovmskb,
    x86_mmx_pmulh_w,
    x86_mmx_pmulhu_w,
    x86_mmx_pmulu_dq,
    x86_mmx_psad_bw,
    x86_mmx_psll_d,
    x86_mmx_psll_q,
    x86_mmx_psll_w,
    x86_mmx_pslli_d,
    x86_mmx_pslli_q,
    x86_mmx_pslli_w,
    x86_mmx_psra_d,
    x86_mmx_psra_w,
    x86_mmx_psrai_d,
    x86_mmx_psrai_w,
    x86_mmx_psrl_d,
    x86_mmx_psrl_q,
    x86_mmx_psrl_w,
    x86_mmx_psrli_d,
    x86_mmx_psrli_q,
    x86_mmx_psrli_w,
    x86_mmx_psubs_b,
    x86_mmx_psubs_w,
    x86_mmx_psubus_b,
    x86_mmx_psubus_w,
    x86_sse2_add_sd,
    x86_sse2_clflush,
    x86_sse2_cmp_pd,
    x86_sse2_cmp_sd,
    x86_sse2_comieq_sd,
    x86_sse2_comige_sd,
    x86_sse2_comigt_sd,
    x86_sse2_comile_sd,
    x86_sse2_comilt_sd,
    x86_sse2_comineq_sd,
    x86_sse2_cvtdq2pd,
    x86_sse2_cvtdq2ps,
    x86_sse2_cvtpd2dq,
    x86_sse2_cvtpd2ps,
    x86_sse2_cvtps2dq,
    x86_sse2_cvtps2pd,
    x86_sse2_cvtsd2si,
    x86_sse2_cvtsd2si64,
    x86_sse2_cvtsd2ss,
    x86_sse2_cvtsi2sd,
    x86_sse2_cvtsi642sd,
    x86_sse2_cvtss2sd,
    x86_sse2_cvttpd2dq,
    x86_sse2_cvttps2dq,
    x86_sse2_cvttsd2si,
    x86_sse2_cvttsd2si64,
    x86_sse2_div_sd,
    x86_sse2_lfence,
    x86_sse2_loadu_dq,
    x86_sse2_loadu_pd,
    x86_sse2_maskmov_dqu,
    x86_sse2_max_pd,
    x86_sse2_max_sd,
    x86_sse2_mfence,
    x86_sse2_min_pd,
    x86_sse2_min_sd,
    x86_sse2_movmsk_pd,
    x86_sse2_movnt_dq,
    x86_sse2_movnt_i,
    x86_sse2_movnt_pd,
    x86_sse2_mul_sd,
    x86_sse2_packssdw_128,
    x86_sse2_packsswb_128,
    x86_sse2_packuswb_128,
    x86_sse2_padds_b,
    x86_sse2_padds_w,
    x86_sse2_paddus_b,
    x86_sse2_paddus_w,
    x86_sse2_pavg_b,
    x86_sse2_pavg_w,
    x86_sse2_pcmpeq_b,
    x86_sse2_pcmpeq_d,
    x86_sse2_pcmpeq_w,
    x86_sse2_pcmpgt_b,
    x86_sse2_pcmpgt_d,
    x86_sse2_pcmpgt_w,
    x86_sse2_pmadd_wd,
    x86_sse2_pmaxs_w,
    x86_sse2_pmaxu_b,
    x86_sse2_pmins_w,
    x86_sse2_pminu_b,
    x86_sse2_pmovmskb_128,
    x86_sse2_pmulh_w,
    x86_sse2_pmulhu_w,
    x86_sse2_pmulu_dq,
    x86_sse2_psad_bw,
    x86_sse2_psll_d,
    x86_sse2_psll_dq,
    x86_sse2_psll_dq_bs,
    x86_sse2_psll_q,
    x86_sse2_psll_w,
    x86_sse2_pslli_d,
    x86_sse2_pslli_q,
    x86_sse2_pslli_w,
    x86_sse2_psra_d,
    x86_sse2_psra_w,
    x86_sse2_psrai_d,
    x86_sse2_psrai_w,
    x86_sse2_psrl_d,
    x86_sse2_psrl_dq,
    x86_sse2_psrl_dq_bs,
    x86_sse2_psrl_q,
    x86_sse2_psrl_w,
    x86_sse2_psrli_d,
    x86_sse2_psrli_q,
    x86_sse2_psrli_w,
    x86_sse2_psubs_b,
    x86_sse2_psubs_w,
    x86_sse2_psubus_b,
    x86_sse2_psubus_w,
    x86_sse2_sqrt_pd,
    x86_sse2_sqrt_sd,
    x86_sse2_storel_dq,
    x86_sse2_storeu_dq,
    x86_sse2_storeu_pd,
    x86_sse2_sub_sd,
    x86_sse2_ucomieq_sd,
    x86_sse2_ucomige_sd,
    x86_sse2_ucomigt_sd,
    x86_sse2_ucomile_sd,
    x86_sse2_ucomilt_sd,
    x86_sse2_ucomineq_sd,
    x86_sse3_addsub_pd,
    x86_sse3_addsub_ps,
    x86_sse3_hadd_pd,
    x86_sse3_hadd_ps,
    x86_sse3_hsub_pd,
    x86_sse3_hsub_ps,
    x86_sse3_ldu_dq,
    x86_sse3_monitor,
    x86_sse3_mwait,
    x86_sse41_blendpd,
    x86_sse41_blendps,
    x86_sse41_blendvpd,
    x86_sse41_blendvps,
    x86_sse41_dppd,
    x86_sse41_dpps,
    x86_sse41_extractps,
    x86_sse41_insertps,
    x86_sse41_movntdqa,
    x86_sse41_mpsadbw,
    x86_sse41_packusdw,
    x86_sse41_pblendvb,
    x86_sse41_pblendw,
    x86_sse41_pcmpeqq,
    x86_sse41_pextrb,
    x86_sse41_pextrd,
    x86_sse41_pextrq,
    x86_sse41_phminposuw,
    x86_sse41_pmaxsb,
    x86_sse41_pmaxsd,
    x86_sse41_pmaxud,
    x86_sse41_pmaxuw,
    x86_sse41_pminsb,
    x86_sse41_pminsd,
    x86_sse41_pminud,
    x86_sse41_pminuw,
    x86_sse41_pmovsxbd,
    x86_sse41_pmovsxbq,
    x86_sse41_pmovsxbw,
    x86_sse41_pmovsxdq,
    x86_sse41_pmovsxwd,
    x86_sse41_pmovsxwq,
    x86_sse41_pmovzxbd,
    x86_sse41_pmovzxbq,
    x86_sse41_pmovzxbw,
    x86_sse41_pmovzxdq,
    x86_sse41_pmovzxwd,
    x86_sse41_pmovzxwq,
    x86_sse41_pmuldq,
    x86_sse41_pmulld,
    x86_sse41_ptestc,
    x86_sse41_ptestnzc,
    x86_sse41_ptestz,
    x86_sse41_round_pd,
    x86_sse41_round_ps,
    x86_sse41_round_sd,
    x86_sse41_round_ss,
    x86_sse42_crc32_16,
    x86_sse42_crc32_32,
    x86_sse42_crc32_64,
    x86_sse42_crc32_8,
    x86_sse42_pcmpestri128,
    x86_sse42_pcmpestria128,
    x86_sse42_pcmpestric128,
    x86_sse42_pcmpestrio128,
    x86_sse42_pcmpestris128,
    x86_sse42_pcmpestriz128,
    x86_sse42_pcmpestrm128,
    x86_sse42_pcmpgtq,
    x86_sse42_pcmpistri128,
    x86_sse42_pcmpistria128,
    x86_sse42_pcmpistric128,
    x86_sse42_pcmpistrio128,
    x86_sse42_pcmpistris128,
    x86_sse42_pcmpistriz128,
    x86_sse42_pcmpistrm128,
    x86_sse_add_ss,
    x86_sse_cmp_ps,
    x86_sse_cmp_ss,
    x86_sse_comieq_ss,
    x86_sse_comige_ss,
    x86_sse_comigt_ss,
    x86_sse_comile_ss,
    x86_sse_comilt_ss,
    x86_sse_comineq_ss,
    x86_sse_cvtpd2pi,
    x86_sse_cvtpi2pd,
    x86_sse_cvtpi2ps,
    x86_sse_cvtps2pi,
    x86_sse_cvtsi2ss,
    x86_sse_cvtsi642ss,
    x86_sse_cvtss2si,
    x86_sse_cvtss2si64,
    x86_sse_cvttpd2pi,
    x86_sse_cvttps2pi,
    x86_sse_cvttss2si,
    x86_sse_cvttss2si64,
    x86_sse_div_ss,
    x86_sse_ldmxcsr,
    x86_sse_loadu_ps,
    x86_sse_max_ps,
    x86_sse_max_ss,
    x86_sse_min_ps,
    x86_sse_min_ss,
    x86_sse_movmsk_ps,
    x86_sse_movnt_ps,
    x86_sse_mul_ss,
    x86_sse_rcp_ps,
    x86_sse_rcp_ss,
    x86_sse_rsqrt_ps,
    x86_sse_rsqrt_ss,
    x86_sse_sfence,
    x86_sse_sqrt_ps,
    x86_sse_sqrt_ss,
    x86_sse_stmxcsr,
    x86_sse_storeu_ps,
    x86_sse_sub_ss,
    x86_sse_ucomieq_ss,
    x86_sse_ucomige_ss,
    x86_sse_ucomigt_ss,
    x86_sse_ucomile_ss,
    x86_sse_ucomilt_ss,
    x86_sse_ucomineq_ss,
    x86_ssse3_pabs_b,
    x86_ssse3_pabs_b_128,
    x86_ssse3_pabs_d,
    x86_ssse3_pabs_d_128,
    x86_ssse3_pabs_w,
    x86_ssse3_pabs_w_128,
    x86_ssse3_palign_r,
    x86_ssse3_palign_r_128,
    x86_ssse3_phadd_d,
    x86_ssse3_phadd_d_128,
    x86_ssse3_phadd_sw,
    x86_ssse3_phadd_sw_128,
    x86_ssse3_phadd_w,
    x86_ssse3_phadd_w_128,
    x86_ssse3_phsub_d,
    x86_ssse3_phsub_d_128,
    x86_ssse3_phsub_sw,
    x86_ssse3_phsub_sw_128,
    x86_ssse3_phsub_w,
    x86_ssse3_phsub_w_128,
    x86_ssse3_pmadd_ub_sw,
    x86_ssse3_pmadd_ub_sw_128,
    x86_ssse3_pmul_hr_sw,
    x86_ssse3_pmul_hr_sw_128,
    x86_ssse3_pshuf_b,
    x86_ssse3_pshuf_b_128,
    x86_ssse3_psign_b,
    x86_ssse3_psign_b_128,
    x86_ssse3_psign_d,
    x86_ssse3_psign_d_128,
    x86_ssse3_psign_w,
    x86_ssse3_psign_w_128,
    xcore_bitrev,
    xcore_getid
# 41 "/local/monniaux/packages/llvm-2.7/include/llvm/Intrinsics.h" 2

    , num_intrinsics
  };



  std::string getName(ID id, const Type **Tys = 0, unsigned numTys = 0);



  const FunctionType *getType(LLVMContext &Context, ID id,
                              const Type **Tys = 0, unsigned numTys = 0);



  bool isOverloaded(ID id);



  AttrListPtr getAttributes(ID id);
# 70 "/local/monniaux/packages/llvm-2.7/include/llvm/Intrinsics.h"
  Function *getDeclaration(Module *M, ID id, const Type **Tys = 0,
                           unsigned numTys = 0);


  ID getIntrinsicForGCCBuiltin(const char *Prefix, const char *BuiltinName);

}

}
# 13 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/IntrinsicInst.h" 1
# 32 "/local/monniaux/packages/llvm-2.7/include/llvm/IntrinsicInst.h"
namespace llvm {



  class IntrinsicInst : public CallInst {
    IntrinsicInst();
    IntrinsicInst(const IntrinsicInst&);
    void operator=(const IntrinsicInst&);
  public:


    Intrinsic::ID getIntrinsicID() const {
      return (Intrinsic::ID)getCalledFunction()->getIntrinsicID();
    }


    static inline bool classof(const IntrinsicInst *) { return true; }
    static inline bool classof(const CallInst *I) {
      if (const Function *CF = I->getCalledFunction())
        return CF->getIntrinsicID() != 0;
      return false;
    }
    static inline bool classof(const Value *V) {
      return isa<CallInst>(V) && classof(cast<CallInst>(V));
    }
  };



  class DbgInfoIntrinsic : public IntrinsicInst {
  public:


    static inline bool classof(const DbgInfoIntrinsic *) { return true; }
    static inline bool classof(const IntrinsicInst *I) {
      switch (I->getIntrinsicID()) {
      case Intrinsic::dbg_declare:
      case Intrinsic::dbg_value:
        return true;
      default: return false;
      }
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }

    static Value *StripCast(Value *C);
  };



  class DbgDeclareInst : public DbgInfoIntrinsic {
  public:
    Value *getAddress() const;
    MDNode *getVariable() const { return cast<MDNode>(getOperand(2)); }


    static inline bool classof(const DbgDeclareInst *) { return true; }
    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::dbg_declare;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };



  class DbgValueInst : public DbgInfoIntrinsic {
  public:
    const Value *getValue() const;
    Value *getValue();
    uint64_t getOffset() const {
      return cast<ConstantInt>(
                             const_cast<Value*>(getOperand(2)))->getZExtValue();
    }
    const MDNode *getVariable() const { return cast<MDNode>(getOperand(3)); }
    MDNode *getVariable() { return cast<MDNode>(getOperand(3)); }


    static inline bool classof(const DbgValueInst *) { return true; }
    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::dbg_value;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };



  class MemIntrinsic : public IntrinsicInst {
  public:
    Value *getRawDest() const { return const_cast<Value*>(getOperand(1)); }

    Value *getLength() const { return const_cast<Value*>(getOperand(3)); }
    ConstantInt *getAlignmentCst() const {
      return cast<ConstantInt>(const_cast<Value*>(getOperand(4)));
    }

    unsigned getAlignment() const {
      return getAlignmentCst()->getZExtValue();
    }




    Value *getDest() const { return getRawDest()->stripPointerCasts(); }



    void setDest(Value *Ptr) {
      ((getRawDest()->getType() == Ptr->getType() && "setDest called with pointer of wrong type!") ? static_cast<void> (0) : __assert_fail ("getRawDest()->getType() == Ptr->getType() && \"setDest called with pointer of wrong type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/IntrinsicInst.h", 145, __PRETTY_FUNCTION__));

      setOperand(1, Ptr);
    }

    void setLength(Value *L) {
      ((getLength()->getType() == L->getType() && "setLength called with value of wrong type!") ? static_cast<void> (0) : __assert_fail ("getLength()->getType() == L->getType() && \"setLength called with value of wrong type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/IntrinsicInst.h", 151, __PRETTY_FUNCTION__));

      setOperand(3, L);
    }

    void setAlignment(Constant* A) {
      setOperand(4, A);
    }

    const Type *getAlignmentType() const {
      return getOperand(4)->getType();
    }


    static inline bool classof(const MemIntrinsic *) { return true; }
    static inline bool classof(const IntrinsicInst *I) {
      switch (I->getIntrinsicID()) {
      case Intrinsic::memcpy:
      case Intrinsic::memmove:
      case Intrinsic::memset:
        return true;
      default: return false;
      }
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };



  class MemSetInst : public MemIntrinsic {
  public:


    Value *getValue() const { return const_cast<Value*>(getOperand(2)); }

    void setValue(Value *Val) {
      ((getValue()->getType() == Val->getType() && "setSource called with pointer of wrong type!") ? static_cast<void> (0) : __assert_fail ("getValue()->getType() == Val->getType() && \"setSource called with pointer of wrong type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/IntrinsicInst.h", 189, __PRETTY_FUNCTION__));

      setOperand(2, Val);
    }


    static inline bool classof(const MemSetInst *) { return true; }
    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::memset;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };



  class MemTransferInst : public MemIntrinsic {
  public:


    Value *getRawSource() const { return const_cast<Value*>(getOperand(2)); }




    Value *getSource() const { return getRawSource()->stripPointerCasts(); }

    void setSource(Value *Ptr) {
      ((getRawSource()->getType() == Ptr->getType() && "setSource called with pointer of wrong type!") ? static_cast<void> (0) : __assert_fail ("getRawSource()->getType() == Ptr->getType() && \"setSource called with pointer of wrong type!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/IntrinsicInst.h", 218, __PRETTY_FUNCTION__));

      setOperand(2, Ptr);
    }


    static inline bool classof(const MemTransferInst *) { return true; }
    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::memcpy ||
             I->getIntrinsicID() == Intrinsic::memmove;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };




  class MemCpyInst : public MemTransferInst {
  public:

    static inline bool classof(const MemCpyInst *) { return true; }
    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::memcpy;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };



  class MemMoveInst : public MemTransferInst {
  public:

    static inline bool classof(const MemMoveInst *) { return true; }
    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::memmove;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };



  class EHSelectorInst : public IntrinsicInst {
  public:

    static inline bool classof(const EHSelectorInst *) { return true; }
    static inline bool classof(const IntrinsicInst *I) {
      return I->getIntrinsicID() == Intrinsic::eh_selector;
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };




  class MemoryUseIntrinsic : public IntrinsicInst {
  public:


    static inline bool classof(const MemoryUseIntrinsic *) { return true; }
    static inline bool classof(const IntrinsicInst *I) {
      switch (I->getIntrinsicID()) {
      case Intrinsic::lifetime_start:
      case Intrinsic::lifetime_end:
      case Intrinsic::invariant_start:
      case Intrinsic::invariant_end:
        return true;
      default: return false;
      }
    }
    static inline bool classof(const Value *V) {
      return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));
    }
  };

}
# 14 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/InlineAsm.h" 1
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/InlineAsm.h"
namespace llvm {

class PointerType;
class FunctionType;
class Module;

class InlineAsm : public Value {
  InlineAsm(const InlineAsm &);
  void operator=(const InlineAsm&);

  std::string AsmString, Constraints;
  bool HasSideEffects;
  bool IsAlignStack;

  InlineAsm(const FunctionType *Ty, StringRef AsmString,
            StringRef Constraints, bool hasSideEffects,
            bool isAlignStack = false);
  virtual ~InlineAsm();
public:



  static InlineAsm *get(const FunctionType *Ty, StringRef AsmString,
                        StringRef Constraints, bool hasSideEffects,
                        bool isAlignStack = false);

  bool hasSideEffects() const { return HasSideEffects; }
  bool isAlignStack() const { return IsAlignStack; }



  const PointerType *getType() const {
    return reinterpret_cast<const PointerType*>(Value::getType());
  }



  const FunctionType *getFunctionType() const;

  const std::string &getAsmString() const { return AsmString; }
  const std::string &getConstraintString() const { return Constraints; }





  static bool Verify(const FunctionType *Ty, StringRef Constraints);


  enum ConstraintPrefix {
    isInput,
    isOutput,
    isClobber
  };

  struct ConstraintInfo {


    ConstraintPrefix Type;



    bool isEarlyClobber;





    signed char MatchingInput;



    bool hasMatchingInput() const { return MatchingInput != -1; }



    bool isCommutative;





    bool isIndirect;



    std::vector<std::string> Codes;




    bool Parse(StringRef Str,
               std::vector<InlineAsm::ConstraintInfo> &ConstraintsSoFar);
  };




  static std::vector<ConstraintInfo>
    ParseConstraints(StringRef ConstraintString);



  std::vector<ConstraintInfo>
  ParseConstraints() const {
    return ParseConstraints(Constraints);
  }


  static inline bool classof(const InlineAsm *) { return true; }
  static inline bool classof(const Value *V) {
    return V->getValueID() == Value::InlineAsmVal;
  }



  static unsigned getNumOperandRegisters(unsigned Flag) {
    return (Flag & 0xffff) >> 3;
  }



  static bool isUseOperandTiedToDef(unsigned Flag, unsigned &Idx) {
    if ((Flag & 0x80000000) == 0)
      return false;
    Idx = (Flag & ~0x80000000) >> 16;
    return true;
  }


};

}
# 15 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringExtras.h" 1
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringExtras.h"
# 1 "/usr/include/c++/4.3/cctype" 1 3
# 46 "/usr/include/c++/4.3/cctype" 3
       
# 47 "/usr/include/c++/4.3/cctype" 3
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringExtras.h" 2
# 1 "/usr/include/c++/4.3/cstdio" 1 3
# 46 "/usr/include/c++/4.3/cstdio" 3
       
# 47 "/usr/include/c++/4.3/cstdio" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 50 "/usr/include/c++/4.3/cstdio" 2 3
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringExtras.h" 2



namespace llvm {
template<typename T> class SmallVectorImpl;



static inline char hexdigit(unsigned X) {
  return X < 10 ? '0' + X : 'A' + X - 10;
}
# 42 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringExtras.h"
template<typename IntTy>
static inline char *utohex_buffer(IntTy X, char *BufferEnd) {
  char *BufPtr = BufferEnd;
  *--BufPtr = 0;
  if (X == 0) {
    *--BufPtr = '0';
    return BufPtr;
  }

  while (X) {
    unsigned char Mod = static_cast<unsigned char>(X) & 15;
    *--BufPtr = hexdigit(Mod);
    X >>= 4;
  }
  return BufPtr;
}

static inline std::string utohexstr(uint64_t X) {
  char Buffer[40];
  return utohex_buffer(X, Buffer+40);
}

static inline std::string utostr_32(uint32_t X, bool isNeg = false) {
  char Buffer[20];
  char *BufPtr = Buffer+19;

  *BufPtr = 0;
  if (X == 0) *--BufPtr = '0';

  while (X) {
    *--BufPtr = '0' + char(X % 10);
    X /= 10;
  }

  if (isNeg) *--BufPtr = '-';

  return std::string(BufPtr);
}

static inline std::string utostr(uint64_t X, bool isNeg = false) {
  if (X == uint32_t(X))
    return utostr_32(uint32_t(X), isNeg);

  char Buffer[40];
  char *BufPtr = Buffer+39;

  *BufPtr = 0;
  if (X == 0) *--BufPtr = '0';

  while (X) {
    *--BufPtr = '0' + char(X % 10);
    X /= 10;
  }

  if (isNeg) *--BufPtr = '-';
  return std::string(BufPtr);
}


static inline std::string itostr(int64_t X) {
  if (X < 0)
    return utostr(static_cast<uint64_t>(-X), true);
  else
    return utostr(static_cast<uint64_t>(X));
}

static inline std::string ftostr(double V) {
  char Buffer[200];
  sprintf(Buffer, "%20.6e", V);
  char *B = Buffer;
  while (*B == ' ') ++B;
  return B;
}

static inline std::string ftostr(const APFloat& V) {
  if (&V.getSemantics() == &APFloat::IEEEdouble)
    return ftostr(V.convertToDouble());
  else if (&V.getSemantics() == &APFloat::IEEEsingle)
    return ftostr((double)V.convertToFloat());
  return "<unknown format in ftostr>";
}

static inline std::string LowercaseString(const std::string &S) {
  std::string result(S);
  for (unsigned i = 0; i < S.length(); ++i)
    if (isupper(result[i]))
      result[i] = char(tolower(result[i]));
  return result;
}

static inline std::string UppercaseString(const std::string &S) {
  std::string result(S);
  for (unsigned i = 0; i < S.length(); ++i)
    if (islower(result[i]))
      result[i] = char(toupper(result[i]));
  return result;
}




StringRef::size_type StrInStrNoCase(StringRef s1, StringRef s2);







std::pair<StringRef, StringRef> getToken(StringRef Source,
                                         StringRef Delimiters = " \t\n\v\f\r");



void SplitString(StringRef Source,
                 SmallVectorImpl<StringRef> &OutFragments,
                 StringRef Delimiters = " \t\n\v\f\r");
# 167 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringExtras.h"
static inline unsigned HashString(StringRef Str, unsigned Result = 0) {
  for (unsigned i = 0, e = Str.size(); i != e; ++i)
    Result = Result * 33 + Str[i];
  return Result;
}

}
# 16 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/STLExtras.h" 1
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/STLExtras.h"
# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/STLExtras.h" 2
# 1 "/usr/include/c++/4.3/cstdlib" 1 3
# 46 "/usr/include/c++/4.3/cstdlib" 3
       
# 47 "/usr/include/c++/4.3/cstdlib" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 50 "/usr/include/c++/4.3/cstdlib" 2 3
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/STLExtras.h" 2
# 1 "/usr/include/c++/4.3/functional" 1 3
# 52 "/usr/include/c++/4.3/functional" 3
       
# 53 "/usr/include/c++/4.3/functional" 3
# 23 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/STLExtras.h" 2



namespace llvm {





template<class Ty>
struct less_ptr : public std::binary_function<Ty, Ty, bool> {
  bool operator()(const Ty* left, const Ty* right) const {
    return *left < *right;
  }
};

template<class Ty>
struct greater_ptr : public std::binary_function<Ty, Ty, bool> {
  bool operator()(const Ty* left, const Ty* right) const {
    return *right < *left;
  }
};






template <class T>
static inline void deleter(T *Ptr) {
  delete Ptr;
}
# 65 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/STLExtras.h"
template <class RootIt, class UnaryFunc>
class mapped_iterator {
  RootIt current;
  UnaryFunc Fn;
public:
  typedef typename std::iterator_traits<RootIt>::iterator_category
          iterator_category;
  typedef typename std::iterator_traits<RootIt>::difference_type
          difference_type;
  typedef typename UnaryFunc::result_type value_type;

  typedef void pointer;

  typedef void reference;

  typedef RootIt iterator_type;
  typedef mapped_iterator<RootIt, UnaryFunc> _Self;

  inline const RootIt &getCurrent() const { return current; }
  inline const UnaryFunc &getFunc() const { return Fn; }

  inline explicit mapped_iterator(const RootIt &I, UnaryFunc F)
    : current(I), Fn(F) {}
  inline mapped_iterator(const mapped_iterator &It)
    : current(It.current), Fn(It.Fn) {}

  inline value_type operator*() const {
    return Fn(*current);
  }

  _Self& operator++() { ++current; return *this; }
  _Self& operator--() { --current; return *this; }
  _Self operator++(int) { _Self __tmp = *this; ++current; return __tmp; }
  _Self operator--(int) { _Self __tmp = *this; --current; return __tmp; }
  _Self operator+ (difference_type n) const {
    return _Self(current + n, Fn);
  }
  _Self& operator+= (difference_type n) { current += n; return *this; }
  _Self operator- (difference_type n) const {
    return _Self(current - n, Fn);
  }
  _Self& operator-= (difference_type n) { current -= n; return *this; }
  reference operator[](difference_type n) const { return *(*this + n); }

  inline bool operator!=(const _Self &X) const { return !operator==(X); }
  inline bool operator==(const _Self &X) const { return current == X.current; }
  inline bool operator< (const _Self &X) const { return current < X.current; }

  inline difference_type operator-(const _Self &X) const {
    return current - X.current;
  }
};

template <class _Iterator, class Func>
inline mapped_iterator<_Iterator, Func>
operator+(typename mapped_iterator<_Iterator, Func>::difference_type N,
          const mapped_iterator<_Iterator, Func>& X) {
  return mapped_iterator<_Iterator, Func>(X.getCurrent() - N, X.getFunc());
}





template <class ItTy, class FuncTy>
inline mapped_iterator<ItTy, FuncTy> map_iterator(const ItTy &I, FuncTy F) {
  return mapped_iterator<ItTy, FuncTy>(I, F);
}
# 143 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/STLExtras.h"
template <typename ItTy, typename Dist>
inline ItTy next(ItTy it, Dist n)
{
  std::advance(it, n);
  return it;
}

template <typename ItTy>
inline ItTy next(ItTy it)
{
  return ++it;
}

template <typename ItTy, typename Dist>
inline ItTy prior(ItTy it, Dist n)
{
  std::advance(it, -n);
  return it;
}

template <typename ItTy>
inline ItTy prior(ItTy it)
{
  return --it;
}
# 190 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/STLExtras.h"
namespace
{
  template <typename T1, typename T2>
  struct tier {
    typedef T1 &first_type;
    typedef T2 &second_type;

    first_type first;
    second_type second;

    tier(first_type f, second_type s) : first(f), second(s) { }
    tier& operator=(const std::pair<T1, T2>& p) {
      first = p.first;
      second = p.second;
      return *this;
    }
  };
}

template <typename T1, typename T2>
inline tier<T1, T2> tie(T1& f, T2& s) {
  return tier<T1, T2>(f, s);
}
# 221 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/STLExtras.h"
template<class T, std::size_t N>
inline T *array_endof(T (&x)[N]) {
  return x+N;
}


template<class T, std::size_t N>
inline size_t array_lengthof(T (&x)[N]) {
  return N;
}



template<typename T>
static inline int array_pod_sort_comparator(const void *P1, const void *P2) {
  if (*reinterpret_cast<const T*>(P1) < *reinterpret_cast<const T*>(P2))
    return -1;
  if (*reinterpret_cast<const T*>(P2) < *reinterpret_cast<const T*>(P1))
    return 1;
  return 0;
}



template<typename T>
static int (*get_array_pad_sort_comparator(const T &X))
             (const void*, const void*) {
  return array_pod_sort_comparator<T>;
}
# 266 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/STLExtras.h"
template<class IteratorTy>
static inline void array_pod_sort(IteratorTy Start, IteratorTy End) {

  if (Start == End) return;
  qsort(&*Start, End-Start, sizeof(*Start),
        get_array_pad_sort_comparator(*Start));
}

template<class IteratorTy>
static inline void array_pod_sort(IteratorTy Start, IteratorTy End,
                                  int (*Compare)(const void*, const void*)) {

  if (Start == End) return;
  qsort(&*Start, End-Start, sizeof(*Start), Compare);
}

}
# 17 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/ConstantsScanner.h" 1
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/ConstantsScanner.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/InstIterator.h" 1
# 25 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/InstIterator.h"
namespace llvm {




template <class _BB_t, class _BB_i_t, class _BI_t, class _II_t>
class InstIterator {
  typedef _BB_t BBty;
  typedef _BB_i_t BBIty;
  typedef _BI_t BIty;
  typedef _II_t IIty;
  _BB_t *BBs;
  _BB_i_t BB;
  _BI_t BI;
public:
  typedef std::bidirectional_iterator_tag iterator_category;
  typedef IIty value_type;
  typedef signed difference_type;
  typedef IIty* pointer;
  typedef IIty& reference;


  InstIterator() {}


  template<typename A, typename B, typename C, typename D>
  InstIterator(const InstIterator<A,B,C,D> &II)
    : BBs(II.BBs), BB(II.BB), BI(II.BI) {}

  template<typename A, typename B, typename C, typename D>
  InstIterator(InstIterator<A,B,C,D> &II)
    : BBs(II.BBs), BB(II.BB), BI(II.BI) {}

  template<class M> InstIterator(M &m)
    : BBs(&m.getBasicBlockList()), BB(BBs->begin()) {
    if (BB != BBs->end()) {
      BI = BB->begin();
      advanceToNextBB();
    }
  }

  template<class M> InstIterator(M &m, bool)
    : BBs(&m.getBasicBlockList()), BB(BBs->end()) {
  }


  inline BBIty &getBasicBlockIterator() { return BB; }
  inline BIty &getInstructionIterator() { return BI; }

  inline reference operator*() const { return *BI; }
  inline pointer operator->() const { return &operator*(); }

  inline bool operator==(const InstIterator &y) const {
    return BB == y.BB && (BB == BBs->end() || BI == y.BI);
  }
  inline bool operator!=(const InstIterator& y) const {
    return !operator==(y);
  }

  InstIterator& operator++() {
    ++BI;
    advanceToNextBB();
    return *this;
  }
  inline InstIterator operator++(int) {
    InstIterator tmp = *this; ++*this; return tmp;
  }

  InstIterator& operator--() {
    while (BB == BBs->end() || BI == BB->begin()) {
      --BB;
      BI = BB->end();
    }
    --BI;
    return *this;
  }
  inline InstIterator operator--(int) {
    InstIterator tmp = *this; --*this; return tmp;
  }

  inline bool atEnd() const { return BB == BBs->end(); }

private:
  inline void advanceToNextBB() {


    while (BI == BB->end()) {
      ++BB;
      if (BB == BBs->end()) break;
      BI = BB->begin();
    }
  }
};


typedef InstIterator<iplist<BasicBlock>,
                     Function::iterator, BasicBlock::iterator,
                     Instruction> inst_iterator;
typedef InstIterator<const iplist<BasicBlock>,
                     Function::const_iterator,
                     BasicBlock::const_iterator,
                     const Instruction> const_inst_iterator;

inline inst_iterator inst_begin(Function *F) { return inst_iterator(*F); }
inline inst_iterator inst_end(Function *F) { return inst_iterator(*F, true); }
inline const_inst_iterator inst_begin(const Function *F) {
  return const_inst_iterator(*F);
}
inline const_inst_iterator inst_end(const Function *F) {
  return const_inst_iterator(*F, true);
}
inline inst_iterator inst_begin(Function &F) { return inst_iterator(F); }
inline inst_iterator inst_end(Function &F) { return inst_iterator(F, true); }
inline const_inst_iterator inst_begin(const Function &F) {
  return const_inst_iterator(F);
}
inline const_inst_iterator inst_end(const Function &F) {
  return const_inst_iterator(F, true);
}

}
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/ConstantsScanner.h" 2

namespace llvm {

class Constant;

class constant_iterator : public std::iterator<std::forward_iterator_tag,
                                               const Constant, ptrdiff_t> {
  const_inst_iterator InstI;
  unsigned OpIdx;

  typedef constant_iterator _Self;

  inline bool isAtConstant() const {
    ((!InstI.atEnd() && OpIdx < InstI->getNumOperands() && "isAtConstant called with invalid arguments!") ? static_cast<void> (0) : __assert_fail ("!InstI.atEnd() && OpIdx < InstI->getNumOperands() && \"isAtConstant called with invalid arguments!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/ConstantsScanner.h", 34, __PRETTY_FUNCTION__));

    return isa<Constant>(InstI->getOperand(OpIdx));
  }

public:
  inline constant_iterator(const Function *F) : InstI(inst_begin(F)), OpIdx(0) {

    if (InstI != inst_end(F) &&
        (InstI->getNumOperands() == 0 || !isAtConstant()))
      operator++();
  }

  inline constant_iterator(const Function *F, bool)
    : InstI(inst_end(F)), OpIdx(0) {
  }

  inline bool operator==(const _Self& x) const { return OpIdx == x.OpIdx &&
                                                        InstI == x.InstI; }
  inline bool operator!=(const _Self& x) const { return !operator==(x); }

  inline pointer operator*() const {
    ((isAtConstant() && "Dereferenced an iterator at the end!") ? static_cast<void> (0) : __assert_fail ("isAtConstant() && \"Dereferenced an iterator at the end!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/ConstantsScanner.h", 55, __PRETTY_FUNCTION__));
    return cast<Constant>(InstI->getOperand(OpIdx));
  }
  inline pointer operator->() const { return operator*(); }

  inline _Self& operator++() {
    ++OpIdx;
    do {
      unsigned NumOperands = InstI->getNumOperands();
      while (OpIdx < NumOperands && !isAtConstant()) {
        ++OpIdx;
      }

      if (OpIdx < NumOperands) return *this;
      ++InstI;
      OpIdx = 0;
    } while (!InstI.atEnd());

    return *this;
  }

  inline _Self operator++(int) {
    _Self tmp = *this; ++*this; return tmp;
  }

  inline bool atEnd() const { return InstI.atEnd(); }
};

inline constant_iterator constant_begin(const Function *F) {
  return constant_iterator(F);
}

inline constant_iterator constant_end(const Function *F) {
  return constant_iterator(F, true);
}

}
# 18 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/FindUsedTypes.h" 1
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/FindUsedTypes.h"
# 1 "/usr/include/c++/4.3/set" 1 3
# 63 "/usr/include/c++/4.3/set" 3
       
# 64 "/usr/include/c++/4.3/set" 3


# 1 "/usr/include/c++/4.3/bits/stl_set.h" 1 3
# 67 "/usr/include/c++/4.3/bits/stl_set.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 90 "/usr/include/c++/4.3/bits/stl_set.h" 3
  template<typename _Key, typename _Compare = std::less<_Key>,
    typename _Alloc = std::allocator<_Key> >
    class set
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

    public:


      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;






      set()
      : _M_t() { }






      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 163 "/usr/include/c++/4.3/bits/stl_set.h" 3
      template<typename _InputIterator>
        set(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 179 "/usr/include/c++/4.3/bits/stl_set.h" 3
      template<typename _InputIterator>
        set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 193 "/usr/include/c++/4.3/bits/stl_set.h" 3
      set(const set& __x)
      : _M_t(__x._M_t) { }
# 215 "/usr/include/c++/4.3/bits/stl_set.h" 3
      set&
      operator=(const set& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 243 "/usr/include/c++/4.3/bits/stl_set.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 330 "/usr/include/c++/4.3/bits/stl_set.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 355 "/usr/include/c++/4.3/bits/stl_set.h" 3
      void



      swap(set& __x)

      { _M_t.swap(__x._M_t); }
# 377 "/usr/include/c++/4.3/bits/stl_set.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
# 404 "/usr/include/c++/4.3/bits/stl_set.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
# 416 "/usr/include/c++/4.3/bits/stl_set.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 430 "/usr/include/c++/4.3/bits/stl_set.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 445 "/usr/include/c++/4.3/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 460 "/usr/include/c++/4.3/bits/stl_set.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }







      void
      clear()
      { _M_t.clear(); }
# 484 "/usr/include/c++/4.3/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 502 "/usr/include/c++/4.3/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 523 "/usr/include/c++/4.3/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 539 "/usr/include/c++/4.3/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 564 "/usr/include/c++/4.3/bits/stl_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
# 593 "/usr/include/c++/4.3/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 610 "/usr/include/c++/4.3/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 662 "/usr/include/c++/4.3/bits/stl_set.h" 3
}
# 67 "/usr/include/c++/4.3/set" 2 3
# 1 "/usr/include/c++/4.3/bits/stl_multiset.h" 1 3
# 67 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 87 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:
      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;





      multiset()
      : _M_t() { }






      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 156 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 172 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 186 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      multiset(const multiset& __x)
      : _M_t(__x._M_t) { }
# 208 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      multiset&
      operator=(const multiset& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 236 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 323 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 348 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      void



      swap(multiset& __x)

      { _M_t.swap(__x._M_t); }
# 368 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 392 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
# 404 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 419 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 434 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 449 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }







      void
      clear()
      { _M_t.clear(); }
# 470 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 488 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 509 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 525 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 550 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
# 580 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 597 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 652 "/usr/include/c++/4.3/bits/stl_multiset.h" 3
}
# 68 "/usr/include/c++/4.3/set" 2 3
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/FindUsedTypes.h" 2

namespace llvm {

class Type;
class Value;

class FindUsedTypes : public ModulePass {
  std::set<const Type *> UsedTypes;
public:
  static char ID;
  FindUsedTypes() : ModulePass(&ID) {}




  const std::set<const Type *> &getTypes() const { return UsedTypes; }





  void print(raw_ostream &o, const Module *M) const;

private:



  void IncorporateType(const Type *Ty);



  void IncorporateValue(const Value *V);

public:

  bool runOnModule(Module &M);


  virtual void getAnalysisUsage(AnalysisUsage &AU) const {
    AU.setPreservesAll();
  }
};

}
# 19 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h" 1
# 35 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DepthFirstIterator.h" 1
# 37 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DepthFirstIterator.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallPtrSet.h" 1
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallPtrSet.h"
# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallPtrSet.h" 2
# 1 "/usr/include/c++/4.3/cstring" 1 3
# 45 "/usr/include/c++/4.3/cstring" 3
       
# 46 "/usr/include/c++/4.3/cstring" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 49 "/usr/include/c++/4.3/cstring" 2 3
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallPtrSet.h" 2




namespace llvm {

class SmallPtrSetIteratorImpl;
# 46 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallPtrSet.h"
class SmallPtrSetImpl {
  friend class SmallPtrSetIteratorImpl;
protected:


  const void **CurArray;



  unsigned CurArraySize;


  unsigned NumElements;
  unsigned NumTombstones;
  const void *SmallArray[1];


  SmallPtrSetImpl(const SmallPtrSetImpl& that);
  explicit SmallPtrSetImpl(unsigned SmallSize) {
    ((SmallSize && (SmallSize & (SmallSize-1)) == 0 && "Initial size must be a power of two!") ? static_cast<void> (0) : __assert_fail ("SmallSize && (SmallSize & (SmallSize-1)) == 0 && \"Initial size must be a power of two!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/SmallPtrSet.h", 66, __PRETTY_FUNCTION__));

    CurArray = &SmallArray[0];
    CurArraySize = SmallSize;


    CurArray[SmallSize] = 0;
    clear();
  }
  ~SmallPtrSetImpl();

public:
  bool empty() const { return size() == 0; }
  unsigned size() const { return NumElements; }

  void clear() {


    if (!isSmall() && NumElements*4 < CurArraySize && CurArraySize > 32)
      return shrink_and_clear();


    memset(CurArray, -1, CurArraySize*sizeof(void*));
    NumElements = 0;
    NumTombstones = 0;
  }

protected:
  static void *getTombstoneMarker() { return reinterpret_cast<void*>(-2); }
  static void *getEmptyMarker() {


    return reinterpret_cast<void*>(-1);
  }




  bool insert_imp(const void * Ptr);





  bool erase_imp(const void * Ptr);

  bool count_imp(const void * Ptr) const {
    if (isSmall()) {

      for (const void *const *APtr = SmallArray,
                      *const *E = SmallArray+NumElements; APtr != E; ++APtr)
        if (*APtr == Ptr)
          return true;
      return false;
    }


    return *FindBucketFor(Ptr) == Ptr;
  }

private:
  bool isSmall() const { return CurArray == &SmallArray[0]; }

  unsigned Hash(const void *Ptr) const {
    return static_cast<unsigned>(((uintptr_t)Ptr >> 4) & (CurArraySize-1));
  }
  const void * const *FindBucketFor(const void *Ptr) const;
  void shrink_and_clear();


  void Grow();

  void operator=(const SmallPtrSetImpl &RHS);
protected:
  void CopyFrom(const SmallPtrSetImpl &RHS);
};



class SmallPtrSetIteratorImpl {
protected:
  const void *const *Bucket;
public:
  explicit SmallPtrSetIteratorImpl(const void *const *BP) : Bucket(BP) {
    AdvanceIfNotValid();
  }

  bool operator==(const SmallPtrSetIteratorImpl &RHS) const {
    return Bucket == RHS.Bucket;
  }
  bool operator!=(const SmallPtrSetIteratorImpl &RHS) const {
    return Bucket != RHS.Bucket;
  }

protected:



  void AdvanceIfNotValid() {
    while (*Bucket == SmallPtrSetImpl::getEmptyMarker() ||
           *Bucket == SmallPtrSetImpl::getTombstoneMarker())
      ++Bucket;
  }
};


template<typename PtrTy>
class SmallPtrSetIterator : public SmallPtrSetIteratorImpl {
  typedef PointerLikeTypeTraits<PtrTy> PtrTraits;

public:
  typedef PtrTy value_type;
  typedef PtrTy reference;
  typedef PtrTy pointer;
  typedef std::ptrdiff_t difference_type;
  typedef std::forward_iterator_tag iterator_category;

  explicit SmallPtrSetIterator(const void *const *BP)
    : SmallPtrSetIteratorImpl(BP) {}



  const PtrTy operator*() const {
    return PtrTraits::getFromVoidPointer(const_cast<void*>(*Bucket));
  }

  inline SmallPtrSetIterator& operator++() {
    ++Bucket;
    AdvanceIfNotValid();
    return *this;
  }

  SmallPtrSetIterator operator++(int) {
    SmallPtrSetIterator tmp = *this; ++*this; return tmp;
  }
};



template<unsigned N>
struct NextPowerOfTwo;



template<unsigned N, bool isPowerTwo>
struct NextPowerOfTwoH {
  enum { Val = N };
};
template<unsigned N>
struct NextPowerOfTwoH<N, false> {
  enum {


    Val = NextPowerOfTwo<(N|(N-1)) + 1>::Val
  };
};

template<unsigned N>
struct NextPowerOfTwo {
  enum { Val = NextPowerOfTwoH<N, (N&(N-1)) == 0>::Val };
};






template<class PtrType, unsigned SmallSize>
class SmallPtrSet : public SmallPtrSetImpl {

  enum { SmallSizePowTwo = NextPowerOfTwo<SmallSize>::Val };
  void *SmallArray[SmallSizePowTwo];
  typedef PointerLikeTypeTraits<PtrType> PtrTraits;
public:
  SmallPtrSet() : SmallPtrSetImpl(NextPowerOfTwo<SmallSizePowTwo>::Val) {}
  SmallPtrSet(const SmallPtrSet &that) : SmallPtrSetImpl(that) {}

  template<typename It>
  SmallPtrSet(It I, It E)
    : SmallPtrSetImpl(NextPowerOfTwo<SmallSizePowTwo>::Val) {
    insert(I, E);
  }



  bool insert(PtrType Ptr) {
    return insert_imp(PtrTraits::getAsVoidPointer(Ptr));
  }



  bool erase(PtrType Ptr) {
    return erase_imp(PtrTraits::getAsVoidPointer(Ptr));
  }


  bool count(PtrType Ptr) const {
    return count_imp(PtrTraits::getAsVoidPointer(Ptr));
  }

  template <typename IterT>
  void insert(IterT I, IterT E) {
    for (; I != E; ++I)
      insert(*I);
  }

  typedef SmallPtrSetIterator<PtrType> iterator;
  typedef SmallPtrSetIterator<PtrType> const_iterator;
  inline iterator begin() const {
    return iterator(CurArray);
  }
  inline iterator end() const {
    return iterator(CurArray+CurArraySize);
  }



  const SmallPtrSet<PtrType, SmallSize>&
  operator=(const SmallPtrSet<PtrType, SmallSize> &RHS) {
    CopyFrom(RHS);
    return *this;
  }

};

}
# 38 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DepthFirstIterator.h" 2




namespace llvm {



template<class SetType, bool External>
class df_iterator_storage {
public:
  SetType Visited;
};

template<class SetType>
class df_iterator_storage<SetType, true> {
public:
  df_iterator_storage(SetType &VSet) : Visited(VSet) {}
  df_iterator_storage(const df_iterator_storage &S) : Visited(S.Visited) {}
  SetType &Visited;
};



template<class GraphT,
class SetType = llvm::SmallPtrSet<typename GraphTraits<GraphT>::NodeType*, 8>,
         bool ExtStorage = false, class GT = GraphTraits<GraphT> >
class df_iterator : public std::iterator<std::forward_iterator_tag,
                                         typename GT::NodeType, ptrdiff_t>,
                    public df_iterator_storage<SetType, ExtStorage> {
  typedef std::iterator<std::forward_iterator_tag,
                        typename GT::NodeType, ptrdiff_t> super;

  typedef typename GT::NodeType NodeType;
  typedef typename GT::ChildIteratorType ChildItTy;
  typedef PointerIntPair<NodeType*, 1> PointerIntTy;




  std::vector<std::pair<PointerIntTy, ChildItTy> > VisitStack;
private:
  inline df_iterator(NodeType *Node) {
    this->Visited.insert(Node);
    VisitStack.push_back(std::make_pair(PointerIntTy(Node, 0),
                                        GT::child_begin(Node)));
  }
  inline df_iterator() {

  }
  inline df_iterator(NodeType *Node, SetType &S)
    : df_iterator_storage<SetType, ExtStorage>(S) {
    if (!S.count(Node)) {
      VisitStack.push_back(std::make_pair(PointerIntTy(Node, 0),
                                          GT::child_begin(Node)));
      this->Visited.insert(Node);
    }
  }
  inline df_iterator(SetType &S)
    : df_iterator_storage<SetType, ExtStorage>(S) {

  }

  inline void toNext() {
    do {
      std::pair<PointerIntTy, ChildItTy> &Top = VisitStack.back();
      NodeType *Node = Top.first.getPointer();
      ChildItTy &It = Top.second;
      if (!Top.first.getInt()) {

        It = GT::child_begin(Node);
        Top.first.setInt(1);
      }

      while (It != GT::child_end(Node)) {
        NodeType *Next = *It++;

        if (Next && !this->Visited.count(Next)) {

          this->Visited.insert(Next);
          VisitStack.push_back(std::make_pair(PointerIntTy(Next, 0),
                                              GT::child_begin(Next)));
          return;
        }
      }


      VisitStack.pop_back();
    } while (!VisitStack.empty());
  }

public:
  typedef typename super::pointer pointer;
  typedef df_iterator<GraphT, SetType, ExtStorage, GT> _Self;


  static inline _Self begin(const GraphT& G) {
    return _Self(GT::getEntryNode(G));
  }
  static inline _Self end(const GraphT& G) { return _Self(); }


  static inline _Self begin(const GraphT& G, SetType &S) {
    return _Self(GT::getEntryNode(G), S);
  }
  static inline _Self end(const GraphT& G, SetType &S) { return _Self(S); }

  inline bool operator==(const _Self& x) const {
    return VisitStack.size() == x.VisitStack.size() &&
           VisitStack == x.VisitStack;
  }
  inline bool operator!=(const _Self& x) const { return !operator==(x); }

  inline pointer operator*() const {
    return VisitStack.back().first.getPointer();
  }





  inline NodeType *operator->() const { return operator*(); }

  inline _Self& operator++() {
    toNext();
    return *this;
  }



  inline _Self& skipChildren() {
    VisitStack.pop_back();
    if (!VisitStack.empty())
      toNext();
    return *this;
  }

  inline _Self operator++(int) {
    _Self tmp = *this; ++*this; return tmp;
  }





  inline bool nodeVisited(NodeType *Node) const {
    return this->Visited.count(Node) != 0;
  }
};




template <class T>
df_iterator<T> df_begin(const T& G) {
  return df_iterator<T>::begin(G);
}

template <class T>
df_iterator<T> df_end(const T& G) {
  return df_iterator<T>::end(G);
}


template <class T, class SetTy = std::set<typename GraphTraits<T>::NodeType*> >
struct df_ext_iterator : public df_iterator<T, SetTy, true> {
  df_ext_iterator(const df_iterator<T, SetTy, true> &V)
    : df_iterator<T, SetTy, true>(V) {}
};

template <class T, class SetTy>
df_ext_iterator<T, SetTy> df_ext_begin(const T& G, SetTy &S) {
  return df_ext_iterator<T, SetTy>::begin(G, S);
}

template <class T, class SetTy>
df_ext_iterator<T, SetTy> df_ext_end(const T& G, SetTy &S) {
  return df_ext_iterator<T, SetTy>::end(G, S);
}



template <class T,
  class SetTy = llvm::SmallPtrSet<typename GraphTraits<T>::NodeType*, 8>,
          bool External = false>
struct idf_iterator : public df_iterator<Inverse<T>, SetTy, External> {
  idf_iterator(const df_iterator<Inverse<T>, SetTy, External> &V)
    : df_iterator<Inverse<T>, SetTy, External>(V) {}
};

template <class T>
idf_iterator<T> idf_begin(const T& G) {
  return idf_iterator<T>::begin(Inverse<T>(G));
}

template <class T>
idf_iterator<T> idf_end(const T& G){
  return idf_iterator<T>::end(Inverse<T>(G));
}


template <class T, class SetTy = std::set<typename GraphTraits<T>::NodeType*> >
struct idf_ext_iterator : public idf_iterator<T, SetTy, true> {
  idf_ext_iterator(const idf_iterator<T, SetTy, true> &V)
    : idf_iterator<T, SetTy, true>(V) {}
  idf_ext_iterator(const df_iterator<Inverse<T>, SetTy, true> &V)
    : idf_iterator<T, SetTy, true>(V) {}
};

template <class T, class SetTy>
idf_ext_iterator<T, SetTy> idf_ext_begin(const T& G, SetTy &S) {
  return idf_ext_iterator<T, SetTy>::begin(Inverse<T>(G), S);
}

template <class T, class SetTy>
idf_ext_iterator<T, SetTy> idf_ext_end(const T& G, SetTy &S) {
  return idf_ext_iterator<T, SetTy>::end(Inverse<T>(G), S);
}

}
# 36 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h" 2


# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h" 1
# 27 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DenseMap.h" 1
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DenseMap.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DenseMapInfo.h" 1
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DenseMapInfo.h"
namespace llvm {

template<typename T>
struct DenseMapInfo {




};


template<typename T>
struct DenseMapInfo<T*> {
  static inline T* getEmptyKey() {
    intptr_t Val = -1;
    Val <<= PointerLikeTypeTraits<T*>::NumLowBitsAvailable;
    return reinterpret_cast<T*>(Val);
  }
  static inline T* getTombstoneKey() {
    intptr_t Val = -2;
    Val <<= PointerLikeTypeTraits<T*>::NumLowBitsAvailable;
    return reinterpret_cast<T*>(Val);
  }
  static unsigned getHashValue(const T *PtrVal) {
    return (unsigned((uintptr_t)PtrVal) >> 4) ^
           (unsigned((uintptr_t)PtrVal) >> 9);
  }
  static bool isEqual(const T *LHS, const T *RHS) { return LHS == RHS; }
};


template<> struct DenseMapInfo<char> {
  static inline char getEmptyKey() { return ~0; }
  static inline char getTombstoneKey() { return ~0 - 1; }
  static unsigned getHashValue(const char& Val) { return Val * 37; }
  static bool isEqual(const char &LHS, const char &RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<unsigned> {
  static inline unsigned getEmptyKey() { return ~0; }
  static inline unsigned getTombstoneKey() { return ~0U - 1; }
  static unsigned getHashValue(const unsigned& Val) { return Val * 37; }
  static bool isEqual(const unsigned& LHS, const unsigned& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<unsigned long> {
  static inline unsigned long getEmptyKey() { return ~0UL; }
  static inline unsigned long getTombstoneKey() { return ~0UL - 1L; }
  static unsigned getHashValue(const unsigned long& Val) {
    return (unsigned)(Val * 37UL);
  }
  static bool isEqual(const unsigned long& LHS, const unsigned long& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<unsigned long long> {
  static inline unsigned long long getEmptyKey() { return ~0ULL; }
  static inline unsigned long long getTombstoneKey() { return ~0ULL - 1ULL; }
  static unsigned getHashValue(const unsigned long long& Val) {
    return (unsigned)(Val * 37ULL);
  }
  static bool isEqual(const unsigned long long& LHS,
                      const unsigned long long& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<long long> {
  static inline long long getEmptyKey() { return 0x7fffffffffffffffLL; }
  static inline long long getTombstoneKey() { return -0x7fffffffffffffffLL-1; }
  static unsigned getHashValue(const long long& Val) {
    return (unsigned)(Val * 37LL);
  }
  static bool isEqual(const long long& LHS,
                      const long long& RHS) {
    return LHS == RHS;
  }
};


template<typename T, typename U>
struct DenseMapInfo<std::pair<T, U> > {
  typedef std::pair<T, U> Pair;
  typedef DenseMapInfo<T> FirstInfo;
  typedef DenseMapInfo<U> SecondInfo;

  static inline Pair getEmptyKey() {
    return std::make_pair(FirstInfo::getEmptyKey(),
                          SecondInfo::getEmptyKey());
  }
  static inline Pair getTombstoneKey() {
    return std::make_pair(FirstInfo::getTombstoneKey(),
                            SecondInfo::getEmptyKey());
  }
  static unsigned getHashValue(const Pair& PairVal) {
    uint64_t key = (uint64_t)FirstInfo::getHashValue(PairVal.first) << 32
          | (uint64_t)SecondInfo::getHashValue(PairVal.second);
    key += ~(key << 32);
    key ^= (key >> 22);
    key += ~(key << 13);
    key ^= (key >> 8);
    key += (key << 3);
    key ^= (key >> 15);
    key += ~(key << 27);
    key ^= (key >> 31);
    return (unsigned)key;
  }
  static bool isEqual(const Pair& LHS, const Pair& RHS) { return LHS == RHS; }
};

}
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DenseMap.h" 2



# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 25 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DenseMap.h" 2
# 1 "/usr/include/c++/4.3/cstring" 1 3
# 45 "/usr/include/c++/4.3/cstring" 3
       
# 46 "/usr/include/c++/4.3/cstring" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 49 "/usr/include/c++/4.3/cstring" 2 3
# 26 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DenseMap.h" 2

namespace llvm {

template<typename KeyT, typename ValueT,
         typename KeyInfoT = DenseMapInfo<KeyT>,
         typename ValueInfoT = DenseMapInfo<ValueT>, bool IsConst = false>
class DenseMapIterator;

template<typename KeyT, typename ValueT,
         typename KeyInfoT = DenseMapInfo<KeyT>,
         typename ValueInfoT = DenseMapInfo<ValueT> >
class DenseMap {
  typedef std::pair<KeyT, ValueT> BucketT;
  unsigned NumBuckets;
  BucketT *Buckets;

  unsigned NumEntries;
  unsigned NumTombstones;
public:
  typedef KeyT key_type;
  typedef ValueT mapped_type;
  typedef BucketT value_type;

  DenseMap(const DenseMap &other) {
    NumBuckets = 0;
    CopyFrom(other);
  }

  explicit DenseMap(unsigned NumInitBuckets = 64) {
    init(NumInitBuckets);
  }

  template<typename InputIt>
  DenseMap(const InputIt &I, const InputIt &E) {
    init(64);
    insert(I, E);
  }

  ~DenseMap() {
    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();
    for (BucketT *P = Buckets, *E = Buckets+NumBuckets; P != E; ++P) {
      if (!KeyInfoT::isEqual(P->first, EmptyKey) &&
          !KeyInfoT::isEqual(P->first, TombstoneKey))
        P->second.~ValueT();
      P->first.~KeyT();
    }

    memset(Buckets, 0x5a, sizeof(BucketT)*NumBuckets);

    operator delete(Buckets);
  }

  typedef DenseMapIterator<KeyT, ValueT, KeyInfoT> iterator;
  typedef DenseMapIterator<KeyT, ValueT,
                           KeyInfoT, ValueInfoT, true> const_iterator;
  inline iterator begin() {
     return iterator(Buckets, Buckets+NumBuckets);
  }
  inline iterator end() {
    return iterator(Buckets+NumBuckets, Buckets+NumBuckets);
  }
  inline const_iterator begin() const {
    return const_iterator(Buckets, Buckets+NumBuckets);
  }
  inline const_iterator end() const {
    return const_iterator(Buckets+NumBuckets, Buckets+NumBuckets);
  }

  bool empty() const { return NumEntries == 0; }
  unsigned size() const { return NumEntries; }


  void resize(size_t Size) { grow(Size); }

  void clear() {
    if (NumEntries == 0 && NumTombstones == 0) return;



    if (NumEntries * 4 < NumBuckets && NumBuckets > 64) {
      shrink_and_clear();
      return;
    }

    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();
    for (BucketT *P = Buckets, *E = Buckets+NumBuckets; P != E; ++P) {
      if (!KeyInfoT::isEqual(P->first, EmptyKey)) {
        if (!KeyInfoT::isEqual(P->first, TombstoneKey)) {
          P->second.~ValueT();
          --NumEntries;
        }
        P->first = EmptyKey;
      }
    }
    ((NumEntries == 0 && "Node count imbalance!") ? static_cast<void> (0) : __assert_fail ("NumEntries == 0 && \"Node count imbalance!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DenseMap.h", 120, __PRETTY_FUNCTION__));
    NumTombstones = 0;
  }


  bool count(const KeyT &Val) const {
    BucketT *TheBucket;
    return LookupBucketFor(Val, TheBucket);
  }

  iterator find(const KeyT &Val) {
    BucketT *TheBucket;
    if (LookupBucketFor(Val, TheBucket))
      return iterator(TheBucket, Buckets+NumBuckets);
    return end();
  }
  const_iterator find(const KeyT &Val) const {
    BucketT *TheBucket;
    if (LookupBucketFor(Val, TheBucket))
      return const_iterator(TheBucket, Buckets+NumBuckets);
    return end();
  }



  ValueT lookup(const KeyT &Val) const {
    BucketT *TheBucket;
    if (LookupBucketFor(Val, TheBucket))
      return TheBucket->second;
    return ValueT();
  }




  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {
    BucketT *TheBucket;
    if (LookupBucketFor(KV.first, TheBucket))
      return std::make_pair(iterator(TheBucket, Buckets+NumBuckets),
                            false);


    TheBucket = InsertIntoBucket(KV.first, KV.second, TheBucket);
    return std::make_pair(iterator(TheBucket, Buckets+NumBuckets),
                          true);
  }


  template<typename InputIt>
  void insert(InputIt I, InputIt E) {
    for (; I != E; ++I)
      insert(*I);
  }


  bool erase(const KeyT &Val) {
    BucketT *TheBucket;
    if (!LookupBucketFor(Val, TheBucket))
      return false;

    TheBucket->second.~ValueT();
    TheBucket->first = getTombstoneKey();
    --NumEntries;
    ++NumTombstones;
    return true;
  }
  bool erase(iterator I) {
    BucketT *TheBucket = &*I;
    TheBucket->second.~ValueT();
    TheBucket->first = getTombstoneKey();
    --NumEntries;
    ++NumTombstones;
    return true;
  }

  void swap(DenseMap& RHS) {
    std::swap(NumBuckets, RHS.NumBuckets);
    std::swap(Buckets, RHS.Buckets);
    std::swap(NumEntries, RHS.NumEntries);
    std::swap(NumTombstones, RHS.NumTombstones);
  }

  value_type& FindAndConstruct(const KeyT &Key) {
    BucketT *TheBucket;
    if (LookupBucketFor(Key, TheBucket))
      return *TheBucket;

    return *InsertIntoBucket(Key, ValueT(), TheBucket);
  }

  ValueT &operator[](const KeyT &Key) {
    return FindAndConstruct(Key).second;
  }

  DenseMap& operator=(const DenseMap& other) {
    CopyFrom(other);
    return *this;
  }




  bool isPointerIntoBucketsArray(const void *Ptr) const {
    return Ptr >= Buckets && Ptr < Buckets+NumBuckets;
  }




  const void *getPointerIntoBucketsArray() const { return Buckets; }

private:
  void CopyFrom(const DenseMap& other) {
    if (NumBuckets != 0 &&
        (!isPodLike<KeyInfoT>::value || !isPodLike<ValueInfoT>::value)) {
      const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();
      for (BucketT *P = Buckets, *E = Buckets+NumBuckets; P != E; ++P) {
        if (!KeyInfoT::isEqual(P->first, EmptyKey) &&
            !KeyInfoT::isEqual(P->first, TombstoneKey))
          P->second.~ValueT();
        P->first.~KeyT();
      }
    }

    NumEntries = other.NumEntries;
    NumTombstones = other.NumTombstones;

    if (NumBuckets) {

      memset(Buckets, 0x5a, sizeof(BucketT)*NumBuckets);

      operator delete(Buckets);
    }
    Buckets = static_cast<BucketT*>(operator new(sizeof(BucketT) *
                                                 other.NumBuckets));

    if (isPodLike<KeyInfoT>::value && isPodLike<ValueInfoT>::value)
      memcpy(Buckets, other.Buckets, other.NumBuckets * sizeof(BucketT));
    else
      for (size_t i = 0; i < other.NumBuckets; ++i) {
        new (&Buckets[i].first) KeyT(other.Buckets[i].first);
        if (!KeyInfoT::isEqual(Buckets[i].first, getEmptyKey()) &&
            !KeyInfoT::isEqual(Buckets[i].first, getTombstoneKey()))
          new (&Buckets[i].second) ValueT(other.Buckets[i].second);
      }
    NumBuckets = other.NumBuckets;
  }

  BucketT *InsertIntoBucket(const KeyT &Key, const ValueT &Value,
                            BucketT *TheBucket) {
# 279 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DenseMap.h"
    ++NumEntries;
    if (NumEntries*4 >= NumBuckets*3 ||
        NumBuckets-(NumEntries+NumTombstones) < NumBuckets/8) {
      this->grow(NumBuckets * 2);
      LookupBucketFor(Key, TheBucket);
    }


    if (!KeyInfoT::isEqual(TheBucket->first, getEmptyKey()))
      --NumTombstones;

    TheBucket->first = Key;
    new (&TheBucket->second) ValueT(Value);
    return TheBucket;
  }

  static unsigned getHashValue(const KeyT &Val) {
    return KeyInfoT::getHashValue(Val);
  }
  static const KeyT getEmptyKey() {
    return KeyInfoT::getEmptyKey();
  }
  static const KeyT getTombstoneKey() {
    return KeyInfoT::getTombstoneKey();
  }





  bool LookupBucketFor(const KeyT &Val, BucketT *&FoundBucket) const {
    unsigned BucketNo = getHashValue(Val);
    unsigned ProbeAmt = 1;
    BucketT *BucketsPtr = Buckets;


    BucketT *FoundTombstone = 0;
    const KeyT EmptyKey = getEmptyKey();
    const KeyT TombstoneKey = getTombstoneKey();
    ((!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && "Empty/Tombstone value shouldn't be inserted into map!") ? static_cast<void> (0) : __assert_fail ("!KeyInfoT::isEqual(Val, EmptyKey) && !KeyInfoT::isEqual(Val, TombstoneKey) && \"Empty/Tombstone value shouldn't be inserted into map!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DenseMap.h", 320, __PRETTY_FUNCTION__));



    while (1) {
      BucketT *ThisBucket = BucketsPtr + (BucketNo & (NumBuckets-1));

      if (KeyInfoT::isEqual(ThisBucket->first, Val)) {
        FoundBucket = ThisBucket;
        return true;
      }



      if (KeyInfoT::isEqual(ThisBucket->first, EmptyKey)) {


        if (FoundTombstone) ThisBucket = FoundTombstone;
        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;
        return false;
      }



      if (KeyInfoT::isEqual(ThisBucket->first, TombstoneKey) && !FoundTombstone)
        FoundTombstone = ThisBucket;



      BucketNo += ProbeAmt++;
    }
  }

  void init(unsigned InitBuckets) {
    NumEntries = 0;
    NumTombstones = 0;
    NumBuckets = InitBuckets;
    ((InitBuckets && (InitBuckets & (InitBuckets-1)) == 0 && "# initial buckets must be a power of two!") ? static_cast<void> (0) : __assert_fail ("InitBuckets && (InitBuckets & (InitBuckets-1)) == 0 && \"# initial buckets must be a power of two!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DenseMap.h", 356, __PRETTY_FUNCTION__));

    Buckets = static_cast<BucketT*>(operator new(sizeof(BucketT)*InitBuckets));

    const KeyT EmptyKey = getEmptyKey();
    for (unsigned i = 0; i != InitBuckets; ++i)
      new (&Buckets[i].first) KeyT(EmptyKey);
  }

  void grow(unsigned AtLeast) {
    unsigned OldNumBuckets = NumBuckets;
    BucketT *OldBuckets = Buckets;


    while (NumBuckets < AtLeast)
      NumBuckets <<= 1;
    NumTombstones = 0;
    Buckets = static_cast<BucketT*>(operator new(sizeof(BucketT)*NumBuckets));


    const KeyT EmptyKey = getEmptyKey();
    for (unsigned i = 0, e = NumBuckets; i != e; ++i)
      new (&Buckets[i].first) KeyT(EmptyKey);


    const KeyT TombstoneKey = getTombstoneKey();
    for (BucketT *B = OldBuckets, *E = OldBuckets+OldNumBuckets; B != E; ++B) {
      if (!KeyInfoT::isEqual(B->first, EmptyKey) &&
          !KeyInfoT::isEqual(B->first, TombstoneKey)) {

        BucketT *DestBucket;
        bool FoundVal = LookupBucketFor(B->first, DestBucket);
        FoundVal = FoundVal;
        ((!FoundVal && "Key already in new map?") ? static_cast<void> (0) : __assert_fail ("!FoundVal && \"Key already in new map?\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/DenseMap.h", 388, __PRETTY_FUNCTION__));
        DestBucket->first = B->first;
        new (&DestBucket->second) ValueT(B->second);


        B->second.~ValueT();
      }
      B->first.~KeyT();
    }


    memset(OldBuckets, 0x5a, sizeof(BucketT)*OldNumBuckets);


    operator delete(OldBuckets);
  }

  void shrink_and_clear() {
    unsigned OldNumBuckets = NumBuckets;
    BucketT *OldBuckets = Buckets;


    NumBuckets = NumEntries > 32 ? 1 << (Log2_32_Ceil(NumEntries) + 1)
                                 : 64;
    NumTombstones = 0;
    Buckets = static_cast<BucketT*>(operator new(sizeof(BucketT)*NumBuckets));


    const KeyT EmptyKey = getEmptyKey();
    for (unsigned i = 0, e = NumBuckets; i != e; ++i)
      new (&Buckets[i].first) KeyT(EmptyKey);


    const KeyT TombstoneKey = getTombstoneKey();
    for (BucketT *B = OldBuckets, *E = OldBuckets+OldNumBuckets; B != E; ++B) {
      if (!KeyInfoT::isEqual(B->first, EmptyKey) &&
          !KeyInfoT::isEqual(B->first, TombstoneKey)) {

        B->second.~ValueT();
      }
      B->first.~KeyT();
    }


    memset(OldBuckets, 0x5a, sizeof(BucketT)*OldNumBuckets);


    operator delete(OldBuckets);

    NumEntries = 0;
  }
};

template<typename KeyT, typename ValueT,
         typename KeyInfoT, typename ValueInfoT, bool IsConst>
class DenseMapIterator {
  typedef std::pair<KeyT, ValueT> Bucket;
  typedef DenseMapIterator<KeyT, ValueT,
                           KeyInfoT, ValueInfoT, true> ConstIterator;
  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, ValueInfoT, true>;
public:
  typedef ptrdiff_t difference_type;
  typedef typename conditional<IsConst, const Bucket, Bucket>::type value_type;
  typedef value_type *pointer;
  typedef value_type &reference;
  typedef std::forward_iterator_tag iterator_category;
private:
  pointer Ptr, End;
public:
  DenseMapIterator() : Ptr(0), End(0) {}

  DenseMapIterator(pointer Pos, pointer E) : Ptr(Pos), End(E) {
    AdvancePastEmptyBuckets();
  }




  DenseMapIterator(const DenseMapIterator<KeyT, ValueT,
                                          KeyInfoT, ValueInfoT, false>& I)
    : Ptr(I.Ptr), End(I.End) {}

  reference operator*() const {
    return *Ptr;
  }
  pointer operator->() const {
    return Ptr;
  }

  bool operator==(const ConstIterator &RHS) const {
    return Ptr == RHS.operator->();
  }
  bool operator!=(const ConstIterator &RHS) const {
    return Ptr != RHS.operator->();
  }

  inline DenseMapIterator& operator++() {
    ++Ptr;
    AdvancePastEmptyBuckets();
    return *this;
  }
  DenseMapIterator operator++(int) {
    DenseMapIterator tmp = *this; ++*this; return tmp;
  }

private:
  void AdvancePastEmptyBuckets() {
    const KeyT Empty = KeyInfoT::getEmptyKey();
    const KeyT Tombstone = KeyInfoT::getTombstoneKey();

    while (Ptr != End &&
           (KeyInfoT::isEqual(Ptr->first, Empty) ||
            KeyInfoT::isEqual(Ptr->first, Tombstone)))
      ++Ptr;
  }
};

}
# 28 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h" 2




# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Assembly/Writer.h" 1
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/Assembly/Writer.h"
namespace llvm {

class Type;
class Module;
class Value;
class raw_ostream;
template <typename T> class SmallVectorImpl;


class TypePrinting {
  void *TypeNames;
  TypePrinting(const TypePrinting &);
  void operator=(const TypePrinting&);
public:
  TypePrinting();
  ~TypePrinting();

  void clear();

  void print(const Type *Ty, raw_ostream &OS, bool IgnoreTopLevelName = false);

  void printAtLeastOneLevel(const Type *Ty, raw_ostream &OS) {
    print(Ty, OS, true);
  }



  bool hasTypeName(const Type *Ty) const;




  void addTypeName(const Type *Ty, const std::string &N);

private:
  void CalcTypeName(const Type *Ty, SmallVectorImpl<const Type *> &TypeStack,
                    raw_ostream &OS, bool IgnoreTopLevelName = false);
};





void WriteTypeSymbolic(raw_ostream &, const Type *, const Module *M);







void WriteAsOperand(raw_ostream &, const Value *, bool PrintTy = true,
                    const Module *Context = 0);

}
# 33 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h" 1
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h"
namespace llvm {





template <class _Ptr, class _USE_iterator>
class PredIterator : public std::iterator<std::forward_iterator_tag,
                                          _Ptr, ptrdiff_t> {
  typedef std::iterator<std::forward_iterator_tag, _Ptr, ptrdiff_t> super;
  _USE_iterator It;
public:
  typedef PredIterator<_Ptr,_USE_iterator> _Self;
  typedef typename super::pointer pointer;

  inline void advancePastNonTerminators() {

    while (!It.atEnd() && !isa<TerminatorInst>(*It))
      ++It;
  }

  inline PredIterator(_Ptr *bb) : It(bb->use_begin()) {
    advancePastNonTerminators();
  }
  inline PredIterator(_Ptr *bb, bool) : It(bb->use_end()) {}

  inline bool operator==(const _Self& x) const { return It == x.It; }
  inline bool operator!=(const _Self& x) const { return !operator==(x); }

  inline pointer operator*() const {
    ((!It.atEnd() && "pred_iterator out of range!") ? static_cast<void> (0) : __assert_fail ("!It.atEnd() && \"pred_iterator out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h", 52, __PRETTY_FUNCTION__));
    return cast<TerminatorInst>(*It)->getParent();
  }
  inline pointer *operator->() const { return &(operator*()); }

  inline _Self& operator++() {
    ((!It.atEnd() && "pred_iterator out of range!") ? static_cast<void> (0) : __assert_fail ("!It.atEnd() && \"pred_iterator out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h", 58, __PRETTY_FUNCTION__));
    ++It; advancePastNonTerminators();
    return *this;
  }

  inline _Self operator++(int) {
    _Self tmp = *this; ++*this; return tmp;
  }
};

typedef PredIterator<BasicBlock, Value::use_iterator> pred_iterator;
typedef PredIterator<const BasicBlock,
                     Value::use_const_iterator> pred_const_iterator;

inline pred_iterator pred_begin(BasicBlock *BB) { return pred_iterator(BB); }
inline pred_const_iterator pred_begin(const BasicBlock *BB) {
  return pred_const_iterator(BB);
}
inline pred_iterator pred_end(BasicBlock *BB) { return pred_iterator(BB, true);}
inline pred_const_iterator pred_end(const BasicBlock *BB) {
  return pred_const_iterator(BB, true);
}







template <class Term_, class BB_>
class SuccIterator : public std::iterator<std::bidirectional_iterator_tag,
                                          BB_, ptrdiff_t> {
  const Term_ Term;
  unsigned idx;
  typedef std::iterator<std::bidirectional_iterator_tag, BB_, ptrdiff_t> super;
public:
  typedef SuccIterator<Term_, BB_> _Self;
  typedef typename super::pointer pointer;


  inline SuccIterator(Term_ T) : Term(T), idx(0) {
    ((T && "getTerminator returned null!") ? static_cast<void> (0) : __assert_fail ("T && \"getTerminator returned null!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h", 99, __PRETTY_FUNCTION__));
  }
  inline SuccIterator(Term_ T, bool)
    : Term(T), idx(Term->getNumSuccessors()) {
    ((T && "getTerminator returned null!") ? static_cast<void> (0) : __assert_fail ("T && \"getTerminator returned null!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h", 103, __PRETTY_FUNCTION__));
  }

  inline const _Self &operator=(const _Self &I) {
    ((Term == I.Term &&"Cannot assign iterators to two different blocks!") ? static_cast<void> (0) : __assert_fail ("Term == I.Term &&\"Cannot assign iterators to two different blocks!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h", 107, __PRETTY_FUNCTION__));
    idx = I.idx;
    return *this;
  }

  inline bool index_is_valid (int idx) {
    return idx >= 0 && (unsigned) idx < Term->getNumSuccessors();
  }



  unsigned getSuccessorIndex() const { return idx; }

  inline bool operator==(const _Self& x) const { return idx == x.idx; }
  inline bool operator!=(const _Self& x) const { return !operator==(x); }

  inline pointer operator*() const { return Term->getSuccessor(idx); }
  inline pointer operator->() const { return operator*(); }

  inline _Self& operator++() { ++idx; return *this; }

  inline _Self operator++(int) {
    _Self tmp = *this; ++*this; return tmp;
  }

  inline _Self& operator--() { --idx; return *this; }
  inline _Self operator--(int) {
    _Self tmp = *this; --*this; return tmp;
  }

  inline bool operator<(const _Self& x) const {
    ((Term == x.Term && "Cannot compare iterators of different blocks!") ? static_cast<void> (0) : __assert_fail ("Term == x.Term && \"Cannot compare iterators of different blocks!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h", 138, __PRETTY_FUNCTION__));
    return idx < x.idx;
  }

  inline bool operator<=(const _Self& x) const {
    ((Term == x.Term && "Cannot compare iterators of different blocks!") ? static_cast<void> (0) : __assert_fail ("Term == x.Term && \"Cannot compare iterators of different blocks!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h", 143, __PRETTY_FUNCTION__));
    return idx <= x.idx;
  }
  inline bool operator>=(const _Self& x) const {
    ((Term == x.Term && "Cannot compare iterators of different blocks!") ? static_cast<void> (0) : __assert_fail ("Term == x.Term && \"Cannot compare iterators of different blocks!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h", 147, __PRETTY_FUNCTION__));
    return idx >= x.idx;
  }

  inline bool operator>(const _Self& x) const {
    ((Term == x.Term && "Cannot compare iterators of different blocks!") ? static_cast<void> (0) : __assert_fail ("Term == x.Term && \"Cannot compare iterators of different blocks!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h", 152, __PRETTY_FUNCTION__));
    return idx > x.idx;
  }

  inline _Self& operator+=(int Right) {
    unsigned new_idx = idx + Right;
    ((index_is_valid(new_idx) && "Iterator index out of bound") ? static_cast<void> (0) : __assert_fail ("index_is_valid(new_idx) && \"Iterator index out of bound\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h", 158, __PRETTY_FUNCTION__));
    idx = new_idx;
    return *this;
  }

  inline _Self operator+(int Right) {
    _Self tmp = *this;
    tmp += Right;
    return tmp;
  }

  inline _Self& operator-=(int Right) {
    return operator+=(-Right);
  }

  inline _Self operator-(int Right) {
    return operator+(-Right);
  }

  inline int operator-(const _Self& x) {
    ((Term == x.Term && "Cannot work on iterators of different blocks!") ? static_cast<void> (0) : __assert_fail ("Term == x.Term && \"Cannot work on iterators of different blocks!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h", 178, __PRETTY_FUNCTION__));
    int distance = idx - x.idx;
    return distance;
  }
# 194 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h"
  inline BB_ *getSource() {
      return Term->getParent();
  }
};

typedef SuccIterator<TerminatorInst*, BasicBlock> succ_iterator;
typedef SuccIterator<const TerminatorInst*,
                     const BasicBlock> succ_const_iterator;

inline succ_iterator succ_begin(BasicBlock *BB) {
  return succ_iterator(BB->getTerminator());
}
inline succ_const_iterator succ_begin(const BasicBlock *BB) {
  return succ_const_iterator(BB->getTerminator());
}
inline succ_iterator succ_end(BasicBlock *BB) {
  return succ_iterator(BB->getTerminator(), true);
}
inline succ_const_iterator succ_end(const BasicBlock *BB) {
  return succ_const_iterator(BB->getTerminator(), true);
}
# 225 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h"
template <> struct GraphTraits<BasicBlock*> {
  typedef BasicBlock NodeType;
  typedef succ_iterator ChildIteratorType;

  static NodeType *getEntryNode(BasicBlock *BB) { return BB; }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return succ_begin(N);
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return succ_end(N);
  }
};

template <> struct GraphTraits<const BasicBlock*> {
  typedef const BasicBlock NodeType;
  typedef succ_const_iterator ChildIteratorType;

  static NodeType *getEntryNode(const BasicBlock *BB) { return BB; }

  static inline ChildIteratorType child_begin(NodeType *N) {
    return succ_begin(N);
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return succ_end(N);
  }
};






template <> struct GraphTraits<Inverse<BasicBlock*> > {
  typedef BasicBlock NodeType;
  typedef pred_iterator ChildIteratorType;
  static NodeType *getEntryNode(Inverse<BasicBlock *> G) { return G.Graph; }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return pred_begin(N);
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return pred_end(N);
  }
};

template <> struct GraphTraits<Inverse<const BasicBlock*> > {
  typedef const BasicBlock NodeType;
  typedef pred_const_iterator ChildIteratorType;
  static NodeType *getEntryNode(Inverse<const BasicBlock*> G) {
    return G.Graph;
  }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return pred_begin(N);
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return pred_end(N);
  }
};
# 293 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CFG.h"
template <> struct GraphTraits<Function*> : public GraphTraits<BasicBlock*> {
  static NodeType *getEntryNode(Function *F) { return &F->getEntryBlock(); }


  typedef Function::iterator nodes_iterator;
  static nodes_iterator nodes_begin(Function *F) { return F->begin(); }
  static nodes_iterator nodes_end (Function *F) { return F->end(); }
};
template <> struct GraphTraits<const Function*> :
  public GraphTraits<const BasicBlock*> {
  static NodeType *getEntryNode(const Function *F) {return &F->getEntryBlock();}


  typedef Function::const_iterator nodes_iterator;
  static nodes_iterator nodes_begin(const Function *F) { return F->begin(); }
  static nodes_iterator nodes_end (const Function *F) { return F->end(); }
};







template <> struct GraphTraits<Inverse<Function*> > :
  public GraphTraits<Inverse<BasicBlock*> > {
  static NodeType *getEntryNode(Inverse<Function*> G) {
    return &G.Graph->getEntryBlock();
  }
};
template <> struct GraphTraits<Inverse<const Function*> > :
  public GraphTraits<Inverse<const BasicBlock*> > {
  static NodeType *getEntryNode(Inverse<const Function *> G) {
    return &G.Graph->getEntryBlock();
  }
};

}
# 34 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h" 2

# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/raw_ostream.h" 1
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/raw_ostream.h"
namespace llvm {
  class format_object_base;
  template <typename T>
  class SmallVectorImpl;





class raw_ostream {
private:

  void operator=(const raw_ostream &);
  raw_ostream(const raw_ostream &);
# 53 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/raw_ostream.h"
  char *OutBufStart, *OutBufEnd, *OutBufCur;

  enum BufferKind {
    Unbuffered = 0,
    InternalBuffer,
    ExternalBuffer
  } BufferMode;



  bool Error;

public:

  enum Colors {
    BLACK=0,
    RED,
    GREEN,
    YELLOW,
    BLUE,
    MAGENTA,
    CYAN,
    WHITE,
    SAVEDCOLOR
  };

  explicit raw_ostream(bool unbuffered=false)
    : BufferMode(unbuffered ? Unbuffered : InternalBuffer), Error(false) {

    OutBufStart = OutBufEnd = OutBufCur = 0;
  }

  virtual ~raw_ostream();


  uint64_t tell() const { return current_pos() + GetNumBytesInBuffer(); }



  bool has_error() const {
    return Error;
  }





  void clear_error() {
    Error = false;
  }







  void SetBuffered();



  void SetBufferSize(size_t Size) {
    flush();
    SetBufferAndMode(new char[Size], Size, InternalBuffer);
  }

  size_t GetBufferSize() const {


    if (BufferMode != Unbuffered && OutBufStart == 0)
      return preferred_buffer_size();


    return OutBufEnd - OutBufStart;
  }





  void SetUnbuffered() {
    flush();
    SetBufferAndMode(0, 0, Unbuffered);
  }

  size_t GetNumBytesInBuffer() const {
    return OutBufCur - OutBufStart;
  }





  void flush() {
    if (OutBufCur != OutBufStart)
      flush_nonempty();
  }

  raw_ostream &operator<<(char C) {
    if (OutBufCur >= OutBufEnd)
      return write(C);
    *OutBufCur++ = C;
    return *this;
  }

  raw_ostream &operator<<(unsigned char C) {
    if (OutBufCur >= OutBufEnd)
      return write(C);
    *OutBufCur++ = C;
    return *this;
  }

  raw_ostream &operator<<(signed char C) {
    if (OutBufCur >= OutBufEnd)
      return write(C);
    *OutBufCur++ = C;
    return *this;
  }

  raw_ostream &operator<<(StringRef Str) {

    size_t Size = Str.size();


    if (OutBufCur+Size > OutBufEnd)
      return write(Str.data(), Size);

    memcpy(OutBufCur, Str.data(), Size);
    OutBufCur += Size;
    return *this;
  }

  raw_ostream &operator<<(const char *Str) {



    return this->operator<<(StringRef(Str));
  }

  raw_ostream &operator<<(const std::string &Str) {

    return write(Str.data(), Str.length());
  }

  raw_ostream &operator<<(unsigned long N);
  raw_ostream &operator<<(long N);
  raw_ostream &operator<<(unsigned long long N);
  raw_ostream &operator<<(long long N);
  raw_ostream &operator<<(const void *P);
  raw_ostream &operator<<(unsigned int N) {
    return this->operator<<(static_cast<unsigned long>(N));
  }

  raw_ostream &operator<<(int N) {
    return this->operator<<(static_cast<long>(N));
  }

  raw_ostream &operator<<(double N);


  raw_ostream &write_hex(unsigned long long N);



  raw_ostream &write_escaped(StringRef Str);

  raw_ostream &write(unsigned char C);
  raw_ostream &write(const char *Ptr, size_t Size);


  raw_ostream &operator<<(const format_object_base &Fmt);


  raw_ostream &indent(unsigned NumSpaces);
# 236 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/raw_ostream.h"
  virtual raw_ostream &changeColor(enum Colors, bool = false,
       bool = false) { return *this; }



  virtual raw_ostream &resetColor() { return *this; }




  virtual bool is_displayed() const { return false; }





private:
# 265 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/raw_ostream.h"
  virtual void write_impl(const char *Ptr, size_t Size) = 0;


  virtual void handle();



  virtual uint64_t current_pos() const = 0;

protected:




  void SetBuffer(char *BufferStart, size_t Size) {
    SetBufferAndMode(BufferStart, Size, ExternalBuffer);
  }



  virtual size_t preferred_buffer_size() const;



  void error_detected() { Error = true; }



  const char *getBufferStart() const { return OutBufStart; }




private:

  void SetBufferAndMode(char *BufferStart, size_t Size, BufferKind Mode);




  void flush_nonempty();



  void copy_to_buffer(const char *Ptr, size_t Size);
};







class raw_fd_ostream : public raw_ostream {
  int FD;
  bool ShouldClose;
  uint64_t pos;


  virtual void write_impl(const char *Ptr, size_t Size);



  virtual uint64_t current_pos() const { return pos; }


  virtual size_t preferred_buffer_size() const;

public:

  enum {


    F_Excl = 1,




    F_Append = 2,



    F_Binary = 4
  };
# 357 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/raw_ostream.h"
  raw_fd_ostream(const char *Filename, std::string &ErrorInfo,
                 unsigned Flags = 0);



  raw_fd_ostream(int fd, bool shouldClose,
                 bool unbuffered=false) : raw_ostream(unbuffered), FD(fd),
                                          ShouldClose(shouldClose) {}

  ~raw_fd_ostream();


  void close();



  uint64_t seek(uint64_t off);

  virtual raw_ostream &changeColor(enum Colors colors, bool bold=false,
                                   bool bg=false);
  virtual raw_ostream &resetColor();

  virtual bool is_displayed() const;
};



class raw_stdout_ostream : public raw_fd_ostream {

  virtual void handle();
public:
  raw_stdout_ostream();
};



class raw_stderr_ostream : public raw_fd_ostream {

  virtual void handle();
public:
  raw_stderr_ostream();
};



raw_ostream &outs();



raw_ostream &errs();



raw_ostream &nulls();







class raw_string_ostream : public raw_ostream {
  std::string &OS;


  virtual void write_impl(const char *Ptr, size_t Size);



  virtual uint64_t current_pos() const { return OS.size(); }
public:
  explicit raw_string_ostream(std::string &O) : OS(O) {}
  ~raw_string_ostream();



  std::string& str() {
    flush();
    return OS;
  }
};




class raw_svector_ostream : public raw_ostream {
  SmallVectorImpl<char> &OS;


  virtual void write_impl(const char *Ptr, size_t Size);



  virtual uint64_t current_pos() const;
public:




  explicit raw_svector_ostream(SmallVectorImpl<char> &O);
  ~raw_svector_ostream();




  void resync();



  StringRef str();
};


class raw_null_ostream : public raw_ostream {

  virtual void write_impl(const char *Ptr, size_t size);



  virtual uint64_t current_pos() const;

public:
  explicit raw_null_ostream() {}
  ~raw_null_ostream();
};

}
# 36 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h" 2




namespace llvm {





template <class NodeT>
class DominatorBase {
protected:
  std::vector<NodeT*> Roots;
  const bool IsPostDominators;
  inline explicit DominatorBase(bool isPostDom) :
    Roots(), IsPostDominators(isPostDom) {}
public:





  inline const std::vector<NodeT*> &getRoots() const { return Roots; }



  bool isPostDominator() const { return IsPostDominators; }
};




template<class NodeT> class DominatorTreeBase;
struct PostDominatorTree;
class MachineBasicBlock;

template <class NodeT>
class DomTreeNodeBase {
  NodeT *TheBB;
  DomTreeNodeBase<NodeT> *IDom;
  std::vector<DomTreeNodeBase<NodeT> *> Children;
  int DFSNumIn, DFSNumOut;

  template<class N> friend class DominatorTreeBase;
  friend struct PostDominatorTree;
public:
  typedef typename std::vector<DomTreeNodeBase<NodeT> *>::iterator iterator;
  typedef typename std::vector<DomTreeNodeBase<NodeT> *>::const_iterator
                   const_iterator;

  iterator begin() { return Children.begin(); }
  iterator end() { return Children.end(); }
  const_iterator begin() const { return Children.begin(); }
  const_iterator end() const { return Children.end(); }

  NodeT *getBlock() const { return TheBB; }
  DomTreeNodeBase<NodeT> *getIDom() const { return IDom; }
  const std::vector<DomTreeNodeBase<NodeT>*> &getChildren() const {
    return Children;
  }

  DomTreeNodeBase(NodeT *BB, DomTreeNodeBase<NodeT> *iDom)
    : TheBB(BB), IDom(iDom), DFSNumIn(-1), DFSNumOut(-1) { }

  DomTreeNodeBase<NodeT> *addChild(DomTreeNodeBase<NodeT> *C) {
    Children.push_back(C);
    return C;
  }

  size_t getNumChildren() const {
    return Children.size();
  }

  void clearAllChildren() {
    Children.clear();
  }

  bool compare(DomTreeNodeBase<NodeT> *Other) {
    if (getNumChildren() != Other->getNumChildren())
      return true;

    SmallPtrSet<NodeT *, 4> OtherChildren;
    for(iterator I = Other->begin(), E = Other->end(); I != E; ++I) {
      NodeT *Nd = (*I)->getBlock();
      OtherChildren.insert(Nd);
    }

    for(iterator I = begin(), E = end(); I != E; ++I) {
      NodeT *N = (*I)->getBlock();
      if (OtherChildren.count(N) == 0)
        return true;
    }
    return false;
  }

  void setIDom(DomTreeNodeBase<NodeT> *NewIDom) {
    ((IDom && "No immediate dominator?") ? static_cast<void> (0) : __assert_fail ("IDom && \"No immediate dominator?\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 133, __PRETTY_FUNCTION__));
    if (IDom != NewIDom) {
      typename std::vector<DomTreeNodeBase<NodeT>*>::iterator I =
                  std::find(IDom->Children.begin(), IDom->Children.end(), this);
      ((I != IDom->Children.end() && "Not in immediate dominator children set!") ? static_cast<void> (0) : __assert_fail ("I != IDom->Children.end() && \"Not in immediate dominator children set!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 138, __PRETTY_FUNCTION__));


      IDom->Children.erase(I);


      IDom = NewIDom;
      IDom->Children.push_back(this);
    }
  }



  unsigned getDFSNumIn() const { return DFSNumIn; }
  unsigned getDFSNumOut() const { return DFSNumOut; }
private:


  bool DominatedBy(const DomTreeNodeBase<NodeT> *other) const {
    return this->DFSNumIn >= other->DFSNumIn &&
      this->DFSNumOut <= other->DFSNumOut;
  }
};

__extension__ extern template class DomTreeNodeBase<BasicBlock>;
__extension__ extern template class DomTreeNodeBase<MachineBasicBlock>;

template<class NodeT>
static raw_ostream &operator<<(raw_ostream &o,
                               const DomTreeNodeBase<NodeT> *Node) {
  if (Node->getBlock())
    WriteAsOperand(o, Node->getBlock(), false);
  else
    o << " <<exit node>>";

  o << " {" << Node->getDFSNumIn() << "," << Node->getDFSNumOut() << "}";

  return o << "\n";
}

template<class NodeT>
static void PrintDomTree(const DomTreeNodeBase<NodeT> *N, raw_ostream &o,
                         unsigned Lev) {
  o.indent(2*Lev) << "[" << Lev << "] " << N;
  for (typename DomTreeNodeBase<NodeT>::const_iterator I = N->begin(),
       E = N->end(); I != E; ++I)
    PrintDomTree<NodeT>(*I, o, Lev+1);
}

typedef DomTreeNodeBase<BasicBlock> DomTreeNode;





template<class FuncT, class N>
void Calculate(DominatorTreeBase<typename GraphTraits<N>::NodeType>& DT,
               FuncT& F);

template<class NodeT>
class DominatorTreeBase : public DominatorBase<NodeT> {
protected:
  typedef DenseMap<NodeT*, DomTreeNodeBase<NodeT>*> DomTreeNodeMapType;
  DomTreeNodeMapType DomTreeNodes;
  DomTreeNodeBase<NodeT> *RootNode;

  bool DFSInfoValid;
  unsigned int SlowQueries;

  struct InfoRec {
    unsigned DFSNum;
    unsigned Semi;
    unsigned Size;
    NodeT *Label, *Child;
    unsigned Parent, Ancestor;

    std::vector<NodeT*> Bucket;

    InfoRec() : DFSNum(0), Semi(0), Size(0), Label(0), Child(0), Parent(0),
                Ancestor(0) {}
  };

  DenseMap<NodeT*, NodeT*> IDoms;


  std::vector<NodeT*> Vertex;


  DenseMap<NodeT*, InfoRec> Info;

  void reset() {
    for (typename DomTreeNodeMapType::iterator I = this->DomTreeNodes.begin(),
           E = DomTreeNodes.end(); I != E; ++I)
      delete I->second;
    DomTreeNodes.clear();
    IDoms.clear();
    this->Roots.clear();
    Vertex.clear();
    RootNode = 0;
  }



  template<class N, class GraphT>
  void Split(DominatorTreeBase<typename GraphT::NodeType>& DT,
             typename GraphT::NodeType* NewBB) {
    ((std::distance(GraphT::child_begin(NewBB), GraphT::child_end(NewBB)) == 1 && "NewBB should have a single successor!") ? static_cast<void> (0) : __assert_fail ("std::distance(GraphT::child_begin(NewBB), GraphT::child_end(NewBB)) == 1 && \"NewBB should have a single successor!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 244, __PRETTY_FUNCTION__));

    typename GraphT::NodeType* NewBBSucc = *GraphT::child_begin(NewBB);

    std::vector<typename GraphT::NodeType*> PredBlocks;
    for (typename GraphTraits<Inverse<N> >::ChildIteratorType PI =
         GraphTraits<Inverse<N> >::child_begin(NewBB),
         PE = GraphTraits<Inverse<N> >::child_end(NewBB); PI != PE; ++PI)
      PredBlocks.push_back(*PI);

    ((!PredBlocks.empty() && "No predblocks??") ? static_cast<void> (0) : __assert_fail ("!PredBlocks.empty() && \"No predblocks??\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 253, __PRETTY_FUNCTION__));

    bool NewBBDominatesNewBBSucc = true;
    for (typename GraphTraits<Inverse<N> >::ChildIteratorType PI =
         GraphTraits<Inverse<N> >::child_begin(NewBBSucc),
         E = GraphTraits<Inverse<N> >::child_end(NewBBSucc); PI != E; ++PI)
      if (*PI != NewBB && !DT.dominates(NewBBSucc, *PI) &&
          DT.isReachableFromEntry(*PI)) {
        NewBBDominatesNewBBSucc = false;
        break;
      }



    NodeT *NewBBIDom = 0;
    unsigned i = 0;
    for (i = 0; i < PredBlocks.size(); ++i)
      if (DT.isReachableFromEntry(PredBlocks[i])) {
        NewBBIDom = PredBlocks[i];
        break;
      }




    if (!NewBBIDom)
      return;

    for (i = i + 1; i < PredBlocks.size(); ++i) {
      if (DT.isReachableFromEntry(PredBlocks[i]))
        NewBBIDom = DT.findNearestCommonDominator(NewBBIDom, PredBlocks[i]);
    }


    DomTreeNodeBase<NodeT> *NewBBNode = DT.addNewBlock(NewBB, NewBBIDom);



    if (NewBBDominatesNewBBSucc) {
      DomTreeNodeBase<NodeT> *NewBBSuccNode = DT.getNode(NewBBSucc);
      DT.changeImmediateDominator(NewBBSuccNode, NewBBNode);
    }
  }

public:
  explicit DominatorTreeBase(bool isPostDom)
    : DominatorBase<NodeT>(isPostDom), DFSInfoValid(false), SlowQueries(0) {}
  virtual ~DominatorTreeBase() { reset(); }


  virtual bool runOnFunction(Function &F) { return false; }



  bool compare(DominatorTreeBase &Other) const {

    const DomTreeNodeMapType &OtherDomTreeNodes = Other.DomTreeNodes;
    if (DomTreeNodes.size() != OtherDomTreeNodes.size())
      return true;

    for (typename DomTreeNodeMapType::const_iterator
           I = this->DomTreeNodes.begin(),
           E = this->DomTreeNodes.end(); I != E; ++I) {
      NodeT *BB = I->first;
      typename DomTreeNodeMapType::const_iterator OI = OtherDomTreeNodes.find(BB);
      if (OI == OtherDomTreeNodes.end())
        return true;

      DomTreeNodeBase<NodeT>* MyNd = I->second;
      DomTreeNodeBase<NodeT>* OtherNd = OI->second;

      if (MyNd->compare(OtherNd))
        return true;
    }

    return false;
  }

  virtual void releaseMemory() { reset(); }




  inline DomTreeNodeBase<NodeT> *getNode(NodeT *BB) const {
    typename DomTreeNodeMapType::const_iterator I = DomTreeNodes.find(BB);
    return I != DomTreeNodes.end() ? I->second : 0;
  }
# 348 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h"
  DomTreeNodeBase<NodeT> *getRootNode() { return RootNode; }
  const DomTreeNodeBase<NodeT> *getRootNode() const { return RootNode; }




  bool properlyDominates(const DomTreeNodeBase<NodeT> *A,
                         const DomTreeNodeBase<NodeT> *B) const {
    if (A == 0 || B == 0) return false;
    return dominatedBySlowTreeWalk(A, B);
  }

  inline bool properlyDominates(NodeT *A, NodeT *B) {
    return properlyDominates(getNode(A), getNode(B));
  }

  bool dominatedBySlowTreeWalk(const DomTreeNodeBase<NodeT> *A,
                               const DomTreeNodeBase<NodeT> *B) const {
    const DomTreeNodeBase<NodeT> *IDom;
    if (A == 0 || B == 0) return false;
    while ((IDom = B->getIDom()) != 0 && IDom != A && IDom != B)
      B = IDom;
    return IDom != 0;
  }




  bool isReachableFromEntry(NodeT* A) {
    ((!this->isPostDominator() && "This is not implemented for post dominators") ? static_cast<void> (0) : __assert_fail ("!this->isPostDominator() && \"This is not implemented for post dominators\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 378, __PRETTY_FUNCTION__));

    return dominates(&A->getParent()->front(), A);
  }




  inline bool dominates(const DomTreeNodeBase<NodeT> *A,
                        const DomTreeNodeBase<NodeT> *B) {
    if (B == A)
      return true;

    if (A == 0 || B == 0)
      return false;
# 400 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h"
    if (DFSInfoValid)
      return B->DominatedBy(A);



    SlowQueries++;
    if (SlowQueries > 32) {
      updateDFSNumbers();
      return B->DominatedBy(A);
    }

    return dominatedBySlowTreeWalk(A, B);
  }

  inline bool dominates(const NodeT *A, const NodeT *B) {
    if (A == B)
      return true;




    return dominates(getNode(const_cast<NodeT *>(A)),
                     getNode(const_cast<NodeT *>(B)));
  }

  NodeT *getRoot() const {
    ((this->Roots.size() == 1 && "Should always have entry node!") ? static_cast<void> (0) : __assert_fail ("this->Roots.size() == 1 && \"Should always have entry node!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 426, __PRETTY_FUNCTION__));
    return this->Roots[0];
  }



  NodeT *findNearestCommonDominator(NodeT *A, NodeT *B) {

    ((!this->isPostDominator() && "This is not implemented for post dominators") ? static_cast<void> (0) : __assert_fail ("!this->isPostDominator() && \"This is not implemented for post dominators\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 435, __PRETTY_FUNCTION__));

    ((A->getParent() == B->getParent() && "Two blocks are not in same function") ? static_cast<void> (0) : __assert_fail ("A->getParent() == B->getParent() && \"Two blocks are not in same function\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 437, __PRETTY_FUNCTION__));



    NodeT &Entry = A->getParent()->front();
    if (A == &Entry || B == &Entry)
      return &Entry;


    if (dominates(B, A))
      return B;


    if (dominates(A, B))
      return A;

    DomTreeNodeBase<NodeT> *NodeA = getNode(A);
    DomTreeNodeBase<NodeT> *NodeB = getNode(B);


    SmallPtrSet<DomTreeNodeBase<NodeT>*, 16> NodeADoms;
    NodeADoms.insert(NodeA);
    DomTreeNodeBase<NodeT> *IDomA = NodeA->getIDom();
    while (IDomA) {
      NodeADoms.insert(IDomA);
      IDomA = IDomA->getIDom();
    }


    DomTreeNodeBase<NodeT> *IDomB = NodeB->getIDom();
    while(IDomB) {
      if (NodeADoms.count(IDomB) != 0)
        return IDomB->getBlock();

      IDomB = IDomB->getIDom();
    }

    return __null;
  }
# 483 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h"
  DomTreeNodeBase<NodeT> *addNewBlock(NodeT *BB, NodeT *DomBB) {
    ((getNode(BB) == 0 && "Block already in dominator tree!") ? static_cast<void> (0) : __assert_fail ("getNode(BB) == 0 && \"Block already in dominator tree!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 484, __PRETTY_FUNCTION__));
    DomTreeNodeBase<NodeT> *IDomNode = getNode(DomBB);
    ((IDomNode && "Not immediate dominator specified for block!") ? static_cast<void> (0) : __assert_fail ("IDomNode && \"Not immediate dominator specified for block!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 486, __PRETTY_FUNCTION__));
    DFSInfoValid = false;
    return DomTreeNodes[BB] =
      IDomNode->addChild(new DomTreeNodeBase<NodeT>(BB, IDomNode));
  }




  void changeImmediateDominator(DomTreeNodeBase<NodeT> *N,
                                DomTreeNodeBase<NodeT> *NewIDom) {
    ((N && NewIDom && "Cannot change null node pointers!") ? static_cast<void> (0) : __assert_fail ("N && NewIDom && \"Cannot change null node pointers!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 497, __PRETTY_FUNCTION__));
    DFSInfoValid = false;
    N->setIDom(NewIDom);
  }

  void changeImmediateDominator(NodeT *BB, NodeT *NewBB) {
    changeImmediateDominator(getNode(BB), getNode(NewBB));
  }




  void eraseNode(NodeT *BB) {
    DomTreeNodeBase<NodeT> *Node = getNode(BB);
    ((Node && "Removing node that isn't in dominator tree.") ? static_cast<void> (0) : __assert_fail ("Node && \"Removing node that isn't in dominator tree.\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 511, __PRETTY_FUNCTION__));
    ((Node->getChildren().empty() && "Node is not a leaf node.") ? static_cast<void> (0) : __assert_fail ("Node->getChildren().empty() && \"Node is not a leaf node.\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 512, __PRETTY_FUNCTION__));


    DomTreeNodeBase<NodeT> *IDom = Node->getIDom();
    if (IDom) {
      typename std::vector<DomTreeNodeBase<NodeT>*>::iterator I =
        std::find(IDom->Children.begin(), IDom->Children.end(), Node);
      ((I != IDom->Children.end() && "Not in immediate dominator children set!") ? static_cast<void> (0) : __assert_fail ("I != IDom->Children.end() && \"Not in immediate dominator children set!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 520, __PRETTY_FUNCTION__));


      IDom->Children.erase(I);
    }

    DomTreeNodes.erase(BB);
    delete Node;
  }




  void removeNode(NodeT *BB) {
    ((getNode(BB) && "Removing node that isn't in dominator tree.") ? static_cast<void> (0) : __assert_fail ("getNode(BB) && \"Removing node that isn't in dominator tree.\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 533, __PRETTY_FUNCTION__));
    DomTreeNodes.erase(BB);
  }



  void splitBlock(NodeT* NewBB) {
    if (this->IsPostDominators)
      this->Split<Inverse<NodeT*>, GraphTraits<Inverse<NodeT*> > >(*this, NewBB);
    else
      this->Split<NodeT*, GraphTraits<NodeT*> >(*this, NewBB);
  }



  void print(raw_ostream &o) const {
    o << "=============================--------------------------------\n";
    if (this->isPostDominator())
      o << "Inorder PostDominator Tree: ";
    else
      o << "Inorder Dominator Tree: ";
    if (this->DFSInfoValid)
      o << "DFSNumbers invalid: " << SlowQueries << " slow queries.";
    o << "\n";


    if (getRootNode())
      PrintDomTree<NodeT>(getRootNode(), o, 1);
  }

protected:
  template<class GraphT>
  friend void Compress(DominatorTreeBase<typename GraphT::NodeType>& DT,
                       typename GraphT::NodeType* VIn);

  template<class GraphT>
  friend typename GraphT::NodeType* Eval(
                               DominatorTreeBase<typename GraphT::NodeType>& DT,
                                         typename GraphT::NodeType* V);

  template<class GraphT>
  friend void Link(DominatorTreeBase<typename GraphT::NodeType>& DT,
                   unsigned DFSNumV, typename GraphT::NodeType* W,
         typename DominatorTreeBase<typename GraphT::NodeType>::InfoRec &WInfo);

  template<class GraphT>
  friend unsigned DFSPass(DominatorTreeBase<typename GraphT::NodeType>& DT,
                          typename GraphT::NodeType* V,
                          unsigned N);

  template<class FuncT, class N>
  friend void Calculate(DominatorTreeBase<typename GraphTraits<N>::NodeType>& DT,
                        FuncT& F);



  void updateDFSNumbers() {
    unsigned DFSNum = 0;

    SmallVector<std::pair<DomTreeNodeBase<NodeT>*,
                typename DomTreeNodeBase<NodeT>::iterator>, 32> WorkStack;

    DomTreeNodeBase<NodeT> *ThisRoot = getRootNode();

    if (!ThisRoot)
      return;





    WorkStack.push_back(std::make_pair(ThisRoot, ThisRoot->begin()));
    ThisRoot->DFSNumIn = DFSNum++;

    while (!WorkStack.empty()) {
      DomTreeNodeBase<NodeT> *Node = WorkStack.back().first;
      typename DomTreeNodeBase<NodeT>::iterator ChildIt =
        WorkStack.back().second;



      if (ChildIt == Node->end()) {
        Node->DFSNumOut = DFSNum++;
        WorkStack.pop_back();
      } else {

        DomTreeNodeBase<NodeT> *Child = *ChildIt;
        ++WorkStack.back().second;

        WorkStack.push_back(std::make_pair(Child, Child->begin()));
        Child->DFSNumIn = DFSNum++;
      }
    }

    SlowQueries = 0;
    DFSInfoValid = true;
  }

  DomTreeNodeBase<NodeT> *getNodeForBlock(NodeT *BB) {
    typename DomTreeNodeMapType::iterator I = this->DomTreeNodes.find(BB);
    if (I != this->DomTreeNodes.end() && I->second)
      return I->second;



    NodeT *IDom = getIDom(BB);

    ((IDom || this->DomTreeNodes[__null]) ? static_cast<void> (0) : __assert_fail ("IDom || this->DomTreeNodes[__null]", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 640, __PRETTY_FUNCTION__));
    DomTreeNodeBase<NodeT> *IDomNode = getNodeForBlock(IDom);



    DomTreeNodeBase<NodeT> *C = new DomTreeNodeBase<NodeT>(BB, IDomNode);
    return this->DomTreeNodes[BB] = IDomNode->addChild(C);
  }

  inline NodeT *getIDom(NodeT *BB) const {
    typename DenseMap<NodeT*, NodeT*>::const_iterator I = IDoms.find(BB);
    return I != IDoms.end() ? I->second : 0;
  }

  inline void addRoot(NodeT* BB) {
    this->Roots.push_back(BB);
  }

public:

  template<class FT>
  void recalculate(FT& F) {
    reset();
    this->Vertex.push_back(0);

    if (!this->IsPostDominators) {

      this->Roots.push_back(&F.front());
      this->IDoms[&F.front()] = 0;
      this->DomTreeNodes[&F.front()] = 0;

      Calculate<FT, NodeT*>(*this, F);
    } else {

      for (typename FT::iterator I = F.begin(), E = F.end(); I != E; ++I) {
        if (std::distance(GraphTraits<FT*>::child_begin(I),
                          GraphTraits<FT*>::child_end(I)) == 0)
          addRoot(I);


        this->IDoms[I] = 0;
        this->DomTreeNodes[I] = 0;
      }

      Calculate<FT, Inverse<NodeT*> >(*this, F);
    }
  }
};

__extension__ extern template class DominatorTreeBase<BasicBlock>;





class DominatorTree : public FunctionPass {
public:
  static char ID;
  DominatorTreeBase<BasicBlock>* DT;

  DominatorTree() : FunctionPass(&ID) {
    DT = new DominatorTreeBase<BasicBlock>(false);
  }

  ~DominatorTree() {
    DT->releaseMemory();
    delete DT;
  }

  DominatorTreeBase<BasicBlock>& getBase() { return *DT; }





  inline const std::vector<BasicBlock*> &getRoots() const {
    return DT->getRoots();
  }

  inline BasicBlock *getRoot() const {
    return DT->getRoot();
  }

  inline DomTreeNode *getRootNode() const {
    return DT->getRootNode();
  }



  inline bool compare(DominatorTree &Other) const {
    DomTreeNode *R = getRootNode();
    DomTreeNode *OtherR = Other.getRootNode();

    if (!R || !OtherR || R->getBlock() != OtherR->getBlock())
      return true;

    if (DT->compare(Other.getBase()))
      return true;

    return false;
  }

  virtual bool runOnFunction(Function &F);

  virtual void verifyAnalysis() const;

  virtual void getAnalysisUsage(AnalysisUsage &AU) const {
    AU.setPreservesAll();
  }

  inline bool dominates(DomTreeNode* A, DomTreeNode* B) const {
    return DT->dominates(A, B);
  }

  inline bool dominates(const BasicBlock* A, const BasicBlock* B) const {
    return DT->dominates(A, B);
  }



  bool dominates(const Instruction *A, const Instruction *B) const;

  bool properlyDominates(const DomTreeNode *A, const DomTreeNode *B) const {
    return DT->properlyDominates(A, B);
  }

  bool properlyDominates(BasicBlock *A, BasicBlock *B) const {
    return DT->properlyDominates(A, B);
  }



  inline BasicBlock *findNearestCommonDominator(BasicBlock *A, BasicBlock *B) {
    return DT->findNearestCommonDominator(A, B);
  }

  inline DomTreeNode *operator[](BasicBlock *BB) const {
    return DT->getNode(BB);
  }




  inline DomTreeNode *getNode(BasicBlock *BB) const {
    return DT->getNode(BB);
  }




  inline DomTreeNode *addNewBlock(BasicBlock *BB, BasicBlock *DomBB) {
    return DT->addNewBlock(BB, DomBB);
  }




  inline void changeImmediateDominator(BasicBlock *N, BasicBlock* NewIDom) {
    DT->changeImmediateDominator(N, NewIDom);
  }

  inline void changeImmediateDominator(DomTreeNode *N, DomTreeNode* NewIDom) {
    DT->changeImmediateDominator(N, NewIDom);
  }




  inline void eraseNode(BasicBlock *BB) {
    DT->eraseNode(BB);
  }



  inline void splitBlock(BasicBlock* NewBB) {
    DT->splitBlock(NewBB);
  }

  bool isReachableFromEntry(BasicBlock* A) {
    return DT->isReachableFromEntry(A);
  }


  virtual void releaseMemory() {
    DT->releaseMemory();
  }

  virtual void print(raw_ostream &OS, const Module* M= 0) const;
};





template <> struct GraphTraits<DomTreeNode*> {
  typedef DomTreeNode NodeType;
  typedef NodeType::iterator ChildIteratorType;

  static NodeType *getEntryNode(NodeType *N) {
    return N;
  }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return N->begin();
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return N->end();
  }

  typedef df_iterator<DomTreeNode*> nodes_iterator;

  static nodes_iterator nodes_begin(DomTreeNode *N) {
    return df_begin(getEntryNode(N));
  }

  static nodes_iterator nodes_end(DomTreeNode *N) {
    return df_end(getEntryNode(N));
  }
};

template <> struct GraphTraits<DominatorTree*>
  : public GraphTraits<DomTreeNode*> {
  static NodeType *getEntryNode(DominatorTree *DT) {
    return DT->getRootNode();
  }

  static nodes_iterator nodes_begin(DominatorTree *N) {
    return df_begin(getEntryNode(N));
  }

  static nodes_iterator nodes_end(DominatorTree *N) {
    return df_end(getEntryNode(N));
  }
};






class DominanceFrontierBase : public FunctionPass {
public:
  typedef std::set<BasicBlock*> DomSetType;
  typedef std::map<BasicBlock*, DomSetType> DomSetMapType;
protected:
  DomSetMapType Frontiers;
  std::vector<BasicBlock*> Roots;
  const bool IsPostDominators;

public:
  DominanceFrontierBase(void *ID, bool isPostDom)
    : FunctionPass(ID), IsPostDominators(isPostDom) {}





  inline const std::vector<BasicBlock*> &getRoots() const { return Roots; }



  bool isPostDominator() const { return IsPostDominators; }

  virtual void releaseMemory() { Frontiers.clear(); }


  typedef DomSetMapType::iterator iterator;
  typedef DomSetMapType::const_iterator const_iterator;
  iterator begin() { return Frontiers.begin(); }
  const_iterator begin() const { return Frontiers.begin(); }
  iterator end() { return Frontiers.end(); }
  const_iterator end() const { return Frontiers.end(); }
  iterator find(BasicBlock *B) { return Frontiers.find(B); }
  const_iterator find(BasicBlock *B) const { return Frontiers.find(B); }

  iterator addBasicBlock(BasicBlock *BB, const DomSetType &frontier) {
    ((find(BB) == end() && "Block already in DominanceFrontier!") ? static_cast<void> (0) : __assert_fail ("find(BB) == end() && \"Block already in DominanceFrontier!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 915, __PRETTY_FUNCTION__));
    return Frontiers.insert(std::make_pair(BB, frontier)).first;
  }


  void removeBlock(BasicBlock *BB) {
    ((find(BB) != end() && "Block is not in DominanceFrontier!") ? static_cast<void> (0) : __assert_fail ("find(BB) != end() && \"Block is not in DominanceFrontier!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 921, __PRETTY_FUNCTION__));
    for (iterator I = begin(), E = end(); I != E; ++I)
      I->second.erase(BB);
    Frontiers.erase(BB);
  }

  void addToFrontier(iterator I, BasicBlock *Node) {
    ((I != end() && "BB is not in DominanceFrontier!") ? static_cast<void> (0) : __assert_fail ("I != end() && \"BB is not in DominanceFrontier!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 928, __PRETTY_FUNCTION__));
    I->second.insert(Node);
  }

  void removeFromFrontier(iterator I, BasicBlock *Node) {
    ((I != end() && "BB is not in DominanceFrontier!") ? static_cast<void> (0) : __assert_fail ("I != end() && \"BB is not in DominanceFrontier!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 933, __PRETTY_FUNCTION__));
    ((I->second.count(Node) && "Node is not in DominanceFrontier of BB") ? static_cast<void> (0) : __assert_fail ("I->second.count(Node) && \"Node is not in DominanceFrontier of BB\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 934, __PRETTY_FUNCTION__));
    I->second.erase(Node);
  }



  bool compareDomSet(DomSetType &DS1, const DomSetType &DS2) const {
    std::set<BasicBlock *> tmpSet;
    for (DomSetType::const_iterator I = DS2.begin(),
           E = DS2.end(); I != E; ++I)
      tmpSet.insert(*I);

    for (DomSetType::const_iterator I = DS1.begin(),
           E = DS1.end(); I != E; ) {
      BasicBlock *Node = *I++;

      if (tmpSet.erase(Node) == 0)

        return true;
    }

    if(!tmpSet.empty())

      return true;


    return false;
  }



  bool compare(DominanceFrontierBase &Other) const {
    DomSetMapType tmpFrontiers;
    for (DomSetMapType::const_iterator I = Other.begin(),
           E = Other.end(); I != E; ++I)
      tmpFrontiers.insert(std::make_pair(I->first, I->second));

    for (DomSetMapType::iterator I = tmpFrontiers.begin(),
           E = tmpFrontiers.end(); I != E; ) {
      BasicBlock *Node = I->first;
      const_iterator DFI = find(Node);
      if (DFI == end())
        return true;

      if (compareDomSet(I->second, DFI->second))
        return true;

      ++I;
      tmpFrontiers.erase(Node);
    }

    if (!tmpFrontiers.empty())
      return true;

    return false;
  }



  virtual void print(raw_ostream &OS, const Module* = 0) const;
};






class DominanceFrontier : public DominanceFrontierBase {
public:
  static char ID;
  DominanceFrontier() :
    DominanceFrontierBase(&ID, false) {}

  BasicBlock *getRoot() const {
    ((Roots.size() == 1 && "Should always have entry node!") ? static_cast<void> (0) : __assert_fail ("Roots.size() == 1 && \"Should always have entry node!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 1008, __PRETTY_FUNCTION__));
    return Roots[0];
  }

  virtual bool runOnFunction(Function &) {
    Frontiers.clear();
    DominatorTree &DT = getAnalysis<DominatorTree>();
    Roots = DT.getRoots();
    ((Roots.size() == 1 && "Only one entry block for forward domfronts!") ? static_cast<void> (0) : __assert_fail ("Roots.size() == 1 && \"Only one entry block for forward domfronts!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/Dominators.h", 1016, __PRETTY_FUNCTION__));
    calculate(DT, DT[Roots[0]]);
    return false;
  }

  virtual void verifyAnalysis() const;

  virtual void getAnalysisUsage(AnalysisUsage &AU) const {
    AU.setPreservesAll();
    AU.addRequired<DominatorTree>();
  }



  void splitBlock(BasicBlock *BB);



  void changeImmediateDominator(BasicBlock *BB, BasicBlock *NewBB,
                                DominatorTree *DT) {



    DominanceFrontier::iterator NewDFI = find(NewBB);
    DominanceFrontier::iterator DFI = find(BB);

    if (DFI == end())
      return;
    DominanceFrontier::DomSetType BBSet = DFI->second;
    for (DominanceFrontier::DomSetType::iterator BBSetI = BBSet.begin(),
           BBSetE = BBSet.end(); BBSetI != BBSetE; ++BBSetI) {
      BasicBlock *DFMember = *BBSetI;

      if (!DT->dominates(NewBB, DFMember))
        NewDFI->second.insert(DFMember);
    }
    NewDFI->second.erase(BB);
  }

  const DomSetType &calculate(const DominatorTree &DT,
                              const DomTreeNode *Node);
};


}
# 39 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h" 2




namespace llvm {

template<typename T>
static void RemoveFromVector(std::vector<T*> &V, T *N) {
  typename std::vector<T*>::iterator I = std::find(V.begin(), V.end(), N);
  ((I != V.end() && "N is not in this list!") ? static_cast<void> (0) : __assert_fail ("I != V.end() && \"N is not in this list!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 48, __PRETTY_FUNCTION__));
  V.erase(I);
}

class DominatorTree;
class LoopInfo;
class Loop;
template<class N, class M> class LoopInfoBase;
template<class N, class M> class LoopBase;





template<class BlockT, class LoopT>
class LoopBase {
  LoopT *ParentLoop;

  std::vector<LoopT *> SubLoops;


  std::vector<BlockT*> Blocks;


  LoopBase(const LoopBase<BlockT, LoopT> &);

  const LoopBase<BlockT, LoopT>&operator=(const LoopBase<BlockT, LoopT> &);
public:

  LoopBase() : ParentLoop(0) {}
  ~LoopBase() {
    for (size_t i = 0, e = SubLoops.size(); i != e; ++i)
      delete SubLoops[i];
  }




  unsigned getLoopDepth() const {
    unsigned D = 1;
    for (const LoopT *CurLoop = ParentLoop; CurLoop;
         CurLoop = CurLoop->ParentLoop)
      ++D;
    return D;
  }
  BlockT *getHeader() const { return Blocks.front(); }
  LoopT *getParentLoop() const { return ParentLoop; }




  bool contains(const LoopT *L) const {
    if (L == this) return true;
    if (L == 0) return false;
    return contains(L->getParentLoop());
  }



  bool contains(const BlockT *BB) const {
    return std::find(block_begin(), block_end(), BB) != block_end();
  }



  template<class InstT>
  bool contains(const InstT *Inst) const {
    return contains(Inst->getParent());
  }



  const std::vector<LoopT *> &getSubLoops() const { return SubLoops; }
  typedef typename std::vector<LoopT *>::const_iterator iterator;
  iterator begin() const { return SubLoops.begin(); }
  iterator end() const { return SubLoops.end(); }
  bool empty() const { return SubLoops.empty(); }



  const std::vector<BlockT*> &getBlocks() const { return Blocks; }
  typedef typename std::vector<BlockT*>::const_iterator block_iterator;
  block_iterator block_begin() const { return Blocks.begin(); }
  block_iterator block_end() const { return Blocks.end(); }




  bool isLoopExiting(const BlockT *BB) const {
    typedef GraphTraits<BlockT*> BlockTraits;
    for (typename BlockTraits::ChildIteratorType SI =
         BlockTraits::child_begin(const_cast<BlockT*>(BB)),
         SE = BlockTraits::child_end(const_cast<BlockT*>(BB)); SI != SE; ++SI) {
      if (!contains(*SI))
        return true;
    }
    return false;
  }



  unsigned getNumBackEdges() const {
    unsigned NumBackEdges = 0;
    BlockT *H = getHeader();

    typedef GraphTraits<Inverse<BlockT*> > InvBlockTraits;
    for (typename InvBlockTraits::ChildIteratorType I =
         InvBlockTraits::child_begin(const_cast<BlockT*>(H)),
         E = InvBlockTraits::child_end(const_cast<BlockT*>(H)); I != E; ++I)
      if (contains(*I))
        ++NumBackEdges;

    return NumBackEdges;
  }
# 175 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h"
  void getExitingBlocks(SmallVectorImpl<BlockT *> &ExitingBlocks) const {


    SmallVector<BlockT*, 128> LoopBBs(block_begin(), block_end());
    std::sort(LoopBBs.begin(), LoopBBs.end());

    typedef GraphTraits<BlockT*> BlockTraits;
    for (block_iterator BI = block_begin(), BE = block_end(); BI != BE; ++BI)
      for (typename BlockTraits::ChildIteratorType I =
          BlockTraits::child_begin(*BI), E = BlockTraits::child_end(*BI);
          I != E; ++I)
        if (!std::binary_search(LoopBBs.begin(), LoopBBs.end(), *I)) {

          ExitingBlocks.push_back(*BI);
          break;
        }
  }



  BlockT *getExitingBlock() const {
    SmallVector<BlockT*, 8> ExitingBlocks;
    getExitingBlocks(ExitingBlocks);
    if (ExitingBlocks.size() == 1)
      return ExitingBlocks[0];
    return 0;
  }




  void getExitBlocks(SmallVectorImpl<BlockT*> &ExitBlocks) const {


    SmallVector<BlockT*, 128> LoopBBs(block_begin(), block_end());
    std::sort(LoopBBs.begin(), LoopBBs.end());

    typedef GraphTraits<BlockT*> BlockTraits;
    for (block_iterator BI = block_begin(), BE = block_end(); BI != BE; ++BI)
      for (typename BlockTraits::ChildIteratorType I =
           BlockTraits::child_begin(*BI), E = BlockTraits::child_end(*BI);
           I != E; ++I)
        if (!std::binary_search(LoopBBs.begin(), LoopBBs.end(), *I))

          ExitBlocks.push_back(*I);
  }



  BlockT *getExitBlock() const {
    SmallVector<BlockT*, 8> ExitBlocks;
    getExitBlocks(ExitBlocks);
    if (ExitBlocks.size() == 1)
      return ExitBlocks[0];
    return 0;
  }


  typedef std::pair<const BlockT*,const BlockT*> Edge;
  void getExitEdges(SmallVectorImpl<Edge> &ExitEdges) const {


    SmallVector<BlockT*, 128> LoopBBs(block_begin(), block_end());
    std::sort(LoopBBs.begin(), LoopBBs.end());

    typedef GraphTraits<BlockT*> BlockTraits;
    for (block_iterator BI = block_begin(), BE = block_end(); BI != BE; ++BI)
      for (typename BlockTraits::ChildIteratorType I =
           BlockTraits::child_begin(*BI), E = BlockTraits::child_end(*BI);
           I != E; ++I)
        if (!std::binary_search(LoopBBs.begin(), LoopBBs.end(), *I))

          ExitEdges.push_back(std::make_pair(*BI, *I));
  }
# 257 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h"
  BlockT *getLoopPreheader() const {

    BlockT *Out = 0;


    BlockT *Header = getHeader();
    typedef GraphTraits<BlockT*> BlockTraits;
    typedef GraphTraits<Inverse<BlockT*> > InvBlockTraits;
    for (typename InvBlockTraits::ChildIteratorType PI =
         InvBlockTraits::child_begin(Header),
         PE = InvBlockTraits::child_end(Header); PI != PE; ++PI)
      if (!contains(*PI)) {
        if (Out && Out != *PI)
          return 0;
        Out = *PI;
      }


    ((Out && "Header of loop has no predecessors from outside loop?") ? static_cast<void> (0) : __assert_fail ("Out && \"Header of loop has no predecessors from outside loop?\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 275, __PRETTY_FUNCTION__));
    typename BlockTraits::ChildIteratorType SI = BlockTraits::child_begin(Out);
    ++SI;
    if (SI != BlockTraits::child_end(Out))
      return 0;



    return Out;
  }



  BlockT *getLoopLatch() const {
    BlockT *Header = getHeader();
    typedef GraphTraits<Inverse<BlockT*> > InvBlockTraits;
    typename InvBlockTraits::ChildIteratorType PI =
                                            InvBlockTraits::child_begin(Header);
    typename InvBlockTraits::ChildIteratorType PE =
                                              InvBlockTraits::child_end(Header);
    BlockT *Latch = 0;
    for (; PI != PE; ++PI)
      if (contains(*PI)) {
        if (Latch) return 0;
        Latch = *PI;
      }

    return Latch;
  }
# 315 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h"
  void addBasicBlockToLoop(BlockT *NewBB, LoopInfoBase<BlockT, LoopT> &LI);





  void replaceChildLoopWith(LoopT *OldChild,
                            LoopT *NewChild) {
    ((OldChild->ParentLoop == this && "This loop is already broken!") ? static_cast<void> (0) : __assert_fail ("OldChild->ParentLoop == this && \"This loop is already broken!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 323, __PRETTY_FUNCTION__));
    ((NewChild->ParentLoop == 0 && "NewChild already has a parent!") ? static_cast<void> (0) : __assert_fail ("NewChild->ParentLoop == 0 && \"NewChild already has a parent!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 324, __PRETTY_FUNCTION__));
    typename std::vector<LoopT *>::iterator I =
                          std::find(SubLoops.begin(), SubLoops.end(), OldChild);
    ((I != SubLoops.end() && "OldChild not in loop!") ? static_cast<void> (0) : __assert_fail ("I != SubLoops.end() && \"OldChild not in loop!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 327, __PRETTY_FUNCTION__));
    *I = NewChild;
    OldChild->ParentLoop = 0;
    NewChild->ParentLoop = static_cast<LoopT *>(this);
  }




  void addChildLoop(LoopT *NewChild) {
    ((NewChild->ParentLoop == 0 && "NewChild already has a parent!") ? static_cast<void> (0) : __assert_fail ("NewChild->ParentLoop == 0 && \"NewChild already has a parent!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 337, __PRETTY_FUNCTION__));
    NewChild->ParentLoop = static_cast<LoopT *>(this);
    SubLoops.push_back(NewChild);
  }




  LoopT *removeChildLoop(iterator I) {
    ((I != SubLoops.end() && "Cannot remove end iterator!") ? static_cast<void> (0) : __assert_fail ("I != SubLoops.end() && \"Cannot remove end iterator!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 346, __PRETTY_FUNCTION__));
    LoopT *Child = *I;
    ((Child->ParentLoop == this && "Child is not a child of this loop!") ? static_cast<void> (0) : __assert_fail ("Child->ParentLoop == this && \"Child is not a child of this loop!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 348, __PRETTY_FUNCTION__));
    SubLoops.erase(SubLoops.begin()+(I-begin()));
    Child->ParentLoop = 0;
    return Child;
  }




  void addBlockEntry(BlockT *BB) {
    Blocks.push_back(BB);
  }




  void moveToHeader(BlockT *BB) {
    if (Blocks[0] == BB) return;
    for (unsigned i = 0; ; ++i) {
      ((i != Blocks.size() && "Loop does not contain BB!") ? static_cast<void> (0) : __assert_fail ("i != Blocks.size() && \"Loop does not contain BB!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 367, __PRETTY_FUNCTION__));
      if (Blocks[i] == BB) {
        Blocks[i] = Blocks[0];
        Blocks[0] = BB;
        return;
      }
    }
  }




  void removeBlockFromLoop(BlockT *BB) {
    RemoveFromVector(Blocks, BB);
  }


  void verifyLoop() const {

    ((!Blocks.empty() && "Loop header is missing") ? static_cast<void> (0) : __assert_fail ("!Blocks.empty() && \"Loop header is missing\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 386, __PRETTY_FUNCTION__));



    SmallVector<BlockT*, 128> LoopBBs(block_begin(), block_end());
    std::sort(LoopBBs.begin(), LoopBBs.end());


    for (block_iterator I = block_begin(), E = block_end(); I != E; ++I) {
      BlockT *BB = *I;
      bool HasInsideLoopSuccs = false;
      bool HasInsideLoopPreds = false;
      SmallVector<BlockT *, 2> OutsideLoopPreds;

      typedef GraphTraits<BlockT*> BlockTraits;
      for (typename BlockTraits::ChildIteratorType SI =
           BlockTraits::child_begin(BB), SE = BlockTraits::child_end(BB);
           SI != SE; ++SI)
        if (std::binary_search(LoopBBs.begin(), LoopBBs.end(), *SI)) {
          HasInsideLoopSuccs = true;
          break;
        }
      typedef GraphTraits<Inverse<BlockT*> > InvBlockTraits;
      for (typename InvBlockTraits::ChildIteratorType PI =
           InvBlockTraits::child_begin(BB), PE = InvBlockTraits::child_end(BB);
           PI != PE; ++PI) {
        if (std::binary_search(LoopBBs.begin(), LoopBBs.end(), *PI))
          HasInsideLoopPreds = true;
        else
          OutsideLoopPreds.push_back(*PI);
      }

      if (BB == getHeader()) {
        ((!OutsideLoopPreds.empty() && "Loop is unreachable!") ? static_cast<void> (0) : __assert_fail ("!OutsideLoopPreds.empty() && \"Loop is unreachable!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 419, __PRETTY_FUNCTION__));
      } else if (!OutsideLoopPreds.empty()) {



        BlockT *EntryBB = BB->getParent()->begin();
        for (df_iterator<BlockT *> NI = df_begin(EntryBB),
             NE = df_end(EntryBB); NI != NE; ++NI)
          for (unsigned i = 0, e = OutsideLoopPreds.size(); i != e; ++i)
            ((*NI != OutsideLoopPreds[i] && "Loop has multiple entry points!") ? static_cast<void> (0) : __assert_fail ("*NI != OutsideLoopPreds[i] && \"Loop has multiple entry points!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 429, __PRETTY_FUNCTION__));

      }
      ((HasInsideLoopPreds && "Loop block has no in-loop predecessors!") ? static_cast<void> (0) : __assert_fail ("HasInsideLoopPreds && \"Loop block has no in-loop predecessors!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 431, __PRETTY_FUNCTION__));
      ((HasInsideLoopSuccs && "Loop block has no in-loop successors!") ? static_cast<void> (0) : __assert_fail ("HasInsideLoopSuccs && \"Loop block has no in-loop successors!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 432, __PRETTY_FUNCTION__));
      ((BB != getHeader()->getParent()->begin() && "Loop contains function entry block!") ? static_cast<void> (0) : __assert_fail ("BB != getHeader()->getParent()->begin() && \"Loop contains function entry block!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 434, __PRETTY_FUNCTION__));

    }


    for (iterator I = begin(), E = end(); I != E; ++I)

      for (block_iterator BI = (*I)->block_begin(), BE = (*I)->block_end();
           BI != BE; ++BI) {
        ((std::binary_search(LoopBBs.begin(), LoopBBs.end(), *BI) && "Loop does not contain all the blocks of a subloop!") ? static_cast<void> (0) : __assert_fail ("std::binary_search(LoopBBs.begin(), LoopBBs.end(), *BI) && \"Loop does not contain all the blocks of a subloop!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 443, __PRETTY_FUNCTION__));

      }


    if (ParentLoop) {
      ((std::find(ParentLoop->begin(), ParentLoop->end(), this) != ParentLoop->end() && "Loop is not a subloop of its parent!") ? static_cast<void> (0) : __assert_fail ("std::find(ParentLoop->begin(), ParentLoop->end(), this) != ParentLoop->end() && \"Loop is not a subloop of its parent!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 450, __PRETTY_FUNCTION__));


    }

  }


  void verifyLoopNest() const {

    verifyLoop();

    for (iterator I = begin(), E = end(); I != E; ++I)
      (*I)->verifyLoopNest();
  }

  void print(raw_ostream &OS, unsigned Depth = 0) const {
    OS.indent(Depth*2) << "Loop at depth " << getLoopDepth()
       << " containing: ";

    for (unsigned i = 0; i < getBlocks().size(); ++i) {
      if (i) OS << ",";
      BlockT *BB = getBlocks()[i];
      WriteAsOperand(OS, BB, false);
      if (BB == getHeader()) OS << "<header>";
      if (BB == getLoopLatch()) OS << "<latch>";
      if (isLoopExiting(BB)) OS << "<exiting>";
    }
    OS << "\n";

    for (iterator I = begin(), E = end(); I != E; ++I)
      (*I)->print(OS, Depth+2);
  }

protected:
  friend class LoopInfoBase<BlockT, LoopT>;
  explicit LoopBase(BlockT *BB) : ParentLoop(0) {
    Blocks.push_back(BB);
  }
};

class Loop : public LoopBase<BasicBlock, Loop> {
public:
  Loop() {}



  bool isLoopInvariant(Value *V) const;




  bool isLoopInvariant(Instruction *I) const;
# 511 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h"
  bool makeLoopInvariant(Value *V, bool &Changed,
                         Instruction *InsertPt = 0) const;
# 523 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h"
  bool makeLoopInvariant(Instruction *I, bool &Changed,
                         Instruction *InsertPt = 0) const;
# 534 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h"
  PHINode *getCanonicalInductionVariable() const;





  Instruction *getCanonicalInductionVariableIncrement() const;
# 550 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h"
  Value *getTripCount() const;
# 560 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h"
  unsigned getSmallConstantTripCount() const;
# 571 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h"
  unsigned getSmallConstantTripMultiple() const;


  bool isLCSSAForm() const;




  bool isLoopSimplifyForm() const;



  bool hasDedicatedExits() const;





  void getUniqueExitBlocks(SmallVectorImpl<BasicBlock *> &ExitBlocks) const;



  BasicBlock *getUniqueExitBlock() const;

  void dump() const;

private:
  friend class LoopInfoBase<BasicBlock, Loop>;
  explicit Loop(BasicBlock *BB) : LoopBase<BasicBlock, Loop>(BB) {}
};






template<class BlockT, class LoopT>
class LoopInfoBase {

  std::map<BlockT *, LoopT *> BBMap;
  std::vector<LoopT *> TopLevelLoops;
  friend class LoopBase<BlockT, LoopT>;

  void operator=(const LoopInfoBase &);
  LoopInfoBase(const LoopInfo &);
public:
  LoopInfoBase() { }
  ~LoopInfoBase() { releaseMemory(); }

  void releaseMemory() {
    for (typename std::vector<LoopT *>::iterator I =
         TopLevelLoops.begin(), E = TopLevelLoops.end(); I != E; ++I)
      delete *I;

    BBMap.clear();
    TopLevelLoops.clear();
  }




  typedef typename std::vector<LoopT *>::const_iterator iterator;
  iterator begin() const { return TopLevelLoops.begin(); }
  iterator end() const { return TopLevelLoops.end(); }
  bool empty() const { return TopLevelLoops.empty(); }




  LoopT *getLoopFor(const BlockT *BB) const {
    typename std::map<BlockT *, LoopT *>::const_iterator I=
      BBMap.find(const_cast<BlockT*>(BB));
    return I != BBMap.end() ? I->second : 0;
  }



  const LoopT *operator[](const BlockT *BB) const {
    return getLoopFor(BB);
  }




  unsigned getLoopDepth(const BlockT *BB) const {
    const LoopT *L = getLoopFor(BB);
    return L ? L->getLoopDepth() : 0;
  }


  bool isLoopHeader(BlockT *BB) const {
    const LoopT *L = getLoopFor(BB);
    return L && L->getHeader() == BB;
  }




  LoopT *removeLoop(iterator I) {
    ((I != end() && "Cannot remove end iterator!") ? static_cast<void> (0) : __assert_fail ("I != end() && \"Cannot remove end iterator!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 670, __PRETTY_FUNCTION__));
    LoopT *L = *I;
    ((L->getParentLoop() == 0 && "Not a top-level loop!") ? static_cast<void> (0) : __assert_fail ("L->getParentLoop() == 0 && \"Not a top-level loop!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 672, __PRETTY_FUNCTION__));
    TopLevelLoops.erase(TopLevelLoops.begin() + (I-begin()));
    return L;
  }




  void changeLoopFor(BlockT *BB, LoopT *L) {
    LoopT *&OldLoop = BBMap[BB];
    ((OldLoop && "Block not in a loop yet!") ? static_cast<void> (0) : __assert_fail ("OldLoop && \"Block not in a loop yet!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 682, __PRETTY_FUNCTION__));
    OldLoop = L;
  }



  void changeTopLevelLoop(LoopT *OldLoop,
                          LoopT *NewLoop) {
    typename std::vector<LoopT *>::iterator I =
                 std::find(TopLevelLoops.begin(), TopLevelLoops.end(), OldLoop);
    ((I != TopLevelLoops.end() && "Old loop not at top level!") ? static_cast<void> (0) : __assert_fail ("I != TopLevelLoops.end() && \"Old loop not at top level!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 692, __PRETTY_FUNCTION__));
    *I = NewLoop;
    ((NewLoop->ParentLoop == 0 && OldLoop->ParentLoop == 0 && "Loops already embedded into a subloop!") ? static_cast<void> (0) : __assert_fail ("NewLoop->ParentLoop == 0 && OldLoop->ParentLoop == 0 && \"Loops already embedded into a subloop!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 695, __PRETTY_FUNCTION__));

  }



  void addTopLevelLoop(LoopT *New) {
    ((New->getParentLoop() == 0 && "Loop already in subloop!") ? static_cast<void> (0) : __assert_fail ("New->getParentLoop() == 0 && \"Loop already in subloop!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 701, __PRETTY_FUNCTION__));
    TopLevelLoops.push_back(New);
  }




  void removeBlock(BlockT *BB) {
    typename std::map<BlockT *, LoopT *>::iterator I = BBMap.find(BB);
    if (I != BBMap.end()) {
      for (LoopT *L = I->second; L; L = L->getParentLoop())
        L->removeBlockFromLoop(BB);

      BBMap.erase(I);
    }
  }



  static bool isNotAlreadyContainedIn(const LoopT *SubLoop,
                                      const LoopT *ParentLoop) {
    if (SubLoop == 0) return true;
    if (SubLoop == ParentLoop) return false;
    return isNotAlreadyContainedIn(SubLoop->getParentLoop(), ParentLoop);
  }

  void Calculate(DominatorTreeBase<BlockT> &DT) {
    BlockT *RootNode = DT.getRootNode()->getBlock();

    for (df_iterator<BlockT*> NI = df_begin(RootNode),
           NE = df_end(RootNode); NI != NE; ++NI)
      if (LoopT *L = ConsiderForLoop(*NI, DT))
        TopLevelLoops.push_back(L);
  }

  LoopT *ConsiderForLoop(BlockT *BB, DominatorTreeBase<BlockT> &DT) {
    if (BBMap.find(BB) != BBMap.end()) return 0;

    std::vector<BlockT *> TodoStack;



    typedef GraphTraits<Inverse<BlockT*> > InvBlockTraits;
    for (typename InvBlockTraits::ChildIteratorType I =
         InvBlockTraits::child_begin(BB), E = InvBlockTraits::child_end(BB);
         I != E; ++I)
      if (DT.dominates(BB, *I))
        TodoStack.push_back(*I);

    if (TodoStack.empty()) return 0;


    LoopT *L = new LoopT(BB);
    BBMap[BB] = L;

    BlockT *EntryBlock = BB->getParent()->begin();

    while (!TodoStack.empty()) {
      BlockT *X = TodoStack.back();
      TodoStack.pop_back();

      if (!L->contains(X) &&
          DT.dominates(EntryBlock, X)) {






        if (LoopT *SubLoop =
            const_cast<LoopT *>(getLoopFor(X)))
          if (SubLoop->getHeader() == X && isNotAlreadyContainedIn(SubLoop, L)){

            ((SubLoop->ParentLoop && SubLoop->ParentLoop != L) ? static_cast<void> (0) : __assert_fail ("SubLoop->ParentLoop && SubLoop->ParentLoop != L", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 774, __PRETTY_FUNCTION__));
            LoopT *SLP = SubLoop->ParentLoop;
            typename std::vector<LoopT *>::iterator I =
              std::find(SLP->SubLoops.begin(), SLP->SubLoops.end(), SubLoop);
            ((I != SLP->SubLoops.end() &&"SubLoop not a child of parent?") ? static_cast<void> (0) : __assert_fail ("I != SLP->SubLoops.end() &&\"SubLoop not a child of parent?\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 778, __PRETTY_FUNCTION__));
            SLP->SubLoops.erase(I);


            SubLoop->ParentLoop = L;
            L->SubLoops.push_back(SubLoop);
          }


        L->Blocks.push_back(X);

        typedef GraphTraits<Inverse<BlockT*> > InvBlockTraits;


        TodoStack.insert(TodoStack.end(), InvBlockTraits::child_begin(X),
                         InvBlockTraits::child_end(X));
      }
    }


    for (typename std::vector<BlockT*>::iterator I = L->Blocks.begin(),
         E = L->Blocks.end(); I != E; ++I)
      if (LoopT *NewLoop = ConsiderForLoop(*I, DT)) {
        L->SubLoops.push_back(NewLoop);
        NewLoop->ParentLoop = L;
      }




    for (typename std::vector<BlockT*>::iterator I = L->Blocks.begin(),
           E = L->Blocks.end(); I != E; ++I)
      BBMap.insert(std::make_pair(*I, L));





    {
      std::map<BlockT *, LoopT *> ContainingLoops;
      for (unsigned i = 0; i != L->SubLoops.size(); ++i) {
        LoopT *Child = L->SubLoops[i];
        ((Child->getParentLoop() == L && "Not proper child loop?") ? static_cast<void> (0) : __assert_fail ("Child->getParentLoop() == L && \"Not proper child loop?\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 820, __PRETTY_FUNCTION__));

        if (LoopT *ContainingLoop = ContainingLoops[Child->getHeader()]) {


          MoveSiblingLoopInto(Child, ContainingLoop);
          --i;
        } else {



          for (unsigned b = 0, e = Child->Blocks.size(); b != e; ++b) {
            LoopT *&BlockLoop = ContainingLoops[Child->Blocks[b]];
            if (BlockLoop == 0) {
              BlockLoop = Child;
            } else if (BlockLoop != Child) {
              LoopT *SubLoop = BlockLoop;

              for (unsigned j = 0, f = SubLoop->Blocks.size(); j != f; ++j)
                ContainingLoops[SubLoop->Blocks[j]] = Child;




              MoveSiblingLoopInto(SubLoop, Child);
              --i;
            }
          }
        }
      }
    }

    return L;
  }



  void MoveSiblingLoopInto(LoopT *NewChild,
                           LoopT *NewParent) {
    LoopT *OldParent = NewChild->getParentLoop();
    ((OldParent && OldParent == NewParent->getParentLoop() && NewChild != NewParent && "Not sibling loops!") ? static_cast<void> (0) : __assert_fail ("OldParent && OldParent == NewParent->getParentLoop() && NewChild != NewParent && \"Not sibling loops!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 861, __PRETTY_FUNCTION__));



    typename std::vector<LoopT *>::iterator I =
      std::find(OldParent->SubLoops.begin(), OldParent->SubLoops.end(),
                NewChild);
    ((I != OldParent->SubLoops.end() && "Parent fields incorrect??") ? static_cast<void> (0) : __assert_fail ("I != OldParent->SubLoops.end() && \"Parent fields incorrect??\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 867, __PRETTY_FUNCTION__));
    OldParent->SubLoops.erase(I);
    NewChild->ParentLoop = 0;

    InsertLoopInto(NewChild, NewParent);
  }




  void InsertLoopInto(LoopT *L, LoopT *Parent) {
    BlockT *LHeader = L->getHeader();
    ((Parent->contains(LHeader) && "This loop should not be inserted here!") ? static_cast<void> (0) : __assert_fail ("Parent->contains(LHeader) && \"This loop should not be inserted here!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 880, __PRETTY_FUNCTION__));



    for (unsigned i = 0, e = static_cast<unsigned>(Parent->SubLoops.size());
         i != e; ++i)
      if (Parent->SubLoops[i]->contains(LHeader)) {
        InsertLoopInto(L, Parent->SubLoops[i]);
        return;
      }


    Parent->SubLoops.push_back(L);
    L->ParentLoop = Parent;
  }



  void print(raw_ostream &OS) const {
    for (unsigned i = 0; i < TopLevelLoops.size(); ++i)
      TopLevelLoops[i]->print(OS);






  }
};

class LoopInfo : public FunctionPass {
  LoopInfoBase<BasicBlock, Loop> LI;
  friend class LoopBase<BasicBlock, Loop>;

  void operator=(const LoopInfo &);
  LoopInfo(const LoopInfo &);
public:
  static char ID;

  LoopInfo() : FunctionPass(&ID) {}

  LoopInfoBase<BasicBlock, Loop>& getBase() { return LI; }




  typedef LoopInfoBase<BasicBlock, Loop>::iterator iterator;
  inline iterator begin() const { return LI.begin(); }
  inline iterator end() const { return LI.end(); }
  bool empty() const { return LI.empty(); }




  inline Loop *getLoopFor(const BasicBlock *BB) const {
    return LI.getLoopFor(BB);
  }



  inline const Loop *operator[](const BasicBlock *BB) const {
    return LI.getLoopFor(BB);
  }




  inline unsigned getLoopDepth(const BasicBlock *BB) const {
    return LI.getLoopDepth(BB);
  }


  inline bool isLoopHeader(BasicBlock *BB) const {
    return LI.isLoopHeader(BB);
  }



  virtual bool runOnFunction(Function &F);

  virtual void verifyAnalysis() const;

  virtual void releaseMemory() { LI.releaseMemory(); }

  virtual void print(raw_ostream &O, const Module* M = 0) const;

  virtual void getAnalysisUsage(AnalysisUsage &AU) const;




  inline Loop *removeLoop(iterator I) { return LI.removeLoop(I); }




  inline void changeLoopFor(BasicBlock *BB, Loop *L) {
    LI.changeLoopFor(BB, L);
  }



  inline void changeTopLevelLoop(Loop *OldLoop, Loop *NewLoop) {
    LI.changeTopLevelLoop(OldLoop, NewLoop);
  }



  inline void addTopLevelLoop(Loop *New) {
    LI.addTopLevelLoop(New);
  }




  void removeBlock(BasicBlock *BB) {
    LI.removeBlock(BB);
  }
};



template <> struct GraphTraits<const Loop*> {
  typedef const Loop NodeType;
  typedef LoopInfo::iterator ChildIteratorType;

  static NodeType *getEntryNode(const Loop *L) { return L; }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return N->begin();
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return N->end();
  }
};

template <> struct GraphTraits<Loop*> {
  typedef Loop NodeType;
  typedef LoopInfo::iterator ChildIteratorType;

  static NodeType *getEntryNode(Loop *L) { return L; }
  static inline ChildIteratorType child_begin(NodeType *N) {
    return N->begin();
  }
  static inline ChildIteratorType child_end(NodeType *N) {
    return N->end();
  }
};

template<class BlockT, class LoopT>
void
LoopBase<BlockT, LoopT>::addBasicBlockToLoop(BlockT *NewBB,
                                             LoopInfoBase<BlockT, LoopT> &LIB) {
  (((Blocks.empty() || LIB[getHeader()] == this) && "Incorrect LI specified for this loop!") ? static_cast<void> (0) : __assert_fail ("(Blocks.empty() || LIB[getHeader()] == this) && \"Incorrect LI specified for this loop!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 1032, __PRETTY_FUNCTION__));

  ((NewBB && "Cannot add a null basic block to the loop!") ? static_cast<void> (0) : __assert_fail ("NewBB && \"Cannot add a null basic block to the loop!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 1033, __PRETTY_FUNCTION__));
  ((LIB[NewBB] == 0 && "BasicBlock already in the loop!") ? static_cast<void> (0) : __assert_fail ("LIB[NewBB] == 0 && \"BasicBlock already in the loop!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/LoopInfo.h", 1034, __PRETTY_FUNCTION__));

  LoopT *L = static_cast<LoopT *>(this);


  LIB.BBMap[NewBB] = L;


  while (L) {
    L->Blocks.push_back(NewBB);
    L = L->getParentLoop();
  }
}

}
# 20 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/ValueTracking.h" 1
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/ValueTracking.h"
namespace llvm {
  template <typename T> class SmallVectorImpl;
  class Value;
  class Instruction;
  class APInt;
  class TargetData;
# 38 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/ValueTracking.h"
  void ComputeMaskedBits(Value *V, const APInt &Mask, APInt &KnownZero,
                         APInt &KnownOne, const TargetData *TD = 0,
                         unsigned Depth = 0);
# 51 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/ValueTracking.h"
  bool MaskedValueIsZero(Value *V, const APInt &Mask,
                         const TargetData *TD = 0, unsigned Depth = 0);
# 63 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/ValueTracking.h"
  unsigned ComputeNumSignBits(Value *Op, const TargetData *TD = 0,
                              unsigned Depth = 0);






  bool ComputeMultiple(Value *V, unsigned Base, Value *&Multiple,
                       bool LookThroughSExt = false,
                       unsigned Depth = 0);




  bool CannotBeNegativeZero(const Value *V, unsigned Depth = 0);
# 94 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/ValueTracking.h"
  const Value *DecomposeGEPExpression(const Value *V, int64_t &BaseOffs,
                 SmallVectorImpl<std::pair<const Value*, int64_t> > &VarIndices,
                                      const TargetData *TD);
# 106 "/local/monniaux/packages/llvm-2.7/include/llvm/Analysis/ValueTracking.h"
  Value *FindInsertedValue(Value *V,
                           const unsigned *idx_begin,
                           const unsigned *idx_end,
                           Instruction *InsertBefore = 0);



  inline Value *FindInsertedValue(Value *V, const unsigned Idx,
                                  Instruction *InsertBefore = 0) {
    const unsigned Idxs[1] = { Idx };
    return FindInsertedValue(V, &Idxs[0], &Idxs[1], InsertBefore);
  }







  bool GetConstantStringInfo(Value *V, std::string &Str, uint64_t Offset = 0,
                             bool StopAtNul = true);



  uint64_t GetStringLength(Value *V);
}
# 21 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/CodeGen/Passes.h" 1
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/CodeGen/Passes.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetMachine.h" 1
# 17 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetMachine.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetInstrItineraries.h" 1
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetInstrItineraries.h"
namespace llvm {
# 50 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetInstrItineraries.h"
struct InstrStage {
  unsigned Cycles_;
  unsigned Units_;
  int NextCycles_;


  unsigned getCycles() const {
    return Cycles_;
  }


  unsigned getUnits() const {
    return Units_;
  }



  unsigned getNextCycles() const {
    return (NextCycles_ >= 0) ? (unsigned)NextCycles_ : Cycles_;
  }
};
# 79 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetInstrItineraries.h"
struct InstrItinerary {
  unsigned FirstStage;
  unsigned LastStage;
  unsigned FirstOperandCycle;
  unsigned LastOperandCycle;
};






struct InstrItineraryData {
  const InstrStage *Stages;
  const unsigned *OperandCycles;
  const InstrItinerary *Itineratries;



  InstrItineraryData() : Stages(0), OperandCycles(0), Itineratries(0) {}
  InstrItineraryData(const InstrStage *S, const unsigned *OS,
                     const InstrItinerary *I)
    : Stages(S), OperandCycles(OS), Itineratries(I) {}



  bool isEmpty() const { return Itineratries == 0; }




  bool isEndMarker(unsigned ItinClassIndx) const {
    return ((Itineratries[ItinClassIndx].FirstStage == ~0U) &&
            (Itineratries[ItinClassIndx].LastStage == ~0U));
  }



  const InstrStage *beginStage(unsigned ItinClassIndx) const {
    unsigned StageIdx = Itineratries[ItinClassIndx].FirstStage;
    return Stages + StageIdx;
  }



  const InstrStage *endStage(unsigned ItinClassIndx) const {
    unsigned StageIdx = Itineratries[ItinClassIndx].LastStage;
    return Stages + StageIdx;
  }





  unsigned getStageLatency(unsigned ItinClassIndx) const {


    if (isEmpty())
      return 1;


    unsigned Latency = 0, StartCycle = 0;
    for (const InstrStage *IS = beginStage(ItinClassIndx),
           *E = endStage(ItinClassIndx); IS != E; ++IS) {
      Latency = std::max(Latency, StartCycle + IS->getCycles());
      StartCycle += IS->getNextCycles();
    }

    return Latency;
  }




  int getOperandCycle(unsigned ItinClassIndx, unsigned OperandIdx) const {
    if (isEmpty())
      return -1;

    unsigned FirstIdx = Itineratries[ItinClassIndx].FirstOperandCycle;
    unsigned LastIdx = Itineratries[ItinClassIndx].LastOperandCycle;
    if ((FirstIdx + OperandIdx) >= LastIdx)
      return -1;

    return (int)OperandCycles[FirstIdx + OperandIdx];
  }
};


}
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetMachine.h" 2
# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetMachine.h" 2


namespace llvm {

class Target;
class MCAsmInfo;
class TargetData;
class TargetSubtarget;
class TargetInstrInfo;
class TargetIntrinsicInfo;
class TargetJITInfo;
class TargetLowering;
class TargetFrameInfo;
class JITCodeEmitter;
class TargetRegisterInfo;
class PassManagerBase;
class PassManager;
class Pass;
class TargetELFWriterInfo;
class formatted_raw_ostream;


namespace Reloc {
  enum Model {
    Default,
    Static,
    PIC_,
    DynamicNoPIC
  };
}


namespace CodeModel {
  enum Model {
    Default,
    Small,
    Kernel,
    Medium,
    Large
  };
}


namespace CodeGenOpt {
  enum Level {
    None,
    Less,
    Default,
    Aggressive
  };
}







class TargetMachine {
  TargetMachine(const TargetMachine &);
  void operator=(const TargetMachine &);
protected:
  TargetMachine(const Target &);



  virtual const TargetSubtarget *getSubtargetImpl() const { return 0; }


  const Target &TheTarget;



  const MCAsmInfo *AsmInfo;

public:
  virtual ~TargetMachine();

  const Target &getTarget() const { return TheTarget; }







  virtual const TargetInstrInfo *getInstrInfo() const { return 0; }
  virtual const TargetFrameInfo *getFrameInfo() const { return 0; }
  virtual TargetLowering *getTargetLowering() const { return 0; }
  virtual const TargetData *getTargetData() const { return 0; }



  const MCAsmInfo *getMCAsmInfo() const { return AsmInfo; }




  template<typename STC> const STC &getSubtarget() const {
    return *static_cast<const STC*>(getSubtargetImpl());
  }





  virtual const TargetRegisterInfo *getRegisterInfo() const { return 0; }




  virtual const TargetIntrinsicInfo *getIntrinsicInfo() const { return 0; }




  virtual TargetJITInfo *getJITInfo() { return 0; }




  virtual const InstrItineraryData getInstrItineraryData() const {
    return InstrItineraryData();
  }




  virtual const TargetELFWriterInfo *getELFWriterInfo() const { return 0; }



  static Reloc::Model getRelocationModel();



  static void setRelocationModel(Reloc::Model Model);



  static CodeModel::Model getCodeModel();



  static void setCodeModel(CodeModel::Model Model);



  static bool getAsmVerbosityDefault();



  static void setAsmVerbosityDefault(bool);




  enum CodeGenFileType {
    CGFT_AssemblyFile,
    CGFT_ObjectFile,
    CGFT_Null
  };



  virtual bool getEnableTailMergeDefault() const { return true; }





  virtual bool addPassesToEmitFile(PassManagerBase &,
                                   formatted_raw_ostream &,
                                   CodeGenFileType,
                                   CodeGenOpt::Level,
                                   bool DisableVerify = true) {
    return true;
  }







  virtual bool addPassesToEmitMachineCode(PassManagerBase &,
                                          JITCodeEmitter &,
                                          CodeGenOpt::Level,
                                          bool DisableVerify = true) {
    return true;
  }




  virtual bool WantsWholeFile() const { return false; }
  virtual bool addPassesToEmitWholeFile(PassManager &, formatted_raw_ostream &,
                                        CodeGenFileType,
                                        CodeGenOpt::Level,
                                        bool DisableVerify = true) {
    return true;
  }
};




class LLVMTargetMachine : public TargetMachine {
protected:
  LLVMTargetMachine(const Target &T, const std::string &TargetTriple);




  bool addCommonCodeGenPasses(PassManagerBase &, CodeGenOpt::Level,
                              bool DisableVerify);

private:
  virtual void setCodeModelForJIT();
  virtual void setCodeModelForStatic();

public:





  virtual bool addPassesToEmitFile(PassManagerBase &PM,
                                   formatted_raw_ostream &Out,
                                   CodeGenFileType FileType,
                                   CodeGenOpt::Level,
                                   bool DisableVerify = true);







  virtual bool addPassesToEmitMachineCode(PassManagerBase &PM,
                                          JITCodeEmitter &MCE,
                                          CodeGenOpt::Level,
                                          bool DisableVerify = true);






  virtual bool addInstSelector(PassManagerBase &, CodeGenOpt::Level) {
    return true;
  }




  virtual bool addPreRegAlloc(PassManagerBase &, CodeGenOpt::Level) {
    return false;
  }





  virtual bool addPostRegAlloc(PassManagerBase &, CodeGenOpt::Level) {
    return false;
  }





  virtual bool addPreSched2(PassManagerBase &, CodeGenOpt::Level) {
    return false;
  }




  virtual bool addPreEmitPass(PassManagerBase &, CodeGenOpt::Level) {
    return false;
  }





  virtual bool addCodeEmitter(PassManagerBase &, CodeGenOpt::Level,
                              JITCodeEmitter &) {
    return true;
  }



  virtual bool getEnableTailMergeDefault() const { return true; }
};

}
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/CodeGen/Passes.h" 2


namespace llvm {

  class FunctionPass;
  class PassInfo;
  class TargetLowering;
  class RegisterCoalescer;
  class raw_ostream;







  FunctionPass *createUnreachableBlockEliminationPass();



  FunctionPass *createMachineFunctionPrinterPass(raw_ostream &OS,
                                                 const std::string &Banner ="");



  extern const PassInfo *const MachineLoopInfoID;



  extern const PassInfo *const MachineDominatorsID;






  extern const PassInfo *const PHIEliminationID;







  extern const PassInfo *const StrongPHIEliminationID;

  extern const PassInfo *const PreAllocSplittingID;




  extern const PassInfo *const SimpleRegisterCoalescingID;




  extern const PassInfo *const TwoAddressInstructionPassID;



  extern const PassInfo *const UnreachableMachineBlockElimID;




  FunctionPass *createDeadMachineInstructionElimPass();



  FunctionPass *createRegisterAllocator();





  FunctionPass *createLocalRegisterAllocator();




  FunctionPass *createLinearScanRegisterAllocator();




  FunctionPass *createPBQPRegisterAllocator();




  RegisterCoalescer *createSimpleRegisterCoalescer();




  FunctionPass *createPrologEpilogCodeInserter();





  FunctionPass *createLowerSubregsPass();



  FunctionPass *createPostRAScheduler(CodeGenOpt::Level OptLevel);





  FunctionPass *createBranchFoldingPass(bool DefaultEnableTailMerge);



  FunctionPass *createTailDuplicatePass(bool PreRegAlloc = false);


  FunctionPass *createIfConverterPass();



  FunctionPass *createCodePlacementOptPass();



  FunctionPass *getRegisterAllocator(TargetMachine &T);



  FunctionPass *createGCLoweringPass();





  FunctionPass *createGCMachineCodeAnalysisPass();



  FunctionPass *createGCInfoDeleter();



  FunctionPass *createGCInfoPrinter(raw_ostream &OS);



  FunctionPass *createMachineCSEPass();



  FunctionPass *createMachineLICMPass();



  FunctionPass *createMachineSinkingPass();



  FunctionPass *createOptimizeExtsPass();



  FunctionPass *createOptimizePHIsPass();


  FunctionPass *createStackSlotColoringPass(bool);


  FunctionPass *createStackProtectorPass(const TargetLowering *tli);






  FunctionPass *createMachineVerifierPass(bool allowDoubleDefs);



  FunctionPass *createDwarfEHPass(const TargetLowering *tli, bool fast);



  FunctionPass *createSjLjEHPass(const TargetLowering *tli);

}
# 22 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/CodeGen/IntrinsicLowering.h" 1
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/CodeGen/IntrinsicLowering.h"
namespace llvm {
  class CallInst;
  class Module;
  class TargetData;

  class IntrinsicLowering {
    const TargetData& TD;


    bool Warned;
  public:
    explicit IntrinsicLowering(const TargetData &td) :
      TD(td), Warned(false) {}




    void AddPrototypes(Module &M);
# 50 "/local/monniaux/packages/llvm-2.7/include/llvm/CodeGen/IntrinsicLowering.h"
    void LowerIntrinsicCall(CallInst *CI);
  };
}
# 23 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Transforms/Scalar.h" 1
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/Transforms/Scalar.h"
namespace llvm {

class FunctionPass;
class Pass;
class GetElementPtrInst;
class PassInfo;
class TerminatorInst;
class TargetLowering;





FunctionPass *createConstantPropagationPass();





FunctionPass *createSCCPPass();







Pass *createDeadInstEliminationPass();
# 54 "/local/monniaux/packages/llvm-2.7/include/llvm/Transforms/Scalar.h"
FunctionPass *createDeadCodeEliminationPass();






FunctionPass *createDeadStoreEliminationPass();







FunctionPass *createAggressiveDCEPass();






FunctionPass *createScalarReplAggregatesPass(signed Threshold = -1);






Pass *createIndVarSimplifyPass();
# 97 "/local/monniaux/packages/llvm-2.7/include/llvm/Transforms/Scalar.h"
FunctionPass *createInstructionCombiningPass();





Pass *createLICMPass();
# 112 "/local/monniaux/packages/llvm-2.7/include/llvm/Transforms/Scalar.h"
Pass *createLoopStrengthReducePass(const TargetLowering *TLI = 0);





Pass *createLoopUnswitchPass(bool OptimizeForSize = false);





Pass *createLoopUnrollPass();





Pass *createLoopRotatePass();






Pass *createLoopIndexSplitPass();
# 151 "/local/monniaux/packages/llvm-2.7/include/llvm/Transforms/Scalar.h"
FunctionPass *createPromoteMemoryToRegisterPass();
extern const PassInfo *const PromoteMemoryToRegisterID;







FunctionPass *createDemoteRegisterToMemoryPass();
extern const PassInfo *const DemoteRegisterToMemoryID;
# 170 "/local/monniaux/packages/llvm-2.7/include/llvm/Transforms/Scalar.h"
FunctionPass *createReassociatePass();






FunctionPass *createTailDuplicationPass();






FunctionPass *createJumpThreadingPass();






FunctionPass *createCFGSimplificationPass();
# 204 "/local/monniaux/packages/llvm-2.7/include/llvm/Transforms/Scalar.h"
FunctionPass *createBreakCriticalEdgesPass();
extern const PassInfo *const BreakCriticalEdgesID;
# 215 "/local/monniaux/packages/llvm-2.7/include/llvm/Transforms/Scalar.h"
Pass *createLoopSimplifyPass();
extern const PassInfo *const LoopSimplifyID;






FunctionPass *createTailCallEliminationPass();






FunctionPass *createLowerSwitchPass();
extern const PassInfo *const LowerSwitchID;
# 243 "/local/monniaux/packages/llvm-2.7/include/llvm/Transforms/Scalar.h"
FunctionPass *createLowerInvokePass(const TargetLowering *TLI = 0);
extern const PassInfo *const LowerInvokePassID;






FunctionPass *createBlockPlacementPass();






Pass *createLCSSAPass();
extern const PassInfo *const LCSSAID;






FunctionPass *createGVNPass(bool NoLoads = false);






FunctionPass *createMemCpyOptPass();






Pass *createLoopDeletionPass();





FunctionPass *createSimplifyLibCallsPass();





FunctionPass *createSimplifyHalfPowrLibCallsPass();





FunctionPass *createCodeGenPreparePass(const TargetLowering *TLI = 0);





FunctionPass *createInstructionNamerPass();
extern const PassInfo *const InstructionNamerID;






FunctionPass *createSSIPass();






FunctionPass *createSSIEverythingPass();





FunctionPass *createGEPSplitterPass();





FunctionPass *createSCCVNPass();





FunctionPass *createABCDPass();

}
# 24 "SMTBackend.cc" 2
# 1 "/usr/include/llvm/Target/TargetAsmInfo.h" 1 3 4
# 19 "/usr/include/llvm/Target/TargetAsmInfo.h" 3 4
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/CodeGen/MachineFunctionPass.h" 1 3 4
# 24 "/local/monniaux/packages/llvm-2.7/include/llvm/CodeGen/MachineFunctionPass.h" 3 4
namespace llvm {

class MachineFunction;





class MachineFunctionPass : public FunctionPass {
protected:
  explicit MachineFunctionPass(intptr_t ID) : FunctionPass(ID) {}
  explicit MachineFunctionPass(void *ID) : FunctionPass(ID) {}




  virtual bool runOnMachineFunction(MachineFunction &MF) = 0;







  virtual void getAnalysisUsage(AnalysisUsage &AU) const;

private:
  bool runOnFunction(Function &F);
};

}
# 20 "/usr/include/llvm/Target/TargetAsmInfo.h" 2 3 4
# 1 "/usr/include/llvm/Support/DataTypes.h" 1 3 4
# 21 "/usr/include/llvm/Target/TargetAsmInfo.h" 2 3 4

namespace llvm {
  class TargetMachine;
  class CallInst;



  class TargetAsmInfo {
  protected:






    const char *TextSection;



    const char *DataSection;




    const char *BSSSection;



    const char *TLSDataSection;




    const char *TLSBSSSection;


    const char *ZeroFillDirective;



    bool NeedsSet;



    unsigned MaxInstLength;



    const char *PCSymbol;




    char SeparatorChar;



    const char *CommentString;



    const char *GlobalPrefix;




    const char *PrivateGlobalPrefix;



    const char *JumpTableSpecialLabelPrefix;




    const char *GlobalVarAddrPrefix;
    const char *GlobalVarAddrSuffix;
# 106 "/usr/include/llvm/Target/TargetAsmInfo.h" 3 4
    const char *FunctionAddrPrefix;
    const char *FunctionAddrSuffix;




    const char *PersonalityPrefix;
    const char *PersonalitySuffix;




    bool NeedsIndirectEncoding;



    const char *InlineAsmStart;
    const char *InlineAsmEnd;


    unsigned AssemblerDialect;







    const char *ZeroDirective;
    const char *ZeroDirectiveSuffix;



    const char *AsciiDirective;




    const char *AscizDirective;




    const char *Data8bitsDirective;
    const char *Data16bitsDirective;
    const char *Data32bitsDirective;
    const char *Data64bitsDirective;






    const char *AlignDirective;





    bool AlignmentIsInBytes;






    const char *SwitchToSectionDirective;



    const char *TextSectionStartSuffix;



    const char *DataSectionStartSuffix;



    const char *SectionEndDirectiveSuffix;



    const char *ConstantPoolSection;




    const char *JumpTableDataSection;



    const char *JumpTableDirective;





    const char *CStringSection;




    const char *StaticCtorsSection;




    const char *StaticDtorsSection;




    const char *FourByteConstantSection;
    const char *EightByteConstantSection;
    const char *SixteenByteConstantSection;




    const char *ReadOnlySection;





    const char *GlobalDirective;



    const char *SetDirective;






    const char *LCOMMDirective;

    const char *COMMDirective;



    bool COMMDirectiveTakesAlignment;



    bool HasDotTypeDotSizeDirective;




    const char *UsedDirective;



    const char *WeakRefDirective;



    const char *WeakDefDirective;



    const char *HiddenDirective;



    const char *ProtectedDirective;





    bool AbsoluteDebugSectionOffsets;



    bool AbsoluteEHSectionOffsets;



    bool HasLEB128;




    bool HasDotLocAndDotFile;



    bool SupportsDebugInformation;




    bool SupportsExceptionHandling;



    bool DwarfRequiresFrameSection;




    const char *GlobalEHDirective;



    bool SupportsWeakOmittedEHFrame;



    bool ShortenEHDataOn64Bit;


    const char* DwarfSectionOffsetDirective;



    const char *DwarfAbbrevSection;



    const char *DwarfInfoSection;



    const char *DwarfLineSection;



    const char *DwarfFrameSection;



    const char *DwarfPubNamesSection;



    const char *DwarfPubTypesSection;



    const char *DwarfStrSection;



    const char *DwarfLocSection;



    const char *DwarfARangesSection;



    const char *DwarfRangesSection;



    const char *DwarfMacInfoSection;



    const char *DwarfEHFrameSection;



    const char *DwarfExceptionSection;




    const char** AsmTransCBE;

  public:
    TargetAsmInfo();
    virtual ~TargetAsmInfo();



    virtual unsigned getInlineAsmLength(const char *Str) const;





    virtual bool ExpandInlineAsm(CallInst *CI) const {
      return false;
    }



    const char *getTextSection() const {
      return TextSection;
    }
    const char *getDataSection() const {
      return DataSection;
    }
    const char *getBSSSection() const {
      return BSSSection;
    }
    const char *getTLSDataSection() const {
      return TLSDataSection;
    }
    const char *getTLSBSSSection() const {
      return TLSBSSSection;
    }
    const char *getZeroFillDirective() const {
      return ZeroFillDirective;
    }
    bool needsSet() const {
      return NeedsSet;
    }
    const char *getPCSymbol() const {
      return PCSymbol;
    }
    char getSeparatorChar() const {
      return SeparatorChar;
    }
    const char *getCommentString() const {
      return CommentString;
    }
    const char *getGlobalPrefix() const {
      return GlobalPrefix;
    }
    const char *getPrivateGlobalPrefix() const {
      return PrivateGlobalPrefix;
    }
    const char *getJumpTableSpecialLabelPrefix() const {
      return JumpTableSpecialLabelPrefix;
    }
    const char *getGlobalVarAddrPrefix() const {
      return GlobalVarAddrPrefix;
    }
    const char *getGlobalVarAddrSuffix() const {
      return GlobalVarAddrSuffix;
    }
    const char *getFunctionAddrPrefix() const {
      return FunctionAddrPrefix;
    }
    const char *getFunctionAddrSuffix() const {
      return FunctionAddrSuffix;
    }
    const char *getPersonalityPrefix() const {
      return PersonalityPrefix;
    }
    const char *getPersonalitySuffix() const {
      return PersonalitySuffix;
    }
    bool getNeedsIndirectEncoding() const {
      return NeedsIndirectEncoding;
    }
    const char *getInlineAsmStart() const {
      return InlineAsmStart;
    }
    const char *getInlineAsmEnd() const {
      return InlineAsmEnd;
    }
    unsigned getAssemblerDialect() const {
      return AssemblerDialect;
    }
    const char *getZeroDirective() const {
      return ZeroDirective;
    }
    const char *getZeroDirectiveSuffix() const {
      return ZeroDirectiveSuffix;
    }
    const char *getAsciiDirective() const {
      return AsciiDirective;
    }
    const char *getAscizDirective() const {
      return AscizDirective;
    }
    const char *getData8bitsDirective() const {
      return Data8bitsDirective;
    }
    const char *getData16bitsDirective() const {
      return Data16bitsDirective;
    }
    const char *getData32bitsDirective() const {
      return Data32bitsDirective;
    }
    const char *getData64bitsDirective() const {
      return Data64bitsDirective;
    }
    const char *getJumpTableDirective() const {
      return JumpTableDirective;
    }
    const char *getAlignDirective() const {
      return AlignDirective;
    }
    bool getAlignmentIsInBytes() const {
      return AlignmentIsInBytes;
    }
    const char *getSwitchToSectionDirective() const {
      return SwitchToSectionDirective;
    }
    const char *getTextSectionStartSuffix() const {
      return TextSectionStartSuffix;
    }
    const char *getDataSectionStartSuffix() const {
      return DataSectionStartSuffix;
    }
    const char *getSectionEndDirectiveSuffix() const {
      return SectionEndDirectiveSuffix;
    }
    const char *getConstantPoolSection() const {
      return ConstantPoolSection;
    }
    const char *getJumpTableDataSection() const {
      return JumpTableDataSection;
    }
    const char *getCStringSection() const {
      return CStringSection;
    }
    const char *getStaticCtorsSection() const {
      return StaticCtorsSection;
    }
    const char *getStaticDtorsSection() const {
      return StaticDtorsSection;
    }
    const char *getFourByteConstantSection() const {
      return FourByteConstantSection;
    }
    const char *getEightByteConstantSection() const {
      return EightByteConstantSection;
    }
    const char *getSixteenByteConstantSection() const {
      return SixteenByteConstantSection;
    }
    const char *getReadOnlySection() const {
      return ReadOnlySection;
    }
    const char *getGlobalDirective() const {
      return GlobalDirective;
    }
    const char *getSetDirective() const {
      return SetDirective;
    }
    const char *getLCOMMDirective() const {
      return LCOMMDirective;
    }
    const char *getCOMMDirective() const {
      return COMMDirective;
    }
    bool getCOMMDirectiveTakesAlignment() const {
      return COMMDirectiveTakesAlignment;
    }
    bool hasDotTypeDotSizeDirective() const {
      return HasDotTypeDotSizeDirective;
    }
    const char *getUsedDirective() const {
      return UsedDirective;
    }
    const char *getWeakRefDirective() const {
      return WeakRefDirective;
    }
    const char *getWeakDefDirective() const {
      return WeakDefDirective;
    }
    const char *getHiddenDirective() const {
      return HiddenDirective;
    }
    const char *getProtectedDirective() const {
      return ProtectedDirective;
    }
    bool isAbsoluteDebugSectionOffsets() const {
      return AbsoluteDebugSectionOffsets;
    }
    bool isAbsoluteEHSectionOffsets() const {
      return AbsoluteEHSectionOffsets;
    }
    bool hasLEB128() const {
      return HasLEB128;
    }
    bool hasDotLocAndDotFile() const {
      return HasDotLocAndDotFile;
    }
    bool doesSupportDebugInformation() const {
      return SupportsDebugInformation;
    }
    bool doesSupportExceptionHandling() const {
      return SupportsExceptionHandling;
    }
    bool doesDwarfRequireFrameSection() const {
      return DwarfRequiresFrameSection;
    }
    const char *getGlobalEHDirective() const {
      return GlobalEHDirective;
    }
    bool getSupportsWeakOmittedEHFrame() const {
      return SupportsWeakOmittedEHFrame;
    }
    bool getShortenEHDataOn64Bit() const {
      return ShortenEHDataOn64Bit;
    }
    const char *getDwarfSectionOffsetDirective() const {
      return DwarfSectionOffsetDirective;
    }
    const char *getDwarfAbbrevSection() const {
      return DwarfAbbrevSection;
    }
    const char *getDwarfInfoSection() const {
      return DwarfInfoSection;
    }
    const char *getDwarfLineSection() const {
      return DwarfLineSection;
    }
    const char *getDwarfFrameSection() const {
      return DwarfFrameSection;
    }
    const char *getDwarfPubNamesSection() const {
      return DwarfPubNamesSection;
    }
    const char *getDwarfPubTypesSection() const {
      return DwarfPubTypesSection;
    }
    const char *getDwarfStrSection() const {
      return DwarfStrSection;
    }
    const char *getDwarfLocSection() const {
      return DwarfLocSection;
    }
    const char *getDwarfARangesSection() const {
      return DwarfARangesSection;
    }
    const char *getDwarfRangesSection() const {
      return DwarfRangesSection;
    }
    const char *getDwarfMacInfoSection() const {
      return DwarfMacInfoSection;
    }
    const char *getDwarfEHFrameSection() const {
      return DwarfEHFrameSection;
    }
    const char *getDwarfExceptionSection() const {
      return DwarfExceptionSection;
    }
    const char** getAsmCBE() const {
      return AsmTransCBE;
    }
  };
}
# 25 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetData.h" 1
# 26 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetData.h"
namespace llvm {

class Value;
class Type;
class IntegerType;
class StructType;
class StructLayout;
class GlobalVariable;
class LLVMContext;


enum AlignTypeEnum {
  INTEGER_ALIGN = 'i',
  VECTOR_ALIGN = 'v',
  FLOAT_ALIGN = 'f',
  AGGREGATE_ALIGN = 'a',
  STACK_ALIGN = 's'
};







struct TargetAlignElem {
  AlignTypeEnum AlignType : 8;
  unsigned char ABIAlign;
  unsigned char PrefAlign;
  uint32_t TypeBitWidth;


  static TargetAlignElem get(AlignTypeEnum align_type, unsigned char abi_align,
                             unsigned char pref_align, uint32_t bit_width);

  bool operator==(const TargetAlignElem &rhs) const;
};

class TargetData : public ImmutablePass {
private:
  bool LittleEndian;
  unsigned char PointerMemSize;
  unsigned char PointerABIAlign;
  unsigned char PointerPrefAlign;

  SmallVector<unsigned char, 8> LegalIntWidths;







  SmallVector<TargetAlignElem, 16> Alignments;



  static const TargetAlignElem InvalidAlignmentElem;


  mutable void *LayoutMap;


  void setAlignment(AlignTypeEnum align_type, unsigned char abi_align,
                    unsigned char pref_align, uint32_t bit_width);
  unsigned getAlignmentInfo(AlignTypeEnum align_type, uint32_t bit_width,
                            bool ABIAlign, const Type *Ty) const;

  unsigned char getAlignment(const Type *Ty, bool abi_or_pref) const;





  bool validAlignment(const TargetAlignElem &align) const {
    return &align != &InvalidAlignmentElem;
  }

public:




  TargetData();


  explicit TargetData(StringRef TargetDescription)
    : ImmutablePass(&ID) {
    init(TargetDescription);
  }


  explicit TargetData(const Module *M);

  TargetData(const TargetData &TD) :
    ImmutablePass(&ID),
    LittleEndian(TD.isLittleEndian()),
    PointerMemSize(TD.PointerMemSize),
    PointerABIAlign(TD.PointerABIAlign),
    PointerPrefAlign(TD.PointerPrefAlign),
    LegalIntWidths(TD.LegalIntWidths),
    Alignments(TD.Alignments),
    LayoutMap(0)
  { }

  ~TargetData();


  void init(StringRef TargetDescription);


  bool isLittleEndian() const { return LittleEndian; }
  bool isBigEndian() const { return !LittleEndian; }




  std::string getStringRepresentation() const;
# 152 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetData.h"
  bool isLegalInteger(unsigned Width) const {
    for (unsigned i = 0, e = (unsigned)LegalIntWidths.size(); i != e; ++i)
      if (LegalIntWidths[i] == Width)
        return true;
    return false;
  }

  bool isIllegalInteger(unsigned Width) const {
    return !isLegalInteger(Width);
  }


  unsigned char getPointerABIAlignment() const { return PointerABIAlign; }

  unsigned char getPointerPrefAlignment() const { return PointerPrefAlign; }

  unsigned char getPointerSize() const { return PointerMemSize; }

  unsigned char getPointerSizeInBits() const { return 8*PointerMemSize; }
# 191 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetData.h"
  uint64_t getTypeSizeInBits(const Type* Ty) const;




  uint64_t getTypeStoreSize(const Type *Ty) const {
    return (getTypeSizeInBits(Ty)+7)/8;
  }




  uint64_t getTypeStoreSizeInBits(const Type *Ty) const {
    return 8*getTypeStoreSize(Ty);
  }





  uint64_t getTypeAllocSize(const Type* Ty) const {

    return RoundUpAlignment(getTypeStoreSize(Ty), getABITypeAlignment(Ty));
  }





  uint64_t getTypeAllocSizeInBits(const Type* Ty) const {
    return 8*getTypeAllocSize(Ty);
  }



  unsigned char getABITypeAlignment(const Type *Ty) const;



  unsigned char getABIIntegerTypeAlignment(unsigned BitWidth) const;




  unsigned char getCallFrameTypeAlignment(const Type *Ty) const;




  unsigned char getPrefTypeAlignment(const Type *Ty) const;




  unsigned char getPreferredTypeAlignmentShift(const Type *Ty) const;




  const IntegerType *getIntPtrType(LLVMContext &C) const;




  uint64_t getIndexedOffset(const Type *Ty,
                            Value* const* Indices, unsigned NumIndices) const;




  const StructLayout *getStructLayout(const StructType *Ty) const;





  void InvalidateStructLayoutInfo(const StructType *Ty) const;




  unsigned getPreferredAlignment(const GlobalVariable *GV) const;




  unsigned getPreferredAlignmentLog(const GlobalVariable *GV) const;





  template <typename UIntTy>
  static UIntTy RoundUpAlignment(UIntTy Val, unsigned Alignment) {
    (((Alignment & (Alignment-1)) == 0 && "Alignment must be power of 2!") ? static_cast<void> (0) : __assert_fail ("(Alignment & (Alignment-1)) == 0 && \"Alignment must be power of 2!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetData.h", 285, __PRETTY_FUNCTION__));
    return (Val + (Alignment-1)) & ~UIntTy(Alignment-1);
  }

  static char ID;
};




class StructLayout {
  uint64_t StructSize;
  unsigned StructAlignment;
  unsigned NumElements;
  uint64_t MemberOffsets[1];
public:

  uint64_t getSizeInBytes() const {
    return StructSize;
  }

  uint64_t getSizeInBits() const {
    return 8*StructSize;
  }

  unsigned getAlignment() const {
    return StructAlignment;
  }




  unsigned getElementContainingOffset(uint64_t Offset) const;

  uint64_t getElementOffset(unsigned Idx) const {
    ((Idx < NumElements && "Invalid element idx!") ? static_cast<void> (0) : __assert_fail ("Idx < NumElements && \"Invalid element idx!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetData.h", 320, __PRETTY_FUNCTION__));
    return MemberOffsets[Idx];
  }

  uint64_t getElementOffsetInBits(unsigned Idx) const {
    return getElementOffset(Idx)*8;
  }

private:
  friend class TargetData;
  StructLayout(const StructType *ST, const TargetData &TD);
};

}
# 26 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h" 1
# 22 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Triple.h" 1
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Triple.h"
namespace llvm {
class StringRef;
class Twine;
# 53 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/Triple.h"
class Triple {
public:
  enum ArchType {
    UnknownArch,

    alpha,
    arm,
    bfin,
    cellspu,
    mips,
    mipsel,
    msp430,
    pic16,
    ppc,
    ppc64,
    sparc,
    sparcv9,
    systemz,
    tce,
    thumb,
    x86,
    x86_64,
    xcore,
    mblaze,

    InvalidArch
  };
  enum VendorType {
    UnknownVendor,

    Apple,
    PC
  };
  enum OSType {
    UnknownOS,

    AuroraUX,
    Cygwin,
    Darwin,
    DragonFly,
    FreeBSD,
    Linux,
    Lv2,
    MinGW32,
    MinGW64,
    NetBSD,
    OpenBSD,
    Psp,
    Solaris,
    Win32,
    Haiku
  };

private:
  std::string Data;


  mutable ArchType Arch;


  mutable VendorType Vendor;


  mutable OSType OS;

  bool isInitialized() const { return Arch != InvalidArch; }
  void Parse() const;

public:



  Triple() : Data(), Arch(InvalidArch) {}
  explicit Triple(StringRef Str) : Data(Str), Arch(InvalidArch) {}
  explicit Triple(StringRef ArchStr, StringRef VendorStr, StringRef OSStr)
    : Data(ArchStr), Arch(InvalidArch) {
    Data += '-';
    Data += VendorStr;
    Data += '-';
    Data += OSStr;
  }






  ArchType getArch() const {
    if (!isInitialized()) Parse();
    return Arch;
  }


  VendorType getVendor() const {
    if (!isInitialized()) Parse();
    return Vendor;
  }


  OSType getOS() const {
    if (!isInitialized()) Parse();
    return OS;
  }



  bool hasEnvironment() const {
    return getEnvironmentName() != "";
  }





  const std::string &str() const { return Data; }

  const std::string &getTriple() const { return Data; }



  StringRef getArchName() const;


  StringRef getVendorName() const;



  StringRef getOSName() const;



  StringRef getEnvironmentName() const;




  StringRef getOSAndEnvironmentName() const;






  void getDarwinNumber(unsigned &Maj, unsigned &Min, unsigned &Revision) const;



  unsigned getDarwinMajorNumber() const {
    unsigned Maj, Min, Rev;
    getDarwinNumber(Maj, Min, Rev);
    return Maj;
  }







  void setArch(ArchType Kind);



  void setVendor(VendorType Kind);



  void setOS(OSType Kind);


  void setTriple(const Twine &Str);



  void setArchName(StringRef Str);



  void setVendorName(StringRef Str);



  void setOSName(StringRef Str);



  void setEnvironmentName(StringRef Str);



  void setOSAndEnvironmentName(StringRef Str);



  const char *getArchNameForAssembler();







  static const char *getArchTypeName(ArchType Kind);







  static const char *getArchTypePrefix(ArchType Kind);



  static const char *getVendorTypeName(VendorType Kind);


  static const char *getOSTypeName(OSType Kind);







  static ArchType getArchTypeForLLVMName(StringRef Str);




  static ArchType getArchTypeForDarwinArchName(StringRef Str);


};

}
# 23 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h" 2

# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 25 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h" 2

namespace llvm {
  class AsmPrinter;
  class Module;
  class MCAssembler;
  class MCAsmInfo;
  class MCAsmParser;
  class MCCodeEmitter;
  class MCContext;
  class MCDisassembler;
  class MCInstPrinter;
  class MCStreamer;
  class TargetAsmBackend;
  class TargetAsmLexer;
  class TargetAsmParser;
  class TargetMachine;
  class formatted_raw_ostream;
  class raw_ostream;
# 52 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
  class Target {
  public:
    friend struct TargetRegistry;

    typedef unsigned (*TripleMatchQualityFnTy)(const std::string &TT);

    typedef const MCAsmInfo *(*AsmInfoCtorFnTy)(const Target &T,
                                                StringRef TT);
    typedef TargetMachine *(*TargetMachineCtorTy)(const Target &T,
                                                  const std::string &TT,
                                                  const std::string &Features);
    typedef AsmPrinter *(*AsmPrinterCtorTy)(formatted_raw_ostream &OS,
                                            TargetMachine &TM,
                                            MCContext &Ctx,
                                            MCStreamer &Streamer,
                                            const MCAsmInfo *MAI);
    typedef TargetAsmBackend *(*AsmBackendCtorTy)(const Target &T,
                                                  MCAssembler &A);
    typedef TargetAsmLexer *(*AsmLexerCtorTy)(const Target &T,
                                              const MCAsmInfo &MAI);
    typedef TargetAsmParser *(*AsmParserCtorTy)(const Target &T,MCAsmParser &P);
    typedef const MCDisassembler *(*MCDisassemblerCtorTy)(const Target &T);
    typedef MCInstPrinter *(*MCInstPrinterCtorTy)(const Target &T,
                                                  unsigned SyntaxVariant,
                                                  const MCAsmInfo &MAI,
                                                  raw_ostream &O);
    typedef MCCodeEmitter *(*CodeEmitterCtorTy)(const Target &T,
                                                TargetMachine &TM,
                                                MCContext &Ctx);

  private:


    Target *Next;



    TripleMatchQualityFnTy TripleMatchQualityFn;


    const char *Name;


    const char *ShortDesc;


    bool HasJIT;

    AsmInfoCtorFnTy AsmInfoCtorFn;



    TargetMachineCtorTy TargetMachineCtorFn;



    AsmBackendCtorTy AsmBackendCtorFn;



    AsmLexerCtorTy AsmLexerCtorFn;



    AsmParserCtorTy AsmParserCtorFn;



    AsmPrinterCtorTy AsmPrinterCtorFn;



    MCDisassemblerCtorTy MCDisassemblerCtorFn;



    MCInstPrinterCtorTy MCInstPrinterCtorFn;



    CodeEmitterCtorTy CodeEmitterCtorFn;

  public:




    const Target *getNext() const { return Next; }


    const char *getName() const { return Name; }


    const char *getShortDescription() const { return ShortDesc; }






    bool hasJIT() const { return HasJIT; }


    bool hasTargetMachine() const { return TargetMachineCtorFn != 0; }


    bool hasAsmBackend() const { return AsmBackendCtorFn != 0; }


    bool hasAsmLexer() const { return AsmLexerCtorFn != 0; }


    bool hasAsmParser() const { return AsmParserCtorFn != 0; }


    bool hasAsmPrinter() const { return AsmPrinterCtorFn != 0; }


    bool hasMCDisassembler() const { return MCDisassemblerCtorFn != 0; }


    bool hasMCInstPrinter() const { return MCInstPrinterCtorFn != 0; }


    bool hasCodeEmitter() const { return CodeEmitterCtorFn != 0; }
# 189 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
    const MCAsmInfo *createAsmInfo(StringRef Triple) const {
      if (!AsmInfoCtorFn)
        return 0;
      return AsmInfoCtorFn(*this, Triple);
    }
# 202 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
    TargetMachine *createTargetMachine(const std::string &Triple,
                                       const std::string &Features) const {
      if (!TargetMachineCtorFn)
        return 0;
      return TargetMachineCtorFn(*this, Triple, Features);
    }




    TargetAsmBackend *createAsmBackend(MCAssembler &Backend) const {
      if (!AsmBackendCtorFn)
        return 0;
      return AsmBackendCtorFn(*this, Backend);
    }



    TargetAsmLexer *createAsmLexer(const MCAsmInfo &MAI) const {
      if (!AsmLexerCtorFn)
        return 0;
      return AsmLexerCtorFn(*this, MAI);
    }





    TargetAsmParser *createAsmParser(MCAsmParser &Parser) const {
      if (!AsmParserCtorFn)
        return 0;
      return AsmParserCtorFn(*this, Parser);
    }



    AsmPrinter *createAsmPrinter(formatted_raw_ostream &OS, TargetMachine &TM,
                                 MCContext &Ctx, MCStreamer &Streamer,
                                 const MCAsmInfo *MAI) const {
      if (!AsmPrinterCtorFn)
        return 0;
      return AsmPrinterCtorFn(OS, TM, Ctx, Streamer, MAI);
    }

    const MCDisassembler *createMCDisassembler() const {
      if (!MCDisassemblerCtorFn)
        return 0;
      return MCDisassemblerCtorFn(*this);
    }

    MCInstPrinter *createMCInstPrinter(unsigned SyntaxVariant,
                                       const MCAsmInfo &MAI,
                                       raw_ostream &O) const {
      if (!MCInstPrinterCtorFn)
        return 0;
      return MCInstPrinterCtorFn(*this, SyntaxVariant, MAI, O);
    }



    MCCodeEmitter *createCodeEmitter(TargetMachine &TM, MCContext &Ctx) const {
      if (!CodeEmitterCtorFn)
        return 0;
      return CodeEmitterCtorFn(*this, TM, Ctx);
    }


  };


  struct TargetRegistry {
    class iterator {
      const Target *Current;
      explicit iterator(Target *T) : Current(T) {}
      friend struct TargetRegistry;
    public:
      iterator(const iterator &I) : Current(I.Current) {}
      iterator() : Current(0) {}

      bool operator==(const iterator &x) const {
        return Current == x.Current;
      }
      bool operator!=(const iterator &x) const {
        return !operator==(x);
      }


      iterator &operator++() {
        ((Current && "Cannot increment end iterator!") ? static_cast<void> (0) : __assert_fail ("Current && \"Cannot increment end iterator!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h", 290, __PRETTY_FUNCTION__));
        Current = Current->getNext();
        return *this;
      }
      iterator operator++(int) {
        iterator tmp = *this;
        ++*this;
        return tmp;
      }

      const Target &operator*() const {
        ((Current && "Cannot dereference end iterator!") ? static_cast<void> (0) : __assert_fail ("Current && \"Cannot dereference end iterator!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h", 301, __PRETTY_FUNCTION__));
        return *Current;
      }

      const Target *operator->() const {
        return &operator*();
      }
    };




    static iterator begin();

    static iterator end() { return iterator(); }






    static const Target *lookupTarget(const std::string &Triple,
                                      std::string &Error);






    static const Target *getClosestTargetForJIT(std::string &Error);
# 351 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
    static void RegisterTarget(Target &T,
                               const char *Name,
                               const char *ShortDesc,
                               Target::TripleMatchQualityFnTy TQualityFn,
                               bool HasJIT = false);
# 366 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
    static void RegisterAsmInfo(Target &T, Target::AsmInfoCtorFnTy Fn) {

      if (!T.AsmInfoCtorFn)
        T.AsmInfoCtorFn = Fn;
    }
# 381 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
    static void RegisterTargetMachine(Target &T,
                                      Target::TargetMachineCtorTy Fn) {

      if (!T.TargetMachineCtorFn)
        T.TargetMachineCtorFn = Fn;
    }
# 397 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
    static void RegisterAsmBackend(Target &T, Target::AsmBackendCtorTy Fn) {
      if (!T.AsmBackendCtorFn)
        T.AsmBackendCtorFn = Fn;
    }
# 411 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
    static void RegisterAsmLexer(Target &T, Target::AsmLexerCtorTy Fn) {
      if (!T.AsmLexerCtorFn)
        T.AsmLexerCtorFn = Fn;
    }
# 425 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
    static void RegisterAsmParser(Target &T, Target::AsmParserCtorTy Fn) {
      if (!T.AsmParserCtorFn)
        T.AsmParserCtorFn = Fn;
    }
# 439 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
    static void RegisterAsmPrinter(Target &T, Target::AsmPrinterCtorTy Fn) {

      if (!T.AsmPrinterCtorFn)
        T.AsmPrinterCtorFn = Fn;
    }
# 454 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
    static void RegisterMCDisassembler(Target &T,
                                       Target::MCDisassemblerCtorTy Fn) {
      if (!T.MCDisassemblerCtorFn)
        T.MCDisassemblerCtorFn = Fn;
    }
# 469 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
    static void RegisterMCInstPrinter(Target &T,
                                      Target::MCInstPrinterCtorTy Fn) {
      if (!T.MCInstPrinterCtorFn)
        T.MCInstPrinterCtorFn = Fn;
    }
# 484 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
    static void RegisterCodeEmitter(Target &T, Target::CodeEmitterCtorTy Fn) {
      if (!T.CodeEmitterCtorFn)
        T.CodeEmitterCtorFn = Fn;
    }


  };
# 504 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
  template<Triple::ArchType TargetArchType = Triple::InvalidArch,
           bool HasJIT = false>
  struct RegisterTarget {
    RegisterTarget(Target &T, const char *Name, const char *Desc) {
      TargetRegistry::RegisterTarget(T, Name, Desc,
                                     &getTripleMatchQuality,
                                     HasJIT);
    }

    static unsigned getTripleMatchQuality(const std::string &TT) {
      if (Triple(TT).getArch() == TargetArchType)
        return 20;
      return 0;
    }
  };
# 528 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
  template<class MCAsmInfoImpl>
  struct RegisterAsmInfo {
    RegisterAsmInfo(Target &T) {
      TargetRegistry::RegisterAsmInfo(T, &Allocator);
    }
  private:
    static const MCAsmInfo *Allocator(const Target &T, StringRef TT) {
      return new MCAsmInfoImpl(T, TT);
    }

  };
# 548 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
  struct RegisterAsmInfoFn {
    RegisterAsmInfoFn(Target &T, Target::AsmInfoCtorFnTy Fn) {
      TargetRegistry::RegisterAsmInfo(T, Fn);
    }
  };
# 563 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
  template<class TargetMachineImpl>
  struct RegisterTargetMachine {
    RegisterTargetMachine(Target &T) {
      TargetRegistry::RegisterTargetMachine(T, &Allocator);
    }

  private:
    static TargetMachine *Allocator(const Target &T, const std::string &TT,
                                    const std::string &FS) {
      return new TargetMachineImpl(T, TT, FS);
    }
  };
# 583 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
  template<class AsmBackendImpl>
  struct RegisterAsmBackend {
    RegisterAsmBackend(Target &T) {
      TargetRegistry::RegisterAsmBackend(T, &Allocator);
    }

  private:
    static TargetAsmBackend *Allocator(const Target &T, MCAssembler &Backend) {
      return new AsmBackendImpl(T, Backend);
    }
  };
# 603 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
  template<class AsmLexerImpl>
  struct RegisterAsmLexer {
    RegisterAsmLexer(Target &T) {
      TargetRegistry::RegisterAsmLexer(T, &Allocator);
    }

  private:
    static TargetAsmLexer *Allocator(const Target &T, const MCAsmInfo &MAI) {
      return new AsmLexerImpl(T, MAI);
    }
  };
# 623 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
  template<class AsmParserImpl>
  struct RegisterAsmParser {
    RegisterAsmParser(Target &T) {
      TargetRegistry::RegisterAsmParser(T, &Allocator);
    }

  private:
    static TargetAsmParser *Allocator(const Target &T, MCAsmParser &P) {
      return new AsmParserImpl(T, P);
    }
  };
# 643 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
  template<class AsmPrinterImpl>
  struct RegisterAsmPrinter {
    RegisterAsmPrinter(Target &T) {
      TargetRegistry::RegisterAsmPrinter(T, &Allocator);
    }

  private:
    static AsmPrinter *Allocator(formatted_raw_ostream &OS, TargetMachine &TM,
                                 MCContext &Ctx, MCStreamer &Streamer,
                                 const MCAsmInfo *MAI) {
      return new AsmPrinterImpl(OS, TM, Ctx, Streamer, MAI);
    }
  };
# 665 "/local/monniaux/packages/llvm-2.7/include/llvm/Target/TargetRegistry.h"
  template<class CodeEmitterImpl>
  struct RegisterCodeEmitter {
    RegisterCodeEmitter(Target &T) {
      TargetRegistry::RegisterCodeEmitter(T, &Allocator);
    }

  private:
    static MCCodeEmitter *Allocator(const Target &T, TargetMachine &TM,
                                    MCContext &Ctx) {
      return new CodeEmitterImpl(T, TM, Ctx);
    }
  };

}
# 27 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CallSite.h" 1
# 32 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CallSite.h"
namespace llvm {

class CallInst;
class InvokeInst;

class CallSite {
  PointerIntPair<Instruction*, 1, bool> I;
public:
  CallSite() : I(0, false) {}
  CallSite(CallInst *CI) : I(reinterpret_cast<Instruction*>(CI), true) {}
  CallSite(InvokeInst *II) : I(reinterpret_cast<Instruction*>(II), false) {}
  CallSite(Instruction *C);

  bool operator==(const CallSite &CS) const { return I == CS.I; }
  bool operator!=(const CallSite &CS) const { return I != CS.I; }






  static CallSite get(Value *V) {
    if (Instruction *I = dyn_cast<Instruction>(V)) {
      if (I->getOpcode() == Instruction::Call)
        return CallSite(reinterpret_cast<CallInst*>(I));
      else if (I->getOpcode() == Instruction::Invoke)
        return CallSite(reinterpret_cast<InvokeInst*>(I));
    }
    return CallSite();
  }



  CallingConv::ID getCallingConv() const;
  void setCallingConv(CallingConv::ID CC);



  const AttrListPtr &getAttributes() const;
  void setAttributes(const AttrListPtr &PAL);


  bool paramHasAttr(uint16_t i, Attributes attr) const;


  uint16_t getParamAlignment(uint16_t i) const;


  bool doesNotAccessMemory() const;
  void setDoesNotAccessMemory(bool doesNotAccessMemory = true);


  bool onlyReadsMemory() const;
  void setOnlyReadsMemory(bool onlyReadsMemory = true);


  bool doesNotReturn() const;
  void setDoesNotReturn(bool doesNotReturn = true);


  bool doesNotThrow() const;
  void setDoesNotThrow(bool doesNotThrow = true);



  const Type *getType() const { return getInstruction()->getType(); }




  bool isCall() const { return I.getInt(); }



  bool isInvoke() const { return getInstruction() && !I.getInt(); }



  Instruction *getInstruction() const { return I.getPointer(); }



  Function *getCaller() const { return getInstruction()
                                  ->getParent()->getParent(); }



  Value *getCalledValue() const {
    ((getInstruction() && "Not a call or invoke instruction!") ? static_cast<void> (0) : __assert_fail ("getInstruction() && \"Not a call or invoke instruction!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CallSite.h", 120, __PRETTY_FUNCTION__));
    return getInstruction()->getOperand(0);
  }




  Function *getCalledFunction() const {
    return dyn_cast<Function>(getCalledValue());
  }



  void setCalledFunction(Value *V) {
    ((getInstruction() && "Not a call or invoke instruction!") ? static_cast<void> (0) : __assert_fail ("getInstruction() && \"Not a call or invoke instruction!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CallSite.h", 134, __PRETTY_FUNCTION__));
    getInstruction()->setOperand(0, V);
  }

  Value *getArgument(unsigned ArgNo) const {
    ((arg_begin() + ArgNo < arg_end() && "Argument # out of range!") ? static_cast<void> (0) : __assert_fail ("arg_begin() + ArgNo < arg_end() && \"Argument # out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CallSite.h", 139, __PRETTY_FUNCTION__));
    return *(arg_begin()+ArgNo);
  }

  void setArgument(unsigned ArgNo, Value* newVal) {
    ((getInstruction() && "Not a call or invoke instruction!") ? static_cast<void> (0) : __assert_fail ("getInstruction() && \"Not a call or invoke instruction!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CallSite.h", 144, __PRETTY_FUNCTION__));
    ((arg_begin() + ArgNo < arg_end() && "Argument # out of range!") ? static_cast<void> (0) : __assert_fail ("arg_begin() + ArgNo < arg_end() && \"Argument # out of range!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CallSite.h", 145, __PRETTY_FUNCTION__));
    getInstruction()->setOperand(getArgumentOffset() + ArgNo, newVal);
  }




  unsigned getArgumentNo(unsigned OperandNo) const {
    ((OperandNo >= getArgumentOffset() && "Operand number passed was not " "a valid argument") ? static_cast<void> (0) : __assert_fail ("OperandNo >= getArgumentOffset() && \"Operand number passed was not \" \"a valid argument\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CallSite.h", 154, __PRETTY_FUNCTION__));

    return OperandNo - getArgumentOffset();
  }



  bool hasArgument(const Value *Arg) const;



  typedef User::op_iterator arg_iterator;



  arg_iterator arg_begin() const {
    ((getInstruction() && "Not a call or invoke instruction!") ? static_cast<void> (0) : __assert_fail ("getInstruction() && \"Not a call or invoke instruction!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/CallSite.h", 169, __PRETTY_FUNCTION__));

    return getInstruction()->op_begin() + getArgumentOffset();
  }

  arg_iterator arg_end() const { return getInstruction()->op_end(); }
  bool arg_empty() const { return arg_end() == arg_begin(); }
  unsigned arg_size() const { return unsigned(arg_end() - arg_begin()); }

  bool operator<(const CallSite &CS) const {
    return getInstruction() < CS.getInstruction();
  }

  bool isCallee(Value::use_iterator UI) const {
    return getInstruction()->op_begin() == &UI.getUse();
  }

private:

  unsigned getArgumentOffset() const {
    if (isCall())
      return 1;
    else
      return 3;
  }
};

}
# 28 "SMTBackend.cc" 2

# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/ErrorHandling.h" 1
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/ErrorHandling.h"
namespace llvm {
  class Twine;


  typedef void (*llvm_error_handler_t)(void *user_data,
                                       const std::string& reason);
# 47 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/ErrorHandling.h"
  void llvm_install_error_handler(llvm_error_handler_t handler,
                                  void *user_data = 0);




  void llvm_remove_error_handler();
# 63 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/ErrorHandling.h"
  __attribute__((noreturn)) void llvm_report_error(const char *reason);
  __attribute__((noreturn)) void llvm_report_error(const std::string &reason);
  __attribute__((noreturn)) void llvm_report_error(const Twine &reason);




  __attribute__((noreturn)) void llvm_unreachable_internal(const char *msg=0,
                                          const char *file=0, unsigned line=0);
}
# 30 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/FormattedStream.h" 1
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/FormattedStream.h"
namespace llvm
{



  class formatted_raw_ostream : public raw_ostream {
  public:


    static const bool DELETE_STREAM = true;




    static const bool PRESERVE_STREAM = false;

  private:



    raw_ostream *TheStream;




    bool DeleteStream;





    unsigned ColumnScanned;




    const char *Scanned;

    virtual void write_impl(const char *Ptr, size_t Size);



    virtual uint64_t current_pos() const {


      return TheStream->tell() - TheStream->GetNumBytesInBuffer();
    }




    void ComputeColumn(const char *Ptr, size_t size);

  public:
# 84 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/FormattedStream.h"
    formatted_raw_ostream(raw_ostream &Stream, bool Delete = false)
      : raw_ostream(), TheStream(0), DeleteStream(false), ColumnScanned(0) {
      setStream(Stream, Delete);
    }
    explicit formatted_raw_ostream()
      : raw_ostream(), TheStream(0), DeleteStream(false), ColumnScanned(0) {
      Scanned = 0;
    }

    ~formatted_raw_ostream() {
      flush();
      releaseStream();
    }

    void setStream(raw_ostream &Stream, bool Delete = false) {
      releaseStream();

      TheStream = &Stream;
      DeleteStream = Delete;





      if (size_t BufferSize = TheStream->GetBufferSize())
        SetBufferSize(BufferSize);
      else
        SetUnbuffered();
      TheStream->SetUnbuffered();

      Scanned = 0;
    }






    formatted_raw_ostream &PadToColumn(unsigned NewCol);

  private:
    void releaseStream() {


      if (!TheStream)
        return;
      if (DeleteStream)
        delete TheStream;
      else if (size_t BufferSize = GetBufferSize())
        TheStream->SetBufferSize(BufferSize);
      else
        TheStream->SetUnbuffered();
    }
  };



formatted_raw_ostream &fouts();



formatted_raw_ostream &ferrs();



formatted_raw_ostream &fdbgs();

}
# 31 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/GetElementPtrTypeIterator.h" 1
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/GetElementPtrTypeIterator.h"
namespace llvm {
  template<typename ItTy = User::const_op_iterator>
  class generic_gep_type_iterator
    : public std::iterator<std::forward_iterator_tag, const Type *, ptrdiff_t> {
    typedef std::iterator<std::forward_iterator_tag,
                          const Type *, ptrdiff_t> super;

    ItTy OpIt;
    const Type *CurTy;
    generic_gep_type_iterator() {}
  public:

    static generic_gep_type_iterator begin(const Type *Ty, ItTy It) {
      generic_gep_type_iterator I;
      I.CurTy = Ty;
      I.OpIt = It;
      return I;
    }
    static generic_gep_type_iterator end(ItTy It) {
      generic_gep_type_iterator I;
      I.CurTy = 0;
      I.OpIt = It;
      return I;
    }

    bool operator==(const generic_gep_type_iterator& x) const {
      return OpIt == x.OpIt;
    }
    bool operator!=(const generic_gep_type_iterator& x) const {
      return !operator==(x);
    }

    const Type *operator*() const {
      return CurTy;
    }

    const Type *getIndexedType() const {
      const CompositeType *CT = cast<CompositeType>(CurTy);
      return CT->getTypeAtIndex(getOperand());
    }



    const Type *operator->() const { return operator*(); }

    Value *getOperand() const { return *OpIt; }

    generic_gep_type_iterator& operator++() {
      if (const CompositeType *CT = dyn_cast<CompositeType>(CurTy)) {
        CurTy = CT->getTypeAtIndex(getOperand());
      } else {
        CurTy = 0;
      }
      ++OpIt;
      return *this;
    }

    generic_gep_type_iterator operator++(int) {
      generic_gep_type_iterator tmp = *this; ++*this; return tmp;
    }
  };

  typedef generic_gep_type_iterator<> gep_type_iterator;

  inline gep_type_iterator gep_type_begin(const User *GEP) {
    return gep_type_iterator::begin(GEP->getOperand(0)->getType(),
                                    GEP->op_begin()+1);
  }
  inline gep_type_iterator gep_type_end(const User *GEP) {
    return gep_type_iterator::end(GEP->op_end());
  }
  inline gep_type_iterator gep_type_begin(const User &GEP) {
    return gep_type_iterator::begin(GEP.getOperand(0)->getType(),
                                    GEP.op_begin()+1);
  }
  inline gep_type_iterator gep_type_end(const User &GEP) {
    return gep_type_iterator::end(GEP.op_end());
  }

  template<typename ItTy>
  inline generic_gep_type_iterator<ItTy>
  gep_type_begin(const Type *Op0, ItTy I, ItTy E) {
    return generic_gep_type_iterator<ItTy>::begin(Op0, I);
  }

  template<typename ItTy>
  inline generic_gep_type_iterator<ItTy>
  gep_type_end(const Type *Op0, ItTy I, ItTy E) {
    return generic_gep_type_iterator<ItTy>::end(E);
  }
}
# 32 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/InstVisitor.h" 1
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/InstVisitor.h"
namespace llvm {





# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def" 1
# 96 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def"

class ReturnInst;
class BranchInst;
class SwitchInst;
class IndirectBrInst;
class InvokeInst;
class UnwindInst;
class UnreachableInst;
 



class BinaryOperator;
class BinaryOperator;
class BinaryOperator;
class BinaryOperator;
class BinaryOperator;
class BinaryOperator;
class BinaryOperator;
class BinaryOperator;
class BinaryOperator;
class BinaryOperator;
class BinaryOperator;
class BinaryOperator;


class BinaryOperator;
class BinaryOperator;
class BinaryOperator;
class BinaryOperator;
class BinaryOperator;
class BinaryOperator;
 



class AllocaInst;
class LoadInst;
class StoreInst;
class GetElementPtrInst;
 





class TruncInst;
class ZExtInst;
class SExtInst;
class FPToUIInst;
class FPToSIInst;
class UIToFPInst;
class SIToFPInst;
class FPTruncInst;
class FPExtInst;
class PtrToIntInst;
class IntToPtrInst;
class BitCastInst;
 



class ICmpInst;
class FCmpInst;
class PHINode;
class CallInst;
class SelectInst;
class Instruction;
class Instruction;
class VAArgInst;
class ExtractElementInst;
class InsertElementInst;
class ShuffleVectorInst;
class ExtractValueInst;
class InsertValueInst;

 
# 26 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/InstVisitor.h" 2
# 77 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/InstVisitor.h"
template<typename SubClass, typename RetTy=void>
class InstVisitor {





public:

  template<class Iterator>
  void visit(Iterator Start, Iterator End) {
    while (Start != End)
      static_cast<SubClass*>(this)->visit(*Start++);
  }



  void visit(Module &M) {
    static_cast<SubClass*>(this)->visitModule(M);
    visit(M.begin(), M.end());
  }
  void visit(Function &F) {
    static_cast<SubClass*>(this)->visitFunction(F);
    visit(F.begin(), F.end());
  }
  void visit(BasicBlock &BB) {
    static_cast<SubClass*>(this)->visitBasicBlock(BB);
    visit(BB.begin(), BB.end());
  }


  void visit(Module *M) { visit(*M); }
  void visit(Function *F) { visit(*F); }
  void visit(BasicBlock *BB) { visit(*BB); }
  RetTy visit(Instruction *I) { return visit(*I); }



  RetTy visit(Instruction &I) {
    switch (I.getOpcode()) {
    default: ::llvm::llvm_unreachable_internal("Unknown instruction type encountered!", "/local/monniaux/packages/llvm-2.7/include/llvm/Support/InstVisitor.h", 117);





# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def" 1
# 96 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def"

case Instruction::Ret: return static_cast<SubClass*>(this)-> visitRet(static_cast<ReturnInst&>(I));
case Instruction::Br: return static_cast<SubClass*>(this)-> visitBr(static_cast<BranchInst&>(I));
case Instruction::Switch: return static_cast<SubClass*>(this)-> visitSwitch(static_cast<SwitchInst&>(I));
case Instruction::IndirectBr: return static_cast<SubClass*>(this)-> visitIndirectBr(static_cast<IndirectBrInst&>(I));
case Instruction::Invoke: return static_cast<SubClass*>(this)-> visitInvoke(static_cast<InvokeInst&>(I));
case Instruction::Unwind: return static_cast<SubClass*>(this)-> visitUnwind(static_cast<UnwindInst&>(I));
case Instruction::Unreachable: return static_cast<SubClass*>(this)-> visitUnreachable(static_cast<UnreachableInst&>(I));
 



case Instruction::Add: return static_cast<SubClass*>(this)-> visitAdd(static_cast<BinaryOperator&>(I));
case Instruction::FAdd: return static_cast<SubClass*>(this)-> visitFAdd(static_cast<BinaryOperator&>(I));
case Instruction::Sub: return static_cast<SubClass*>(this)-> visitSub(static_cast<BinaryOperator&>(I));
case Instruction::FSub: return static_cast<SubClass*>(this)-> visitFSub(static_cast<BinaryOperator&>(I));
case Instruction::Mul: return static_cast<SubClass*>(this)-> visitMul(static_cast<BinaryOperator&>(I));
case Instruction::FMul: return static_cast<SubClass*>(this)-> visitFMul(static_cast<BinaryOperator&>(I));
case Instruction::UDiv: return static_cast<SubClass*>(this)-> visitUDiv(static_cast<BinaryOperator&>(I));
case Instruction::SDiv: return static_cast<SubClass*>(this)-> visitSDiv(static_cast<BinaryOperator&>(I));
case Instruction::FDiv: return static_cast<SubClass*>(this)-> visitFDiv(static_cast<BinaryOperator&>(I));
case Instruction::URem: return static_cast<SubClass*>(this)-> visitURem(static_cast<BinaryOperator&>(I));
case Instruction::SRem: return static_cast<SubClass*>(this)-> visitSRem(static_cast<BinaryOperator&>(I));
case Instruction::FRem: return static_cast<SubClass*>(this)-> visitFRem(static_cast<BinaryOperator&>(I));


case Instruction::Shl: return static_cast<SubClass*>(this)-> visitShl(static_cast<BinaryOperator&>(I));
case Instruction::LShr: return static_cast<SubClass*>(this)-> visitLShr(static_cast<BinaryOperator&>(I));
case Instruction::AShr: return static_cast<SubClass*>(this)-> visitAShr(static_cast<BinaryOperator&>(I));
case Instruction::And: return static_cast<SubClass*>(this)-> visitAnd(static_cast<BinaryOperator&>(I));
case Instruction::Or: return static_cast<SubClass*>(this)-> visitOr(static_cast<BinaryOperator&>(I));
case Instruction::Xor: return static_cast<SubClass*>(this)-> visitXor(static_cast<BinaryOperator&>(I));
 



case Instruction::Alloca: return static_cast<SubClass*>(this)-> visitAlloca(static_cast<AllocaInst&>(I));
case Instruction::Load: return static_cast<SubClass*>(this)-> visitLoad(static_cast<LoadInst&>(I));
case Instruction::Store: return static_cast<SubClass*>(this)-> visitStore(static_cast<StoreInst&>(I));
case Instruction::GetElementPtr: return static_cast<SubClass*>(this)-> visitGetElementPtr(static_cast<GetElementPtrInst&>(I));
 





case Instruction::Trunc: return static_cast<SubClass*>(this)-> visitTrunc(static_cast<TruncInst&>(I));
case Instruction::ZExt: return static_cast<SubClass*>(this)-> visitZExt(static_cast<ZExtInst&>(I));
case Instruction::SExt: return static_cast<SubClass*>(this)-> visitSExt(static_cast<SExtInst&>(I));
case Instruction::FPToUI: return static_cast<SubClass*>(this)-> visitFPToUI(static_cast<FPToUIInst&>(I));
case Instruction::FPToSI: return static_cast<SubClass*>(this)-> visitFPToSI(static_cast<FPToSIInst&>(I));
case Instruction::UIToFP: return static_cast<SubClass*>(this)-> visitUIToFP(static_cast<UIToFPInst&>(I));
case Instruction::SIToFP: return static_cast<SubClass*>(this)-> visitSIToFP(static_cast<SIToFPInst&>(I));
case Instruction::FPTrunc: return static_cast<SubClass*>(this)-> visitFPTrunc(static_cast<FPTruncInst&>(I));
case Instruction::FPExt: return static_cast<SubClass*>(this)-> visitFPExt(static_cast<FPExtInst&>(I));
case Instruction::PtrToInt: return static_cast<SubClass*>(this)-> visitPtrToInt(static_cast<PtrToIntInst&>(I));
case Instruction::IntToPtr: return static_cast<SubClass*>(this)-> visitIntToPtr(static_cast<IntToPtrInst&>(I));
case Instruction::BitCast: return static_cast<SubClass*>(this)-> visitBitCast(static_cast<BitCastInst&>(I));
 



case Instruction::ICmp: return static_cast<SubClass*>(this)-> visitICmp(static_cast<ICmpInst&>(I));
case Instruction::FCmp: return static_cast<SubClass*>(this)-> visitFCmp(static_cast<FCmpInst&>(I));
case Instruction::PHI: return static_cast<SubClass*>(this)-> visitPHI(static_cast<PHINode&>(I));
case Instruction::Call: return static_cast<SubClass*>(this)-> visitCall(static_cast<CallInst&>(I));
case Instruction::Select: return static_cast<SubClass*>(this)-> visitSelect(static_cast<SelectInst&>(I));
case Instruction::UserOp1: return static_cast<SubClass*>(this)-> visitUserOp1(static_cast<Instruction&>(I));
case Instruction::UserOp2: return static_cast<SubClass*>(this)-> visitUserOp2(static_cast<Instruction&>(I));
case Instruction::VAArg: return static_cast<SubClass*>(this)-> visitVAArg(static_cast<VAArgInst&>(I));
case Instruction::ExtractElement: return static_cast<SubClass*>(this)-> visitExtractElement(static_cast<ExtractElementInst&>(I));
case Instruction::InsertElement: return static_cast<SubClass*>(this)-> visitInsertElement(static_cast<InsertElementInst&>(I));
case Instruction::ShuffleVector: return static_cast<SubClass*>(this)-> visitShuffleVector(static_cast<ShuffleVectorInst&>(I));
case Instruction::ExtractValue: return static_cast<SubClass*>(this)-> visitExtractValue(static_cast<ExtractValueInst&>(I));
case Instruction::InsertValue: return static_cast<SubClass*>(this)-> visitInsertValue(static_cast<InsertValueInst&>(I));

 
# 124 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/InstVisitor.h" 2
    }
  }
# 138 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/InstVisitor.h"
  void visitModule (Module &M) {}
  void visitFunction (Function &F) {}
  void visitBasicBlock(BasicBlock &BB) {}
# 155 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/InstVisitor.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def" 1
# 96 "/local/monniaux/packages/llvm-2.7/include/llvm/Instruction.def"

RetTy visitRet(ReturnInst &I) { return static_cast<SubClass*>(this)-> visitReturnInst(static_cast<ReturnInst&>(I)); }
RetTy visitBr(BranchInst &I) { return static_cast<SubClass*>(this)-> visitBranchInst(static_cast<BranchInst&>(I)); }
RetTy visitSwitch(SwitchInst &I) { return static_cast<SubClass*>(this)-> visitSwitchInst(static_cast<SwitchInst&>(I)); }
RetTy visitIndirectBr(IndirectBrInst &I) { return static_cast<SubClass*>(this)-> visitIndirectBrInst(static_cast<IndirectBrInst&>(I)); }
RetTy visitInvoke(InvokeInst &I) { return static_cast<SubClass*>(this)-> visitInvokeInst(static_cast<InvokeInst&>(I)); }
RetTy visitUnwind(UnwindInst &I) { return static_cast<SubClass*>(this)-> visitUnwindInst(static_cast<UnwindInst&>(I)); }
RetTy visitUnreachable(UnreachableInst &I) { return static_cast<SubClass*>(this)-> visitUnreachableInst(static_cast<UnreachableInst&>(I)); }
 



RetTy visitAdd(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitFAdd(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitSub(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitFSub(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitMul(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitFMul(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitUDiv(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitSDiv(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitFDiv(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitURem(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitSRem(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitFRem(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }


RetTy visitShl(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitLShr(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitAShr(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitAnd(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitOr(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
RetTy visitXor(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitBinaryOperator(static_cast<BinaryOperator&>(I)); }
 



RetTy visitAlloca(AllocaInst &I) { return static_cast<SubClass*>(this)-> visitAllocaInst(static_cast<AllocaInst&>(I)); }
RetTy visitLoad(LoadInst &I) { return static_cast<SubClass*>(this)-> visitLoadInst(static_cast<LoadInst&>(I)); }
RetTy visitStore(StoreInst &I) { return static_cast<SubClass*>(this)-> visitStoreInst(static_cast<StoreInst&>(I)); }
RetTy visitGetElementPtr(GetElementPtrInst &I) { return static_cast<SubClass*>(this)-> visitGetElementPtrInst(static_cast<GetElementPtrInst&>(I)); }
 





RetTy visitTrunc(TruncInst &I) { return static_cast<SubClass*>(this)-> visitTruncInst(static_cast<TruncInst&>(I)); }
RetTy visitZExt(ZExtInst &I) { return static_cast<SubClass*>(this)-> visitZExtInst(static_cast<ZExtInst&>(I)); }
RetTy visitSExt(SExtInst &I) { return static_cast<SubClass*>(this)-> visitSExtInst(static_cast<SExtInst&>(I)); }
RetTy visitFPToUI(FPToUIInst &I) { return static_cast<SubClass*>(this)-> visitFPToUIInst(static_cast<FPToUIInst&>(I)); }
RetTy visitFPToSI(FPToSIInst &I) { return static_cast<SubClass*>(this)-> visitFPToSIInst(static_cast<FPToSIInst&>(I)); }
RetTy visitUIToFP(UIToFPInst &I) { return static_cast<SubClass*>(this)-> visitUIToFPInst(static_cast<UIToFPInst&>(I)); }
RetTy visitSIToFP(SIToFPInst &I) { return static_cast<SubClass*>(this)-> visitSIToFPInst(static_cast<SIToFPInst&>(I)); }
RetTy visitFPTrunc(FPTruncInst &I) { return static_cast<SubClass*>(this)-> visitFPTruncInst(static_cast<FPTruncInst&>(I)); }
RetTy visitFPExt(FPExtInst &I) { return static_cast<SubClass*>(this)-> visitFPExtInst(static_cast<FPExtInst&>(I)); }
RetTy visitPtrToInt(PtrToIntInst &I) { return static_cast<SubClass*>(this)-> visitPtrToIntInst(static_cast<PtrToIntInst&>(I)); }
RetTy visitIntToPtr(IntToPtrInst &I) { return static_cast<SubClass*>(this)-> visitIntToPtrInst(static_cast<IntToPtrInst&>(I)); }
RetTy visitBitCast(BitCastInst &I) { return static_cast<SubClass*>(this)-> visitBitCastInst(static_cast<BitCastInst&>(I)); }
 



RetTy visitICmp(ICmpInst &I) { return static_cast<SubClass*>(this)-> visitICmpInst(static_cast<ICmpInst&>(I)); }
RetTy visitFCmp(FCmpInst &I) { return static_cast<SubClass*>(this)-> visitFCmpInst(static_cast<FCmpInst&>(I)); }
RetTy visitPHI(PHINode &I) { return static_cast<SubClass*>(this)-> visitPHINode(static_cast<PHINode&>(I)); }
RetTy visitCall(CallInst &I) { return static_cast<SubClass*>(this)-> visitCallInst(static_cast<CallInst&>(I)); }
RetTy visitSelect(SelectInst &I) { return static_cast<SubClass*>(this)-> visitSelectInst(static_cast<SelectInst&>(I)); }
RetTy visitUserOp1(Instruction &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
RetTy visitUserOp2(Instruction &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
RetTy visitVAArg(VAArgInst &I) { return static_cast<SubClass*>(this)-> visitVAArgInst(static_cast<VAArgInst&>(I)); }
RetTy visitExtractElement(ExtractElementInst &I) { return static_cast<SubClass*>(this)-> visitExtractElementInst(static_cast<ExtractElementInst&>(I)); }
RetTy visitInsertElement(InsertElementInst &I) { return static_cast<SubClass*>(this)-> visitInsertElementInst(static_cast<InsertElementInst&>(I)); }
RetTy visitShuffleVector(ShuffleVectorInst &I) { return static_cast<SubClass*>(this)-> visitShuffleVectorInst(static_cast<ShuffleVectorInst&>(I)); }
RetTy visitExtractValue(ExtractValueInst &I) { return static_cast<SubClass*>(this)-> visitExtractValueInst(static_cast<ExtractValueInst&>(I)); }
RetTy visitInsertValue(InsertValueInst &I) { return static_cast<SubClass*>(this)-> visitInsertValueInst(static_cast<InsertValueInst&>(I)); }

 
# 156 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/InstVisitor.h" 2




  RetTy visitReturnInst(ReturnInst &I) { return static_cast<SubClass*>(this)-> visitTerminatorInst(static_cast<TerminatorInst&>(I));}
  RetTy visitBranchInst(BranchInst &I) { return static_cast<SubClass*>(this)-> visitTerminatorInst(static_cast<TerminatorInst&>(I));}
  RetTy visitSwitchInst(SwitchInst &I) { return static_cast<SubClass*>(this)-> visitTerminatorInst(static_cast<TerminatorInst&>(I));}
  RetTy visitIndirectBrInst(IndirectBrInst &I) { return static_cast<SubClass*>(this)-> visitTerminatorInst(static_cast<TerminatorInst&>(I));}
  RetTy visitInvokeInst(InvokeInst &I) { return static_cast<SubClass*>(this)-> visitTerminatorInst(static_cast<TerminatorInst&>(I));}
  RetTy visitUnwindInst(UnwindInst &I) { return static_cast<SubClass*>(this)-> visitTerminatorInst(static_cast<TerminatorInst&>(I));}
  RetTy visitUnreachableInst(UnreachableInst &I) { return static_cast<SubClass*>(this)-> visitTerminatorInst(static_cast<TerminatorInst&>(I));}
  RetTy visitICmpInst(ICmpInst &I) { return static_cast<SubClass*>(this)-> visitCmpInst(static_cast<CmpInst&>(I));}
  RetTy visitFCmpInst(FCmpInst &I) { return static_cast<SubClass*>(this)-> visitCmpInst(static_cast<CmpInst&>(I));}
  RetTy visitAllocaInst(AllocaInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
  RetTy visitLoadInst(LoadInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
  RetTy visitStoreInst(StoreInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
  RetTy visitGetElementPtrInst(GetElementPtrInst &I){ return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
  RetTy visitPHINode(PHINode &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
  RetTy visitTruncInst(TruncInst &I) { return static_cast<SubClass*>(this)-> visitCastInst(static_cast<CastInst&>(I)); }
  RetTy visitZExtInst(ZExtInst &I) { return static_cast<SubClass*>(this)-> visitCastInst(static_cast<CastInst&>(I)); }
  RetTy visitSExtInst(SExtInst &I) { return static_cast<SubClass*>(this)-> visitCastInst(static_cast<CastInst&>(I)); }
  RetTy visitFPTruncInst(FPTruncInst &I) { return static_cast<SubClass*>(this)-> visitCastInst(static_cast<CastInst&>(I)); }
  RetTy visitFPExtInst(FPExtInst &I) { return static_cast<SubClass*>(this)-> visitCastInst(static_cast<CastInst&>(I)); }
  RetTy visitFPToUIInst(FPToUIInst &I) { return static_cast<SubClass*>(this)-> visitCastInst(static_cast<CastInst&>(I)); }
  RetTy visitFPToSIInst(FPToSIInst &I) { return static_cast<SubClass*>(this)-> visitCastInst(static_cast<CastInst&>(I)); }
  RetTy visitUIToFPInst(UIToFPInst &I) { return static_cast<SubClass*>(this)-> visitCastInst(static_cast<CastInst&>(I)); }
  RetTy visitSIToFPInst(SIToFPInst &I) { return static_cast<SubClass*>(this)-> visitCastInst(static_cast<CastInst&>(I)); }
  RetTy visitPtrToIntInst(PtrToIntInst &I) { return static_cast<SubClass*>(this)-> visitCastInst(static_cast<CastInst&>(I)); }
  RetTy visitIntToPtrInst(IntToPtrInst &I) { return static_cast<SubClass*>(this)-> visitCastInst(static_cast<CastInst&>(I)); }
  RetTy visitBitCastInst(BitCastInst &I) { return static_cast<SubClass*>(this)-> visitCastInst(static_cast<CastInst&>(I)); }
  RetTy visitSelectInst(SelectInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
  RetTy visitCallInst(CallInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
  RetTy visitVAArgInst(VAArgInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
  RetTy visitExtractElementInst(ExtractElementInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I));}
  RetTy visitInsertElementInst(InsertElementInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
  RetTy visitShuffleVectorInst(ShuffleVectorInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
  RetTy visitExtractValueInst(ExtractValueInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I));}
  RetTy visitInsertValueInst(InsertValueInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }





  RetTy visitTerminatorInst(TerminatorInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
  RetTy visitBinaryOperator(BinaryOperator &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
  RetTy visitCmpInst(CmpInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }
  RetTy visitCastInst(CastInst &I) { return static_cast<SubClass*>(this)-> visitInstruction(static_cast<Instruction&>(I)); }







  void visitInstruction(Instruction &I) {}
};



}
# 33 "SMTBackend.cc" 2


# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/System/Host.h" 1
# 17 "/local/monniaux/packages/llvm-2.7/include/llvm/System/Host.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringMap.h" 1
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringMap.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Allocator.h" 1
# 17 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Allocator.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/AlignOf.h" 1
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/AlignOf.h"
namespace llvm {

template <typename T>
struct AlignmentCalcImpl {
  char x;
  T t;
private:
  AlignmentCalcImpl() {}
};
# 35 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/AlignOf.h"
template <typename T>
struct AlignOf {
  enum { Alignment =
         static_cast<unsigned int>(sizeof(AlignmentCalcImpl<T>) - sizeof(T)) };

  enum { Alignment_GreaterEqual_2Bytes = Alignment >= 2 ? 1 : 0 };
  enum { Alignment_GreaterEqual_4Bytes = Alignment >= 4 ? 1 : 0 };
  enum { Alignment_GreaterEqual_8Bytes = Alignment >= 8 ? 1 : 0 };
  enum { Alignment_GreaterEqual_16Bytes = Alignment >= 16 ? 1 : 0 };

  enum { Alignment_LessEqual_2Bytes = Alignment <= 2 ? 1 : 0 };
  enum { Alignment_LessEqual_4Bytes = Alignment <= 4 ? 1 : 0 };
  enum { Alignment_LessEqual_8Bytes = Alignment <= 8 ? 1 : 0 };
  enum { Alignment_LessEqual_16Bytes = Alignment <= 16 ? 1 : 0 };

};





template <typename T>
static inline unsigned alignof() { return AlignOf<T>::Alignment; }

}
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Allocator.h" 2

# 1 "/usr/include/c++/4.3/cassert" 1 3
# 47 "/usr/include/c++/4.3/cassert" 3
       
# 48 "/usr/include/c++/4.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 49 "/usr/include/c++/4.3/cassert" 2 3
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Allocator.h" 2
# 1 "/usr/include/c++/4.3/cstdlib" 1 3
# 46 "/usr/include/c++/4.3/cstdlib" 3
       
# 47 "/usr/include/c++/4.3/cstdlib" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 50 "/usr/include/c++/4.3/cstdlib" 2 3
# 21 "/local/monniaux/packages/llvm-2.7/include/llvm/Support/Allocator.h" 2

namespace llvm {

class MallocAllocator {
public:
  MallocAllocator() {}
  ~MallocAllocator() {}

  void Reset() {}

  void *Allocate(size_t Size, size_t ) { return malloc(Size); }

  template <typename T>
  T *Allocate() { return static_cast<T*>(malloc(sizeof(T))); }

  template <typename T>
  T *Allocate(size_t Num) {
    return static_cast<T*>(malloc(sizeof(T)*Num));
  }

  void Deallocate(const void *Ptr) { free(const_cast<void*>(Ptr)); }

  void PrintStats() const {}
};



class MemSlab {
public:
  size_t Size;
  MemSlab *NextPtr;
};






class SlabAllocator {
public:
  virtual ~SlabAllocator();
  virtual MemSlab *Allocate(size_t Size) = 0;
  virtual void Deallocate(MemSlab *Slab) = 0;
};




class MallocSlabAllocator : public SlabAllocator {


  MallocAllocator Allocator;

public:
  MallocSlabAllocator() : Allocator() { }
  virtual ~MallocSlabAllocator();
  virtual MemSlab *Allocate(size_t Size);
  virtual void Deallocate(MemSlab *Slab);
};





class BumpPtrAllocator {
  BumpPtrAllocator(const BumpPtrAllocator &);
  void operator=(const BumpPtrAllocator &);



  size_t SlabSize;



  size_t SizeThreshold;




  SlabAllocator &Allocator;



  MemSlab *CurSlab;



  char *CurPtr;



  char *End;



  size_t BytesAllocated;




  static char *AlignPtr(char *Ptr, size_t Alignment);



  void StartNewSlab();



  void DeallocateSlabs(MemSlab *Slab);

  static MallocSlabAllocator DefaultSlabAllocator;

public:
  BumpPtrAllocator(size_t size = 4096, size_t threshold = 4096,
                   SlabAllocator &allocator = DefaultSlabAllocator);
  ~BumpPtrAllocator();



  void Reset();



  void *Allocate(size_t Size, size_t Alignment);



  template <typename T>
  T *Allocate() {
    return static_cast<T*>(Allocate(sizeof(T),AlignOf<T>::Alignment));
  }



  template <typename T>
  T *Allocate(size_t Num) {
    return static_cast<T*>(Allocate(Num * sizeof(T), AlignOf<T>::Alignment));
  }



  template <typename T>
  T *Allocate(size_t Num, size_t Alignment) {

    size_t EltSize = (sizeof(T)+Alignment-1)&(-Alignment);
    return static_cast<T*>(Allocate(Num * EltSize, Alignment));
  }

  void Deallocate(const void * ) {}

  unsigned GetNumSlabs() const;

  void PrintStats() const;
};

}
# 19 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringMap.h" 2
# 1 "/usr/include/c++/4.3/cstring" 1 3
# 45 "/usr/include/c++/4.3/cstring" 3
       
# 46 "/usr/include/c++/4.3/cstring" 3


# 1 "/usr/include/c++/4.3/cstddef" 1 3
# 45 "/usr/include/c++/4.3/cstddef" 3
       
# 46 "/usr/include/c++/4.3/cstddef" 3


# 1 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/c++/4.3/cstddef" 2 3
# 49 "/usr/include/c++/4.3/cstring" 2 3
# 20 "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringMap.h" 2


namespace llvm {
  template<typename ValueT>
  class StringMapConstIterator;
  template<typename ValueT>
  class StringMapIterator;
  template<typename ValueTy>
  class StringMapEntry;




template<typename ValueTy>
class StringMapEntryInitializer {
public:
  template <typename InitTy>
  static void Initialize(StringMapEntry<ValueTy> &T, InitTy InitVal) {
    T.second = InitVal;
  }
};



class StringMapEntryBase {
  unsigned StrLen;
public:
  explicit StringMapEntryBase(unsigned Len) : StrLen(Len) {}

  unsigned getKeyLength() const { return StrLen; }
};



class StringMapImpl {
public:


  struct ItemBucket {


    unsigned FullHashValue;


    StringMapEntryBase *Item;
  };

protected:
  ItemBucket *TheTable;
  unsigned NumBuckets;
  unsigned NumItems;
  unsigned NumTombstones;
  unsigned ItemSize;
protected:
  explicit StringMapImpl(unsigned itemSize) : ItemSize(itemSize) {

    TheTable = 0;
    NumBuckets = 0;
    NumItems = 0;
    NumTombstones = 0;
  }
  StringMapImpl(unsigned InitSize, unsigned ItemSize);
  void RehashTable();



  bool ShouldRehash() const {



    return NumItems*4 > NumBuckets*3 ||
           NumBuckets-(NumItems+NumTombstones) < NumBuckets/8;
  }






  unsigned LookupBucketFor(StringRef Key);




  int FindKey(StringRef Key) const;



  void RemoveKey(StringMapEntryBase *V);



  StringMapEntryBase *RemoveKey(StringRef Key);
private:
  void init(unsigned Size);
public:
  static StringMapEntryBase *getTombstoneVal() {
    return (StringMapEntryBase*)-1;
  }

  unsigned getNumBuckets() const { return NumBuckets; }
  unsigned getNumItems() const { return NumItems; }

  bool empty() const { return NumItems == 0; }
  unsigned size() const { return NumItems; }
};




template<typename ValueTy>
class StringMapEntry : public StringMapEntryBase {
public:
  ValueTy second;

  explicit StringMapEntry(unsigned strLen)
    : StringMapEntryBase(strLen), second() {}
  StringMapEntry(unsigned strLen, const ValueTy &V)
    : StringMapEntryBase(strLen), second(V) {}

  StringRef getKey() const {
    return StringRef(getKeyData(), getKeyLength());
  }

  const ValueTy &getValue() const { return second; }
  ValueTy &getValue() { return second; }

  void setValue(const ValueTy &V) { second = V; }




  const char *getKeyData() const {return reinterpret_cast<const char*>(this+1);}

  const char *first() const { return getKeyData(); }



  template<typename AllocatorTy, typename InitType>
  static StringMapEntry *Create(const char *KeyStart, const char *KeyEnd,
                                AllocatorTy &Allocator,
                                InitType InitVal) {
    unsigned KeyLength = static_cast<unsigned>(KeyEnd-KeyStart);





    unsigned AllocSize = static_cast<unsigned>(sizeof(StringMapEntry))+
      KeyLength+1;
    unsigned Alignment = alignof<StringMapEntry>();

    StringMapEntry *NewItem =
      static_cast<StringMapEntry*>(Allocator.Allocate(AllocSize,Alignment));


    new (NewItem) StringMapEntry(KeyLength);


    char *StrBuffer = const_cast<char*>(NewItem->getKeyData());
    memcpy(StrBuffer, KeyStart, KeyLength);
    StrBuffer[KeyLength] = 0;


    StringMapEntryInitializer<ValueTy>::Initialize(*NewItem, InitVal);
    return NewItem;
  }

  template<typename AllocatorTy>
  static StringMapEntry *Create(const char *KeyStart, const char *KeyEnd,
                                AllocatorTy &Allocator) {
    return Create(KeyStart, KeyEnd, Allocator, 0);
  }



  template<typename InitType>
  static StringMapEntry *Create(const char *KeyStart, const char *KeyEnd,
                                InitType InitVal) {
    MallocAllocator A;
    return Create(KeyStart, KeyEnd, A, InitVal);
  }

  static StringMapEntry *Create(const char *KeyStart, const char *KeyEnd) {
    return Create(KeyStart, KeyEnd, ValueTy());
  }



  static StringMapEntry &GetStringMapEntryFromValue(ValueTy &V) {
    StringMapEntry *EPtr = 0;
    char *Ptr = reinterpret_cast<char*>(&V) -
                  (reinterpret_cast<char*>(&EPtr->second) -
                   reinterpret_cast<char*>(EPtr));
    return *reinterpret_cast<StringMapEntry*>(Ptr);
  }
  static const StringMapEntry &GetStringMapEntryFromValue(const ValueTy &V) {
    return GetStringMapEntryFromValue(const_cast<ValueTy&>(V));
  }



  template<typename AllocatorTy>
  void Destroy(AllocatorTy &Allocator) {

    this->~StringMapEntry();
    Allocator.Deallocate(this);
  }


  void Destroy() {
    MallocAllocator A;
    Destroy(A);
  }
};






template<typename ValueTy, typename AllocatorTy = MallocAllocator>
class StringMap : public StringMapImpl {
  AllocatorTy Allocator;
  typedef StringMapEntry<ValueTy> MapEntryTy;
public:
  StringMap() : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))) {}
  explicit StringMap(unsigned InitialSize)
    : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))) {}
  explicit StringMap(const StringMap &RHS)
    : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))) {
    ((RHS.empty() && "Copy ctor from non-empty stringmap not implemented yet!") ? static_cast<void> (0) : __assert_fail ("RHS.empty() && \"Copy ctor from non-empty stringmap not implemented yet!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringMap.h", 252, __PRETTY_FUNCTION__));

  }
  void operator=(const StringMap &RHS) {
    ((RHS.empty() && "assignment from non-empty stringmap not implemented yet!") ? static_cast<void> (0) : __assert_fail ("RHS.empty() && \"assignment from non-empty stringmap not implemented yet!\"", "/local/monniaux/packages/llvm-2.7/include/llvm/ADT/StringMap.h", 256, __PRETTY_FUNCTION__));

    clear();
  }


  AllocatorTy &getAllocator() { return Allocator; }
  const AllocatorTy &getAllocator() const { return Allocator; }

  typedef const char* key_type;
  typedef ValueTy mapped_type;
  typedef StringMapEntry<ValueTy> value_type;
  typedef size_t size_type;

  typedef StringMapConstIterator<ValueTy> const_iterator;
  typedef StringMapIterator<ValueTy> iterator;

  iterator begin() {
    return iterator(TheTable, NumBuckets == 0);
  }
  iterator end() {
    return iterator(TheTable+NumBuckets, true);
  }
  const_iterator begin() const {
    return const_iterator(TheTable, NumBuckets == 0);
  }
  const_iterator end() const {
    return const_iterator(TheTable+NumBuckets, true);
  }

  iterator find(StringRef Key) {
    int Bucket = FindKey(Key);
    if (Bucket == -1) return end();
    return iterator(TheTable+Bucket);
  }

  const_iterator find(StringRef Key) const {
    int Bucket = FindKey(Key);
    if (Bucket == -1) return end();
    return const_iterator(TheTable+Bucket);
  }



  ValueTy lookup(StringRef Key) const {
    const_iterator it = find(Key);
    if (it != end())
      return it->second;
    return ValueTy();
  }

  ValueTy& operator[](StringRef Key) {
    return GetOrCreateValue(Key).getValue();
  }

  size_type count(StringRef Key) const {
    return find(Key) == end() ? 0 : 1;
  }




  bool insert(MapEntryTy *KeyValue) {
    unsigned BucketNo = LookupBucketFor(KeyValue->getKey());
    ItemBucket &Bucket = TheTable[BucketNo];
    if (Bucket.Item && Bucket.Item != getTombstoneVal())
      return false;

    if (Bucket.Item == getTombstoneVal())
      --NumTombstones;
    Bucket.Item = KeyValue;
    ++NumItems;

    if (ShouldRehash())
      RehashTable();
    return true;
  }


  void clear() {
    if (empty()) return;



    for (ItemBucket *I = TheTable, *E = TheTable+NumBuckets; I != E; ++I) {
      if (I->Item && I->Item != getTombstoneVal()) {
        static_cast<MapEntryTy*>(I->Item)->Destroy(Allocator);
        I->Item = 0;
      }
    }

    NumItems = 0;
  }




  template <typename InitTy>
  StringMapEntry<ValueTy> &GetOrCreateValue(StringRef Key,
                                            InitTy Val) {
    unsigned BucketNo = LookupBucketFor(Key);
    ItemBucket &Bucket = TheTable[BucketNo];
    if (Bucket.Item && Bucket.Item != getTombstoneVal())
      return *static_cast<MapEntryTy*>(Bucket.Item);

    MapEntryTy *NewItem =
      MapEntryTy::Create(Key.begin(), Key.end(), Allocator, Val);

    if (Bucket.Item == getTombstoneVal())
      --NumTombstones;
    ++NumItems;



    Bucket.Item = NewItem;

    if (ShouldRehash())
      RehashTable();
    return *NewItem;
  }

  StringMapEntry<ValueTy> &GetOrCreateValue(StringRef Key) {
    return GetOrCreateValue(Key, ValueTy());
  }

  template <typename InitTy>
  StringMapEntry<ValueTy> &GetOrCreateValue(const char *KeyStart,
                                            const char *KeyEnd,
                                            InitTy Val) {
    return GetOrCreateValue(StringRef(KeyStart, KeyEnd - KeyStart), Val);
  }

  StringMapEntry<ValueTy> &GetOrCreateValue(const char *KeyStart,
                                            const char *KeyEnd) {
    return GetOrCreateValue(StringRef(KeyStart, KeyEnd - KeyStart));
  }



  void remove(MapEntryTy *KeyValue) {
    RemoveKey(KeyValue);
  }

  void erase(iterator I) {
    MapEntryTy &V = *I;
    remove(&V);
    V.Destroy(Allocator);
  }

  bool erase(StringRef Key) {
    iterator I = find(Key);
    if (I == end()) return false;
    erase(I);
    return true;
  }

  ~StringMap() {
    clear();
    free(TheTable);
  }
};


template<typename ValueTy>
class StringMapConstIterator {
protected:
  StringMapImpl::ItemBucket *Ptr;
public:
  typedef StringMapEntry<ValueTy> value_type;

  explicit StringMapConstIterator(StringMapImpl::ItemBucket *Bucket,
                                  bool NoAdvance = false)
  : Ptr(Bucket) {
    if (!NoAdvance) AdvancePastEmptyBuckets();
  }

  const value_type &operator*() const {
    return *static_cast<StringMapEntry<ValueTy>*>(Ptr->Item);
  }
  const value_type *operator->() const {
    return static_cast<StringMapEntry<ValueTy>*>(Ptr->Item);
  }

  bool operator==(const StringMapConstIterator &RHS) const {
    return Ptr == RHS.Ptr;
  }
  bool operator!=(const StringMapConstIterator &RHS) const {
    return Ptr != RHS.Ptr;
  }

  inline StringMapConstIterator& operator++() {
    ++Ptr;
    AdvancePastEmptyBuckets();
    return *this;
  }
  StringMapConstIterator operator++(int) {
    StringMapConstIterator tmp = *this; ++*this; return tmp;
  }

private:
  void AdvancePastEmptyBuckets() {
    while (Ptr->Item == 0 || Ptr->Item == StringMapImpl::getTombstoneVal())
      ++Ptr;
  }
};

template<typename ValueTy>
class StringMapIterator : public StringMapConstIterator<ValueTy> {
public:
  explicit StringMapIterator(StringMapImpl::ItemBucket *Bucket,
                             bool NoAdvance = false)
    : StringMapConstIterator<ValueTy>(Bucket, NoAdvance) {
  }
  StringMapEntry<ValueTy> &operator*() const {
    return *static_cast<StringMapEntry<ValueTy>*>(this->Ptr->Item);
  }
  StringMapEntry<ValueTy> *operator->() const {
    return static_cast<StringMapEntry<ValueTy>*>(this->Ptr->Item);
  }
};

}
# 18 "/local/monniaux/packages/llvm-2.7/include/llvm/System/Host.h" 2


namespace llvm {
namespace sys {

  inline bool isLittleEndianHost() {
    union {
      int i;
      char c;
    };
    i = 1;
    return c;
  }

  inline bool isBigEndianHost() {
    return !isLittleEndianHost();
  }
# 43 "/local/monniaux/packages/llvm-2.7/include/llvm/System/Host.h"
  std::string getHostTriple();






  std::string getHostCPUName();
# 62 "/local/monniaux/packages/llvm-2.7/include/llvm/System/Host.h"
  bool getHostCPUFeatures(StringMap<bool> &Features);
}
}
# 36 "SMTBackend.cc" 2
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Config/config.h" 1
# 37 "SMTBackend.cc" 2

# 1 "SMTBackend.h" 1
# 38 "SMTBackend.h"
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Config/config.h" 1
# 39 "SMTBackend.h" 2

using namespace llvm;



class SMTBackend : public ModulePass, public InstVisitor<SMTBackend> {
private:
 formatted_raw_ostream &Out;
 std::set<const Argument*> ByValParams;
 std::map<const Instruction*,std::string> locals_name;

 std::multimap<std::string,std::string> branchements;
 static int nstop, nwarn, nfail;
public:
 static char ID;


 SMTBackend (formatted_raw_ostream &o) : ModulePass(&ID), Out(o) {

 }


 ~SMTBackend() {}

 const char *getPassName() const;

 bool runOnModule(Module &M);

 void printFunction(Function* F);

 void printBasicBlock(BasicBlock* blk);

 std::string GetValueName(const Value * Operand);
 std::string GetUserName(const User * Value);


 void visitReturnInst(ReturnInst &I);
 void visitBranchInst(BranchInst &I);
 void visitSwitchInst(SwitchInst &I);

 void visitBinaryOperator(BinaryOperator &I);
 void visitICmpInst(ICmpInst &I);
 void visitFCmpInst(FCmpInst &I);




 void visitLoadInst(LoadInst &I);
 void visitStoreInst(StoreInst &I);
 void visitGetElementPtrInst(GetElementPtrInst &I);
 void visitPHINode(PHINode &I);
 void visitTruncInst(TruncInst &I);
 void visitZExtInst(ZExtInst &I);
 void visitSExtInst(SExtInst &I);
 void visitFPTruncInst(FPTruncInst &I);
 void visitFPExtInst(FPExtInst &I);
 void visitUIToFPInst(UIToFPInst &I);
 void visitSIToFPInst(SIToFPInst &I);
 void visitFPToUIInst(FPToUIInst &I);
 void visitFPToSIInst(FPToSIInst &I);
 void visitPtrToIntInst(PtrToIntInst &I);
 void visitIntToPtrInst(IntToPtrInst &I);
 void visitBitCastInst(BitCastInst &I);
 void visitSelectInst(SelectInst &I);

 void visitCallSite(CallSite CS);
 void visitCallInst(CallInst &I) { visitCallSite (CallSite (&I)); }
 void visitInvokeInst(InvokeInst &I) { visitCallSite (CallSite (&I)); }
 void visitUnwindInst(UnwindInst &I);
 void visitUnreachableInst(UnreachableInst &I);

 void visitShl(BinaryOperator &I);
 void visitLShr(BinaryOperator &I);
 void visitAShr(BinaryOperator &I);

 void visitVAArgInst(VAArgInst &I);
 void visitInstruction(Instruction &I) {



  ((0 && "Instruction not interpretable yet!") ? static_cast<void> (0) : __assert_fail ("0 && \"Instruction not interpretable yet!\"", "SMTBackend.h", 119, __PRETTY_FUNCTION__));
 }
};
# 39 "SMTBackend.cc" 2
# 1 "SMTBackend_decl.h" 1
# 36 "SMTBackend_decl.h"
# 1 "/usr/include/llvm/Support/Mangler.h" 1 3 4
# 17 "/usr/include/llvm/Support/Mangler.h" 3 4
# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/System/IncludeFile.h" 1 3 4
# 53 "/local/monniaux/packages/llvm-2.7/include/llvm/System/IncludeFile.h" 3 4
namespace llvm {
# 73 "/local/monniaux/packages/llvm-2.7/include/llvm/System/IncludeFile.h" 3 4
struct IncludeFile {
  explicit IncludeFile(const void *);
};

}
# 18 "/usr/include/llvm/Support/Mangler.h" 2 3 4




namespace llvm {
class Type;
class Module;
class Value;
class GlobalValue;

class Mangler {


  const char *Prefix;




  bool UseQuotes;



  bool PreserveAsmNames;



  std::map<const Value*, std::string> Memo;



  unsigned Count;



  std::map<const Type*, unsigned> TypeMap;
  unsigned TypeCounter;




  std::set<const GlobalValue*> MangledGlobals;



  unsigned AcceptableChars[256/32];
public:



  Mangler(Module &M, const char *Prefix = "");



  void setUseQuotes(bool Val) { UseQuotes = Val; }



  void setPreserveAsmNames(bool Val) { PreserveAsmNames = Val; }




  void markCharAcceptable(unsigned char X) {
    AcceptableChars[X/32] |= 1 << (X&31);
  }
  void markCharUnacceptable(unsigned char X) {
    AcceptableChars[X/32] &= ~(1 << (X&31));
  }
  bool isCharAcceptable(unsigned char X) const {
    return (AcceptableChars[X/32] & (1 << (X&31))) != 0;
  }



  unsigned getTypeID(const Type *Ty);




  std::string getValueName(const GlobalValue *V, const char *Suffix = "");
  std::string getValueName(const Value *V);
# 107 "/usr/include/llvm/Support/Mangler.h" 3 4
  std::string makeNameProper(const std::string &x, const char *Prefix = "");

private:
  void InsertName(GlobalValue *GV, std::map<std::string, GlobalValue*> &Names);
};

}


namespace llvm { extern const char ManglerLinkVar; __attribute__((used)) static const char *const ManglerLinkObj = &ManglerLinkVar; }
# 37 "SMTBackend_decl.h" 2


# 1 "/local/monniaux/packages/llvm-2.7/include/llvm/Config/config.h" 1
# 40 "SMTBackend_decl.h" 2

using namespace llvm;



class SMTBackend_decl : public InstVisitor<SMTBackend_decl> {
private:
 formatted_raw_ostream &Out;
 std::set<const Argument*> ByValParams;
 std::map<const Instruction*,std::string> * locals_name;

 std::multimap<std::string,std::string> * branchements;
 static int num_local;
 static int nstop, nwarn, nfail;
public:


 SMTBackend_decl (formatted_raw_ostream &o,
    std::map<const Instruction*,std::string> * Map,
    std::multimap<std::string,std::string> * branch) :
 Out(o), locals_name(Map), branchements(branch) {}


 ~SMTBackend_decl() {}

 const char *getPassName() const;

 bool runOnModule(Module &M);

 void printFunction(Function* F);

 void printBasicBlock(BasicBlock* blk);

 std::string GetValueName(const Value * Operand);
 std::string GetUserName(const User * Value);


 void visitReturnInst(ReturnInst &I);
 void visitBranchInst(BranchInst &I);
 void visitSwitchInst(SwitchInst &I);

 void visitBinaryOperator(BinaryOperator &I);
 void visitICmpInst(ICmpInst &I);
 void visitFCmpInst(FCmpInst &I);




 void visitLoadInst(LoadInst &I);
 void visitStoreInst(StoreInst &I);
 void visitGetElementPtrInst(GetElementPtrInst &I);
 void visitPHINode(PHINode &I);
 void visitTruncInst(TruncInst &I);
 void visitZExtInst(ZExtInst &I);
 void visitSExtInst(SExtInst &I);
 void visitFPTruncInst(FPTruncInst &I);
 void visitFPExtInst(FPExtInst &I);
 void visitUIToFPInst(UIToFPInst &I);
 void visitSIToFPInst(SIToFPInst &I);
 void visitFPToUIInst(FPToUIInst &I);
 void visitFPToSIInst(FPToSIInst &I);
 void visitPtrToIntInst(PtrToIntInst &I);
 void visitIntToPtrInst(IntToPtrInst &I);
 void visitBitCastInst(BitCastInst &I);
 void visitSelectInst(SelectInst &I);

 void visitCallSite(CallSite CS);
 void visitCallInst(CallInst &I) { visitCallSite (CallSite (&I)); }
 void visitInvokeInst(InvokeInst &I) { visitCallSite (CallSite (&I)); }
 void visitUnwindInst(UnwindInst &I);
 void visitUnreachableInst(UnreachableInst &I);

 void visitShl(BinaryOperator &I);
 void visitLShr(BinaryOperator &I);
 void visitAShr(BinaryOperator &I);

 void visitVAArgInst(VAArgInst &I);
 void visitInstruction(Instruction &I) {



  ((0 && "Instruction not interpretable yet!") ? static_cast<void> (0) : __assert_fail ("0 && \"Instruction not interpretable yet!\"", "SMTBackend_decl.h", 121, __PRETTY_FUNCTION__));
 }
};
# 40 "SMTBackend.cc" 2



using namespace llvm;
using namespace std;

char SMTBackend::ID = 0;

int SMTBackend::nstop = 0;
int SMTBackend::nwarn = 0;
int SMTBackend::nfail = 0;

const char *SMTBackend::getPassName() const {
 return "not implemented";
}



bool SMTBackend::runOnModule(Module &M){

 Out << "(benchmark VERIMAG\n";
 Out << ":category { random }\n";
 Out << ":status unknown\n";
 Out << ":source { VERIMAG, Synchrone } \n\n";

 SMTBackend_decl * declaration = new SMTBackend_decl(Out,
           &locals_name,
           &branchements);

 for (Module::iterator mIt = M.begin() ; mIt != M.end() ; ++mIt) {
  Function* F = &*mIt;
  declaration->printFunction(F);
 }

 Out << ":formula\n";

 Out << "(and\n";
 for (Module::iterator mIt = M.begin() ; mIt != M.end() ; ++mIt) {
  Function* F = &*mIt;
  printFunction(F);
 }


 if (nwarn > 0) {
  Out << "(or ";
  for (int i=0; i < nwarn; i++) {
   Out << "(and ";
   for (int j=0; j < nstop; j++) {
    Out << "(not stop_" << j << ") ";
   }
   Out << "warn_" << i << ")";
  }
  Out << ")";
 }

 Out << ")";

 Out << ")\n";
 return 0;
}

void SMTBackend::printFunction(Function* F) {
 for (Function::iterator i = F->begin(), e = F->end(); i != e; ++i) {


  printBasicBlock(i);
 }
}

void SMTBackend::printBasicBlock(BasicBlock* blk) {

 Out << "(= " << blk->getName() << " (or ";
 for (multimap<string,string>::iterator i =
       branchements.lower_bound(blk->getName());
      i != branchements.upper_bound(blk->getName());
      i++) {

  Out << " (" << i->second << ")";
 }
 Out << "))\n";

 BasicBlock::iterator i = blk->begin(), e = blk->end();
 Out << "(or (not " << blk->getName() << ")\n";

 ++i;
 if (i != e) {
  Out << "(and\n";
  for (i = blk->begin();i != e; ++i) {
   visit(*i);

  }
  Out << ")";
 } else {
  ostringstream oss;
  oss << (string)blk->getName();
  if (oss.str().compare("return") == 0)
   Out << "false";
  else
   Out << "true";
 }
 Out << ")\n\n";
}

string GetConstantName(const Constant * Value) {
 string Name;
 stringstream ss;

 if (const ConstantInt * Const = dyn_cast < ConstantInt > (Value)) {

  uint64_t Val = Const->getLimitedValue();
  ss << Val;
  Name = ss.str();
 }

 if (Name.empty()) {
  Name = "undef_Constant";
 }
 return Name;
}

string SMTBackend::GetUserName(const User * Value) {

 string Name;
 stringstream ss;

 if (const Constant * Const = dyn_cast < Constant > (Value)) {
  return GetConstantName(Const);
 }

 if (const Instruction * Inst = dyn_cast < Instruction > (Value)) {
  Name = locals_name[Inst];
  if (Name.empty()) {
   Name = "undef_Instruction";
  }
 }

 if (Name.empty()) {
  Name = "undef_User";
 }
 return Name;
}


string SMTBackend::GetValueName(const Value * Operand) {

 string Name = Operand->getNameStr();

 if (const User * Const = dyn_cast < User > (Operand)) {
  return GetUserName(Const);
 }

 if (Name.empty()) {
  Name = "undef_Value";
 }

 return Name;

}



void SMTBackend::visitReturnInst(ReturnInst &I){



}

void SMTBackend::visitBranchInst(BranchInst &I){



 if (I.isConditional()) {
  Out << "(ite "
      << GetValueName(I.getCondition()) << " "
      << I.getSuccessor(0)->getName() << " "
      << I.getSuccessor(1)->getName()
      << ")\n";
 } else {
  Out << "(" << I.getSuccessor(0)->getName() << ")";
 }
}

void SMTBackend::visitSwitchInst(SwitchInst &I){



 string cond = GetValueName(I.getCondition());

 for (unsigned i=1;i<I.getNumCases();i++) {
  Out << "(ite (= " << cond << " "
      << GetConstantName(I.getCaseValue(i)) << ") "
      << I.getSuccessor(i)->getName() << " ";
 }
 Out << I.getDefaultDest()->getName();
 for (unsigned i=1;i<I.getNumCases();i++) {
  Out << ")";
 }
 Out << "\n";
}

void SMTBackend::visitBinaryOperator(BinaryOperator &I){



 Out << "(= " << locals_name[&I] << " (";
 switch (I.getOpcode()) {
 case Instruction::Add:
 case Instruction::FAdd:
  Out << "+ ";
  break;
 case Instruction::Sub:
 case Instruction::FSub:
  Out << "- ";
  break;
 case Instruction::Mul:
 case Instruction::FMul:
  Out << "* ";
  break;
 case Instruction::URem:
 case Instruction::SRem:
 case Instruction::FRem:
  Out << "% ";
  break;
 case Instruction::UDiv:
 case Instruction::SDiv:
 case Instruction::FDiv:
  Out << "/ ";
  break;
 case Instruction::And:
  Out << "and ";
  break;
 case Instruction::Or:
  Out << "or ";
  break;
 case Instruction::Xor:
  Out << "xor ";
  break;
 case Instruction::Shl:
  Out << "<< ";
  break;
 case Instruction::LShr:
 case Instruction::AShr:
 case Instruction::BinaryOpsEnd:
  break;
 }


 Out << GetValueName(I.getOperand(0)) << " " << GetValueName(I.getOperand(1)) << "))\n";

}

void SMTBackend::visitICmpInst(ICmpInst &I){



 Out << "(= " << locals_name[&I] << " (";
 switch (I.getPredicate()) {
 case CmpInst::ICMP_EQ:
  Out << "=";
  break;
 case CmpInst::ICMP_NE:
  Out << "distinct";
  break;
 case CmpInst::ICMP_UGT:
  Out << ">";
  break;
 case CmpInst::ICMP_UGE:
  Out << ">=";
  break;
 case CmpInst::ICMP_ULT:
  Out << "<";
  break;
 case CmpInst::ICMP_ULE:
  Out << "<=";
  break;
 case CmpInst::ICMP_SGT:
  Out << ">";
  break;
 case CmpInst::ICMP_SGE:
  Out << ">=";
  break;
 case CmpInst::ICMP_SLT:
  Out << "<";
  break;
 case CmpInst::ICMP_SLE:
  Out << "<=";
  break;
 default:
  Out << "undef_predicate";
 }

 Out << " " << GetValueName(I.getOperand(0)) << " "
     << GetValueName(I.getOperand(1)) << "))\n";
}

void SMTBackend::visitFCmpInst(FCmpInst &I){



 Out << "(= " << locals_name[&I] << " (";
 switch (I.getPredicate()) {
 case CmpInst::FCMP_FALSE:
  Out << "false";
  break;
 case CmpInst::FCMP_OEQ:
  Out << "=";
  break;
 case CmpInst::FCMP_OGT:
  Out << ">";
  break;
 case CmpInst::FCMP_OGE:
  Out << ">=";
  break;
 case CmpInst::FCMP_OLT:
  Out << "<";
  break;
 case CmpInst::FCMP_OLE:
  Out << "<=";
  break;
 case CmpInst::FCMP_ONE:
  Out << "distinct";
  break;
 case CmpInst::FCMP_ORD:
  Out << "true";
  break;
 case CmpInst::FCMP_UNO:
  Out << "false";
  break;
 case CmpInst::FCMP_UEQ:
  Out << "=";
  break;
 case CmpInst::FCMP_UGT:
  Out << ">";
  break;
 case CmpInst::FCMP_UGE:
  Out << ">=";
  break;
 case CmpInst::FCMP_ULT:
  Out << "<";
  break;
 case CmpInst::FCMP_ULE:
  Out << "<=";
  break;
 case CmpInst::FCMP_UNE:
  Out << "distinct";
  break;
 case CmpInst::FCMP_TRUE:
  Out << "true";
  break;
 default:
  Out << "undef_predicate";
 }

 Out << " " << GetValueName(I.getOperand(0)) << " "
     << GetValueName(I.getOperand(1)) << "))\n";
}
# 411 "SMTBackend.cc"
void SMTBackend::visitLoadInst(LoadInst &I){



}

void SMTBackend::visitStoreInst(StoreInst &I){



}

void SMTBackend::visitGetElementPtrInst(GetElementPtrInst &I){



}

void SMTBackend::visitPHINode(PHINode &I){



 unsigned n = I.getNumIncomingValues();



 Out << "(or ";
 for (unsigned i=0;i<n;i++) {
  Out << I.getIncomingBlock(i)->getName();
  if (i < n - 1)
   Out << " ";
 }
 Out << ")\n";
 Out << "(= " << locals_name[&I] << " ";
 for (unsigned i=0;i<n-1;i++) {
  Out << "(ite ";
  Out << I.getIncomingBlock(i)->getName() << " "
      << GetValueName(I.getIncomingValue(i))
      << " ";
 }
 Out << GetValueName(I.getIncomingValue(n-1));
 for (unsigned i=0;i<n;i++) {
  Out << ")";
 }
 Out << "\n";
}

void SMTBackend::visitTruncInst(TruncInst &I){



}

void SMTBackend::visitZExtInst(ZExtInst &I){



}

void SMTBackend::visitSExtInst(SExtInst &I){



}

void SMTBackend::visitFPTruncInst(FPTruncInst &I){



}

void SMTBackend::visitFPExtInst(FPExtInst &I){



}

void SMTBackend::visitUIToFPInst(UIToFPInst &I){



}

void SMTBackend::visitSIToFPInst(SIToFPInst &I){



}

void SMTBackend::visitFPToUIInst(FPToUIInst &I){



}

void SMTBackend::visitFPToSIInst(FPToSIInst &I){



}

void SMTBackend::visitPtrToIntInst(PtrToIntInst &I){



}

void SMTBackend::visitIntToPtrInst(IntToPtrInst &I){



}

void SMTBackend::visitBitCastInst(BitCastInst &I){



}

void SMTBackend::visitSelectInst(SelectInst &I){




 Out << "(= " << locals_name[&I] << " (ite "
     << GetValueName(I.getCondition()) << " "
     << GetValueName(I.getTrueValue()) << " "
     << GetValueName(I.getFalseValue())
     << "))\n";
}

void SMTBackend::visitCallSite(CallSite CS){
 Instruction* I = CS.getInstruction();



 std::string str;
 raw_string_ostream oss(str);
 oss << *(CS.getCalledFunction());
 if (str.compare(1,29,"declare void @verif_stop(...)") == 0) {




  nstop++;
  Out << "(= "
      << locals_name[I]
      << " true)\n";
 }
 if (str.compare(1,29,"declare void @verif_warn(...)") == 0) {




  nwarn++;
  Out << "(= "
      << locals_name[I]
      << " true)\n";
 }
 if (str.compare(1,29,"declare void @verif_fail(...)") == 0) {




  nfail++;
  Out << "(= "
      << locals_name[I]
      << " true)\n";
 }

 switch (CS.getType()->getTypeID()) {
 case Type::VoidTyID:
  return;
 default:
  Out << "(= " << locals_name[I] << " " << locals_name[I]
      << ")\n";
  break;
 }
}

void SMTBackend::visitUnwindInst(UnwindInst &I){



}

void SMTBackend::visitUnreachableInst(UnreachableInst &I){



 Out << "(false)\n";
}

void SMTBackend::visitShl(BinaryOperator &I){



}

void SMTBackend::visitLShr(BinaryOperator &I){



}

void SMTBackend::visitAShr(BinaryOperator &I){



}

void SMTBackend::visitVAArgInst(VAArgInst &I){



}
